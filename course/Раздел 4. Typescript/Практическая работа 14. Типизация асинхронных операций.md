# Практическая работа 14. Типизация асинхронных операций в TypeScript

## Тема
Типизация асинхронных операций в TypeScript

## Цель
Освоить принципы типизации асинхронных операций в TypeScript, научиться работать с Promise, async/await, обрабатывать ошибки в асинхронном коде, создавать типизированные API запросы и управлять состоянием приложения.

## Теоретическая часть

### Асинхронное программирование в TypeScript
- **Promise** - типизация промисов с Generic типами
- **async/await** - типизация асинхронных функций
- **Обработка ошибок** - типизированные блоки try/catch
- **Promise методы** - Promise.all, Promise.race, Promise.allSettled
- **AbortController** - отмена асинхронных операций

### Типизация HTTP запросов
- **Fetch API** - типизация запросов и ответов
- **REST API** - интерфейсы для данных
- **Статусы ответов** - типизация различных статусов
- **Обработка ошибок** - типизированные ошибки API

### Продвинутые техники
- **Generic типы** для переиспользуемых асинхронных функций
- **Условные типы** для обработки разных ответов
- **Перегрузка функций** для асинхронных методов
- **Type Guards** для проверки типов в runtime

## Ход работы

1. Создать проект с файловой структурой
2. Настроить TypeScript компиляцию
3. Реализовать практический пример
4. Выполнить индивидуальное задание
5. Оформить результаты в README.md
6. Загрузить в Git репозиторий

## Практический пример

```typescript
// Базовые типы для API
interface User {
    id: number;
    name: string;
    email: string;
    website: string;
}

interface Post {
    id: number;
    userId: number;
    title: string;
    body: string;
}

interface Comment {
    id: number;
    postId: number;
    name: string;
    email: string;
    body: string;
}

// Типизированный класс для работы с API
class JSONPlaceholderAPI {
    private readonly baseUrl: string = 'https://jsonplaceholder.typicode.com';

    // Типизированный метод для GET запросов
    private async fetchData<T>(endpoint: string): Promise<T> {
        const response = await fetch(`${this.baseUrl}${endpoint}`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        return await response.json() as T;
    }

    // Асинхронные методы с типизацией
    public async getUsers(): Promise<User[]> {
        return this.fetchData<User[]>('/users');
    }

    public async getUserById(id: number): Promise<User> {
        return this.fetchData<User>(`/users/${id}`);
    }

    public async getPosts(): Promise<Post[]> {
        return this.fetchData<Post[]>('/posts');
    }

    public async getPostsByUserId(userId: number): Promise<Post[]> {
        return this.fetchData<Post[]>(`/users/${userId}/posts`);
    }

    public async getCommentsByPostId(postId: number): Promise<Comment[]> {
        return this.fetchData<Comment[]>(`/posts/${postId}/comments`);
    }

    // Метод с несколькими параллельными запросами
    public async getUserWithPosts(userId: number): Promise<{ user: User; posts: Post[] }> {
        try {
            const [user, posts] = await Promise.all([
                this.getUserById(userId),
                this.getPostsByUserId(userId)
            ]);

            return { user, posts };
        } catch (error) {
            throw new Error(`Failed to fetch user with posts: ${(error as Error).message}`);
        }
    }

    // Метод с обработкой разных сценариев
    public async getPostsWithComments(): Promise<(Post & { comments: Comment[] })[]> {
        try {
            const posts = await this.getPosts();
            const postsWithComments = await Promise.all(
                posts.slice(0, 5).map(async (post) => {
                    const comments = await this.getCommentsByPostId(post.id);
                    return { ...post, comments };
                })
            );

            return postsWithComments;
        } catch (error) {
            console.error('Error fetching posts with comments:', error);
            return [];
        }
    }
}

// Утилиты для работы с асинхронным состоянием
interface AsyncState<T> {
    data: T | null;
    loading: boolean;
    error: string | null;
}

class AsyncDataManager<T> {
    private state: AsyncState<T> = {
        data: null,
        loading: false,
        error: null
    };

    private abortController: AbortController | null = null;

    public async fetchData(
        fetchFn: (signal?: AbortSignal) => Promise<T>,
        onUpdate?: (state: AsyncState<T>) => void
    ): Promise<void> {
        // Отменяем предыдущий запрос
        if (this.abortController) {
            this.abortController.abort();
        }

        this.abortController = new AbortController();
        
        this.setState({ loading: true, error: null }, onUpdate);

        try {
            const data = await fetchFn(this.abortController.signal);
            this.setState({ data, loading: false, error: null }, onUpdate);
        } catch (error) {
            if ((error as Error).name !== 'AbortError') {
                this.setState({ 
                    loading: false, 
                    error: (error as Error).message 
                }, onUpdate);
            }
        }
    }

    public cancel(): void {
        if (this.abortController) {
            this.abortController.abort();
        }
    }

    private setState(
        updates: Partial<AsyncState<T>>, 
        onUpdate?: (state: AsyncState<T>) => void
    ): void {
        this.state = { ...this.state, ...updates };
        if (onUpdate) {
            onUpdate(this.state);
        }
    }

    public getState(): AsyncState<T> {
        return this.state;
    }
}

// Демонстрация работы
async function demonstrateAsyncOperations(): Promise<void> {
    const api = new JSONPlaceholderAPI();
    
    try {
        // Параллельные запросы
        const [users, posts] = await Promise.all([
            api.getUsers(),
            api.getPosts()
        ]);
        
        console.log('Users:', users.length);
        console.log('Posts:', posts.length);

        // Последовательные запросы с зависимостями
        const userWithPosts = await api.getUserWithPosts(1);
        console.log('User with posts:', userWithPosts);

        // Комплексный запрос
        const postsWithComments = await api.getPostsWithComments();
        console.log('Posts with comments:', postsWithComments.length);

    } catch (error) {
        console.error('Demonstration failed:', error);
    }
}
```

## Индивидуальные задания (15 вариантов)

**Вариант 1**: Создайте типизированную систему для работы с погодным API. Реализуйте методы для получения текущей погоды, прогноза и обработки ошибок сети.

**Вариант 2**: Разработайте асинхронный менеджер для работы с локальным хранилищем (localStorage) с типизацией всех операций и поддержкой отмены.

**Вариант 3**: Создайте систему для пакетной обработки файлов с использованием Web File API. Типизируйте операции чтения, обработки и сохранения файлов.

**Вариант 4**: Реализуйте типизированный WebSocket клиент для реального времени обновлений данных с обработкой различных типов сообщений.

**Вариант 5**: Создайте асинхронную систему для работы с геолокацией. Типизируйте получение координат, отслеживание位置 и обработку разрешений.

**Вариант 6**: Разработайте менеджер для параллельной загрузки изображений с прогресс-баром и типизированной обработкой ошибок загрузки.

**Вариант 7**: Создайте систему для работы с IndexedDB с типизированными транзакциями, запросами и асинхронными операциями.

**Вариант 8**: Реализуйте типизированный клиент для GitHub API с методами для поиска репозиториев, пользователей и получения детальной информации.

**Вариант 9**: Создайте асинхронную систему валидации форм с типизированными правилами валидации и цепочками проверок.

**Вариант 10**: Разработайте менеджер для работы с аудио/видео API с типизированными событиями, состояниями и методами управления.

**Вариант 11**: Создайте систему для пакетных HTTP запросов с ограничением количества одновременных соединений и типизацией очереди.

**Вариант 12**: Реализуйте типизированный парсер RSS лент с асинхронной загрузкой и преобразованием данных.

**Вариант 13**: Создайте систему для работы с камерой устройства через MediaDevices API с типизацией потоков и состояний.

**Вариант 14**: Разработайте асинхронный менеджер кэширования с TTL (time-to-live) и типизированными стратегиями кэширования.

**Вариант 15**: Создайте систему для работы с платежным API с типизированными транзакциями, статусами и обработкой webhook.

## Критерии оценки

**5 (Отлично)**:
- Полностью выполнено задание
- Правильно типизированы все асинхронные операции
- Реализована обработка ошибок с типами
- Использованы продвинутые техники (Generic, Promise.all и т.д.)
- Реализована отмена операций
- Код хорошо откомментирован
- README.md полностью заполнен

**4 (Хорошо)**:
- Задание выполнено с незначительными недочетами
- Не все асинхронные операции правильно типизированы
- Неполная обработка ошибок
- README.md заполнен не полностью

**3 (Удовлетворительно)**:
- Выполнена основная часть задания
- Значительные ошибки в типизации асинхронных операций
- Отсутствует обработка ошибок
- README.md заполнен минимально

**2 (Неудовлетворительно)**:
- Задание не выполнено
- Критические ошибки в типизации
- Нет асинхронных операций
- README.md отсутствует или не заполнен

## Контрольные вопросы

1. Как типизировать Promise в TypeScript?
2. Чем отличается типизация async функций от обычных?
3. Как обрабатывать ошибки в асинхронном коде с TypeScript?
4. Что такое Generic типы и как их использовать с Promise?
5. Как реализовать отмену асинхронных операций?
6. Какие методы Promise доступны для работы с несколькими промисами?
7. Как типизировать HTTP ответы с разными статусами?
8. Что такое type guards и как их использовать с асинхронными данными?
9. Как работать с AbortController в TypeScript?
10. Какие лучшие практики типизации асинхронного кода?

---

# Реализация для варианта 1

## Файловая структура проекта

```
practical-work-async-ts/
├── index.html
├── styles.css
├── script.ts
├── script.js
├── images/
│   ├── screenshot1.png
│   └── screenshot2.png
└── README.md
```

## index.html
```html
<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Практическая работа - Типизация асинхронных операций</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>🌤️ Погодное приложение</h1>
        <p class="subtitle">Демонстрация типизации асинхронных операций в TypeScript</p>
        
        <div class="search-section">
            <div class="input-group">
                <input type="text" id="cityInput" placeholder="Введите название города..." value="Moscow">
                <button id="searchBtn" onclick="searchWeather()">Поиск</button>
                <button id="currentLocationBtn" onclick="getCurrentLocationWeather()">📍 Моё местоположение</button>
            </div>
            <div class="loading" id="loadingIndicator" style="display: none;">
                <div class="spinner"></div>
                <span>Загрузка данных...</span>
            </div>
        </div>

        <div class="weather-cards">
            <div class="weather-card" id="currentWeatherCard" style="display: none;">
                <h2>Текущая погода</h2>
                <div class="weather-content" id="currentWeatherContent"></div>
            </div>

            <div class="weather-card" id="forecastCard" style="display: none;">
                <h2>Прогноз на 5 дней</h2>
                <div class="forecast-content" id="forecastContent"></div>
            </div>
        </div>

        <div class="history-section">
            <h2>История запросов</h2>
            <button onclick="clearHistory()">Очистить историю</button>
            <div id="historyContainer"></div>
        </div>

        <div class="api-status">
            <h2>Статус API</h2>
            <div class="status-items" id="apiStatus"></div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
```

## styles.css
```css
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

:root {
    --primary: #3498db;
    --secondary: #2c3e50;
    --success: #27ae60;
    --warning: #f39c12;
    --danger: #e74c3c;
    --light: #ecf0f1;
    --dark: #2c3e50;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #74b9ff 0%, #0984e3 100%);
    color: #333;
    line-height: 1.6;
    min-height: 100vh;
    padding: 20px;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    background: rgba(255, 255, 255, 0.95);
    border-radius: 20px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.1);
    overflow: hidden;
    backdrop-filter: blur(10px);
}

h1 {
    text-align: center;
    color: var(--secondary);
    padding: 30px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    margin-bottom: 0;
    font-size: 2.5rem;
}

.subtitle {
    text-align: center;
    color: #7f8c8d;
    margin-bottom: 30px;
    font-size: 1.1rem;
}

.search-section {
    padding: 30px;
    background: var(--light);
    border-bottom: 1px solid #bdc3c7;
}

.input-group {
    display: flex;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

input {
    flex: 1;
    min-width: 250px;
    padding: 15px 20px;
    border: 2px solid #bdc3c7;
    border-radius: 12px;
    font-size: 16px;
    transition: all 0.3s ease;
    background: white;
}

input:focus {
    outline: none;
    border-color: var(--primary);
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

button {
    padding: 15px 25px;
    border: none;
    border-radius: 12px;
    cursor: pointer;
    font-size: 16px;
    font-weight: 600;
    transition: all 0.3s ease;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

#searchBtn {
    background: var(--primary);
    color: white;
}

#currentLocationBtn {
    background: var(--success);
    color: white;
}

button:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
}

#searchBtn:hover {
    background: #2980b9;
}

#currentLocationBtn:hover {
    background: #219a52;
}

.loading {
    display: flex;
    align-items: center;
    gap: 15px;
    color: var(--primary);
    font-weight: 600;
}

.spinner {
    width: 20px;
    height: 20px;
    border: 2px solid #f3f3f3;
    border-top: 2px solid var(--primary);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.weather-cards {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 30px;
    padding: 30px;
}

.weather-card {
    background: white;
    padding: 25px;
    border-radius: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    border: 1px solid #e1e8ed;
}

.weather-card h2 {
    color: var(--secondary);
    margin-bottom: 20px;
    border-bottom: 2px solid var(--primary);
    padding-bottom: 10px;
}

.weather-content {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.weather-item {
    display: flex;
    justify-content: between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid #ecf0f1;
}

.weather-item:last-child {
    border-bottom: none;
}

.weather-label {
    font-weight: 600;
    color: var(--dark);
    min-width: 120px;
}

.weather-value {
    color: var(--secondary);
    font-weight: 500;
}

.temperature {
    font-size: 2rem;
    font-weight: bold;
    color: var(--primary);
}

.forecast-content {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 15px;
}

.forecast-day {
    background: var(--light);
    padding: 15px;
    border-radius: 10px;
    text-align: center;
    transition: transform 0.2s ease;
}

.forecast-day:hover {
    transform: translateY(-3px);
}

.forecast-date {
    font-weight: 600;
    color: var(--dark);
    margin-bottom: 8px;
}

.forecast-temp {
    font-size: 1.2rem;
    font-weight: bold;
    color: var(--primary);
    margin: 5px 0;
}

.forecast-desc {
    font-size: 0.9rem;
    color: #7f8c8d;
}

.history-section, .api-status {
    padding: 30px;
    background: var(--light);
    border-top: 1px solid #bdc3c7;
}

.history-section h2, .api-status h2 {
    color: var(--secondary);
    margin-bottom: 20px;
}

.history-section button {
    background: var(--warning);
    color: white;
    margin-bottom: 20px;
}

.history-section button:hover {
    background: #e67e22;
}

.history-item {
    background: white;
    padding: 15px;
    margin: 10px 0;
    border-radius: 8px;
    border-left: 4px solid var(--primary);
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.status-items {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 15px;
}

.status-item {
    background: white;
    padding: 15px;
    border-radius: 8px;
    text-align: center;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
}

.status-online {
    border-left: 4px solid var(--success);
}

.status-offline {
    border-left: 4px solid var(--danger);
}

.error-message {
    background: #fadbd8;
    color: var(--danger);
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid var(--danger);
    margin: 10px 0;
}

.success-message {
    background: #d4edda;
    color: var(--success);
    padding: 15px;
    border-radius: 8px;
    border-left: 4px solid var(--success);
    margin: 10px 0;
}

@media (max-width: 768px) {
    .weather-cards {
        grid-template-columns: 1fr;
    }
    
    .input-group {
        flex-direction: column;
    }
    
    input, button {
        min-width: 100%;
    }
    
    .container {
        margin: 10px;
        border-radius: 15px;
    }
    
    h1 {
        font-size: 2rem;
        padding: 20px;
    }
}
```

## script.ts
```typescript
// Типы для погодных данных
interface WeatherMain {
    temp: number;
    feels_like: number;
    temp_min: number;
    temp_max: number;
    pressure: number;
    humidity: number;
    sea_level?: number;
    grnd_level?: number;
}

interface WeatherDescription {
    id: number;
    main: string;
    description: string;
    icon: string;
}

interface Wind {
    speed: number;
    deg: number;
    gust?: number;
}

interface Clouds {
    all: number;
}

interface SystemInfo {
    type: number;
    id: number;
    country: string;
    sunrise: number;
    sunset: number;
}

interface CurrentWeather {
    coord: {
        lon: number;
        lat: number;
    };
    weather: WeatherDescription[];
    base: string;
    main: WeatherMain;
    visibility: number;
    wind: Wind;
    clouds: Clouds;
    dt: number;
    sys: SystemInfo;
    timezone: number;
    id: number;
    name: string;
    cod: number;
}

interface ForecastItem {
    dt: number;
    main: WeatherMain;
    weather: WeatherDescription[];
    clouds: Clouds;
    wind: Wind;
    visibility: number;
    pop: number;
    sys: {
        pod: string;
    };
    dt_txt: string;
}

interface WeatherForecast {
    cod: string;
    message: number;
    cnt: number;
    list: ForecastItem[];
    city: {
        id: number;
        name: string;
        coord: {
            lat: number;
            lon: number;
        };
        country: string;
        population: number;
        timezone: number;
        sunrise: number;
        sunset: number;
    };
}

interface WeatherHistoryItem {
    city: string;
    timestamp: number;
    temperature: number;
    description: string;
}

// Типы для состояния приложения
interface WeatherState {
    current: CurrentWeather | null;
    forecast: WeatherForecast | null;
    loading: boolean;
    error: string | null;
    history: WeatherHistoryItem[];
}

// Класс для работы с Weather API
class WeatherAPI {
    private readonly apiKey: string = 'your_api_key_here'; // Замените на реальный API ключ
    private readonly baseUrl: string = 'https://api.openweathermap.org/data/2.5';
    private abortController: AbortController | null = null;

    // Обобщенный метод для выполнения запросов
    private async fetchWithTimeout<T>(
        url: string, 
        timeout: number = 10000
    ): Promise<T> {
        // Создаем AbortController для отмены запроса
        this.abortController = new AbortController();
        const timeoutId = setTimeout(() => {
            this.abortController?.abort();
        }, timeout);

        try {
            const response = await fetch(url, {
                signal: this.abortController.signal
            });

            clearTimeout(timeoutId);

            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const data: T = await response.json();
            return data;
        } catch (error) {
            if ((error as Error).name === 'AbortError') {
                throw new Error('Request timeout');
            }
            throw error;
        }
    }

    // Получение текущей погоды
    public async getCurrentWeather(city: string): Promise<CurrentWeather> {
        const url = `${this.baseUrl}/weather?q=${encodeURIComponent(city)}&appid=${this.apiKey}&units=metric&lang=ru`;
        return this.fetchWithTimeout<CurrentWeather>(url);
    }

    // Получение погоды по координатам
    public async getCurrentWeatherByCoords(lat: number, lon: number): Promise<CurrentWeather> {
        const url = `${this.baseUrl}/weather?lat=${lat}&lon=${lon}&appid=${this.apiKey}&units=metric&lang=ru`;
        return this.fetchWithTimeout<CurrentWeather>(url);
    }

    // Получение прогноза погоды
    public async getWeatherForecast(city: string): Promise<WeatherForecast> {
        const url = `${this.baseUrl}/forecast?q=${encodeURIComponent(city)}&appid=${this.apiKey}&units=metric&lang=ru`;
        return this.fetchWithTimeout<WeatherForecast>(url);
    }

    // Параллельное получение текущей погоды и прогноза
    public async getCompleteWeatherData(city: string): Promise<{
        current: CurrentWeather;
        forecast: WeatherForecast;
    }> {
        try {
            const [current, forecast] = await Promise.all([
                this.getCurrentWeather(city),
                this.getWeatherForecast(city)
            ]);

            return { current, forecast };
        } catch (error) {
            throw new Error(`Failed to fetch complete weather data: ${(error as Error).message}`);
        }
    }

    // Отмена текущего запроса
    public cancelCurrentRequest(): void {
        if (this.abortController) {
            this.abortController.abort();
        }
    }

    // Проверка доступности API
    public async checkAPIStatus(): Promise<boolean> {
        try {
            await this.fetchWithTimeout(`${this.baseUrl}/weather?q=London&appid=${this.apiKey}`, 5000);
            return true;
        } catch {
            return false;
        }
    }
}

// Класс для управления состоянием приложения
class WeatherApp {
    private state: WeatherState = {
        current: null,
        forecast: null,
        loading: false,
        error: null,
        history: this.loadHistory()
    };

    private api: WeatherAPI = new WeatherAPI();

    // Публичные методы
    public async searchWeather(city: string): Promise<void> {
        this.setLoading(true);
        this.setError(null);

        try {
            const data = await this.api.getCompleteWeatherData(city);
            
            this.setState({
                current: data.current,
                forecast: data.forecast,
                loading: false
            });

            this.addToHistory(city, data.current);
            this.updateDisplay();
        } catch (error) {
            this.setError((error as Error).message);
            this.setLoading(false);
        }
    }

    public async getCurrentLocationWeather(): Promise<void> {
        this.setLoading(true);
        this.setError(null);

        try {
            const position = await this.getCurrentPosition();
            const weather = await this.api.getCurrentWeatherByCoords(
                position.coords.latitude,
                position.coords.longitude
            );

            this.setState({
                current: weather,
                loading: false
            });

            this.addToHistory(weather.name, weather);
            this.updateDisplay();
        } catch (error) {
            this.setError((error as Error).message);
            this.setLoading(false);
        }
    }

    public cancelRequest(): void {
        this.api.cancelCurrentRequest();
        this.setLoading(false);
    }

    public clearHistory(): void {
        this.setState({ history: [] });
        localStorage.removeItem('weatherHistory');
        this.updateHistoryDisplay();
    }

    // Приватные методы
    private setLoading(loading: boolean): void {
        this.state.loading = loading;
        this.updateLoadingDisplay();
    }

    private setError(error: string | null): void {
        this.state.error = error;
        if (error) {
            this.showError(error);
        }
    }

    private setState(updates: Partial<WeatherState>): void {
        this.state = { ...this.state, ...updates };
    }

    private async getCurrentPosition(): Promise<GeolocationPosition> {
        return new Promise((resolve, reject) => {
            if (!navigator.geolocation) {
                reject(new Error('Geolocation is not supported'));
                return;
            }

            navigator.geolocation.getCurrentPosition(resolve, reject, {
                timeout: 10000,
                enableHighAccuracy: true
            });
        });
    }

    private addToHistory(city: string, weather: CurrentWeather): void {
        const historyItem: WeatherHistoryItem = {
            city,
            timestamp: Date.now(),
            temperature: Math.round(weather.main.temp),
            description: weather.weather[0].description
        };

        this.state.history.unshift(historyItem);
        this.state.history = this.state.history.slice(0, 10); // Ограничиваем историю 10 записями
        this.saveHistory();
        this.updateHistoryDisplay();
    }

    private loadHistory(): WeatherHistoryItem[] {
        try {
            const stored = localStorage.getItem('weatherHistory');
            return stored ? JSON.parse(stored) : [];
        } catch {
            return [];
        }
    }

    private saveHistory(): void {
        try {
            localStorage.setItem('weatherHistory', JSON.stringify(this.state.history));
        } catch (error) {
            console.error('Failed to save history:', error);
        }
    }

    // Методы обновления UI
    private updateDisplay(): void {
        this.updateCurrentWeatherDisplay();
        this.updateForecastDisplay();
    }

    private updateCurrentWeatherDisplay(): void {
        const card = document.getElementById('currentWeatherCard');
        const content = document.getElementById('currentWeatherContent');

        if (!this.state.current || !card || !content) return;

        const weather = this.state.current;
        card.style.display = 'block';

        content.innerHTML = `
            <div class="weather-item">
                <span class="weather-label">Город:</span>
                <span class="weather-value">${weather.name}, ${weather.sys.country}</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Температура:</span>
                <span class="weather-value temperature">${Math.round(weather.main.temp)}°C</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Ощущается как:</span>
                <span class="weather-value">${Math.round(weather.main.feels_like)}°C</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Погода:</span>
                <span class="weather-value">${weather.weather[0].description}</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Влажность:</span>
                <span class="weather-value">${weather.main.humidity}%</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Ветер:</span>
                <span class="weather-value">${weather.wind.speed} м/с</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Давление:</span>
                <span class="weather-value">${weather.main.pressure} hPa</span>
            </div>
            <div class="weather-item">
                <span class="weather-label">Видимость:</span>
                <span class="weather-value">${weather.visibility / 1000} км</span>
            </div>
        `;
    }

    private updateForecastDisplay(): void {
        const card = document.getElementById('forecastCard');
        const content = document.getElementById('forecastContent');

        if (!this.state.forecast || !card || !content) return;

        const forecast = this.state.forecast;
        card.style.display = 'block';

        // Группируем прогноз по дням
        const dailyForecast = forecast.list.filter((item, index) => index % 8 === 0).slice(0, 5);

        content.innerHTML = dailyForecast.map(item => `
            <div class="forecast-day">
                <div class="forecast-date">${new Date(item.dt * 1000).toLocaleDateString('ru-RU', { 
                    weekday: 'short', 
                    month: 'short', 
                    day: 'numeric' 
                })}</div>
                <div class="forecast-temp">${Math.round(item.main.temp)}°C</div>
                <div class="forecast-desc">${item.weather[0].description}</div>
                <div class="weather-details">
                    <small>💧 ${item.main.humidity}%</small>
                    <small>💨 ${item.wind.speed} м/с</small>
                </div>
            </div>
        `).join('');
    }

    private updateLoadingDisplay(): void {
        const loadingIndicator = document.getElementById('loadingIndicator');
        if (loadingIndicator) {
            loadingIndicator.style.display = this.state.loading ? 'flex' : 'none';
        }
    }

    private updateHistoryDisplay(): void {
        const container = document.getElementById('historyContainer');
        if (!container) return;

        container.innerHTML = this.state.history.map(item => `
            <div class="history-item">
                <strong>${item.city}</strong> - ${item.temperature}°C
                <br>
                <small>${item.description} • ${new Date(item.timestamp).toLocaleString('ru-RU')}</small>
            </div>
        `).join('') || '<p>История запросов пуста</p>';
    }

    private showError(message: string): void {
        // Можно улучшить отображение ошибок
        console.error('Weather error:', message);
        alert(`Ошибка: ${message}`);
    }

    // Публичный метод для проверки статуса API
    public async checkAPIStatus(): Promise<void> {
        const statusContainer = document.getElementById('apiStatus');
        if (!statusContainer) return;

        const isOnline = await this.api.checkAPIStatus();
        
        statusContainer.innerHTML = `
            <div class="status-item ${isOnline ? 'status-online' : 'status-offline'}">
                <h3>Weather API</h3>