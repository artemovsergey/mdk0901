
# Лекция 11. Введение в TypeScript — Надежный JavaScript

**Цель лекции:** Понять, что такое TypeScript, почему он стал критически важным инструментом в современной фронтенд-разработке, и освоить его базовые концепции на практике.

**Целевая аудитория:** Студенты, знакомые с основами JavaScript.

---

### **План лекции:**

1.  **Что такое TypeScript и зачем он нужен?**
    *   Проблемы JavaScript в больших проектах.
    *   Определение TypeScript.
    *   Преимущества: статическая типизация, инструменты разработчика, предсказуемость кода.

2.  **Базовая система типов**
    *   Аннотации типов (Type Annotations).
    *   Примитивные типы: `string`, `number`, `boolean`.
    *   Массивы и кортежи (Tuples).
    *   Типы `any`, `unknown` и `void`.
    *   Вывод типов (Type Inference).

3.  **Специальные типы и интерфейсы**
    *   Объединения (Unions) и литеральные типы.
    *   Интерфейсы (Interfaces) для описания объектов.
    *   Опциональные свойства и псевдонимы типов (Type Aliases).

4.  **Функции в TypeScript**
    *   Типизация параметров и возвращаемого значения.
    *   Опциональные и параметры по умолчанию.
    *   Перегрузка функций (Function Overloads).

5.  **Компиляция TypeScript в JavaScript**
    *   Что такое компиляция и зачем она нужна?
    *   Файл `tsconfig.json` — сердце проекта TS.
    *   Обзор ключевых настроек компилятора.

6.  **Итоги и дальнейшие шаги**

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Что такое TypeScript и зачем он нужен?**

**Проблемы "большого" JavaScript:**

Представьте, вы работаете в команде над приложением с 1000+ файлов. В JavaScript можно легко допустить ошибку, которую заметишь только при запуске программы.

```javascript
// Чистый JavaScript
function calculateTotal(price, quantity) {
    return price * quantity;
}

// Где-то в другом файле, спустя месяц...
const total = calculateTotal("100", 5); // Передана строка! Получим NaN.
console.log(total); // NaN
```
Эта ошибка не проявится до момента выполнения кода. TypeScript решает эту проблему.

**Определение:**
**TypeScript** — это строго типизированный *надмножество* JavaScript. Это значит, что:
*   Весь код JS является валидным кодом TS.
*   TS добавляет в него систему типов и другие возможности.
*   Код TS *компилируется* (точнее, транcпилируется) в чистый JS.

**Ключевые преимущества:**
*   **Статическая типизация:** Типы проверяются во время *компиляции*, а не выполнения. Ошибки находят раньше.
*   **Улучшенные инструменты разработки:** IDE (VSCode, WebStorm) используют информацию о типах для предоставления умного автодополнения, навигации по коду и рефакторинга.
*   **Предсказуемость:** Код становится самодокументируемым и менее подверженным скрытым багам.
*   **Лучшая масштабируемость:** TypeScript невероятно полезен в больших командах и проектах.

---

#### **2. Базовая система типов**

**Аннотации типов (Type Annotations):**
Синтаксис для явного указания типа переменной, параметра функции или возвращаемого значения.

```typescript
// Синтаксис: let variableName: type = value;

let userName: string = "Alice";
let userAge: number = 25;
let isActive: boolean = true;
```

**Примитивные типы:**
Аналогичны JavaScript: `string`, `number`, `boolean`.

**Массивы и кортежи (Tuples):**
*   **Массивы:** Можно описать двумя способами.
    ```typescript
    let list1: number[] = [1, 2, 3];
    let list2: Array<number> = [1, 2, 3]; // Дженерик-синтаксис
    ```
*   **Кортежи (Tuples):** Массив фиксированной длины с известными типами в каждой позиции.
    ```typescript
    let person: [string, number];
    person = ["Alice", 25]; // OK
    person = [25, "Alice"]; // Ошибка! Типы не совпадают.
    ```

**Специальные типы:**
*   `any`: Отключает проверку типов для переменной. Использовать только в крайних случаях!
    ```typescript
    let data: any = "could be anything";
    data = 42; // OK
    data = true; // OK
    ```
*   `unknown`: Более безопасная альтернатива `any`. Перед использованием значения типа `unknown` нужно проверить его тип.
    ```typescript
    let userInput: unknown;
    userInput = 5;
    userInput = "Hello";

    let myString: string = userInput; // Ошибка! unknown нельзя присвоить string.
    // Нужна проверка:
    if (typeof userInput === "string") {
        let myString: string = userInput; // OK
    }
    ```
*   `void`: Используется для функций, которые не возвращают значение.
    ```typescript
    function logMessage(message: string): void {
        console.log(message);
        // return; // Неявно возвращается undefined
    }
    ```

**Вывод типов (Type Inference):**
TypeScript умен! Он часто может самостоятельно определить тип переменной.

```typescript
let greeting = "Hello, World!"; // TypeScript автоматически понимает, что greeting - string
greeting = 123; // Ошибка! Тип number не может быть присвоен типу string.
```

---

#### **3. Специальные типы и интерфейсы**

**Объединения (Unions) и литеральные типы:**
*   **Union Types:** Позволяют переменной иметь несколько типов.
    ```typescript
    let id: string | number;
    id = "ABC123"; // OK
    id = 123; // OK
    id = true; // Ошибка!
    ```
*   **Литеральные типы:** Позволяют указать точное значение, которое может иметь переменная.
    ```typescript
    let direction: "left" | "right" | "up" | "down";
    direction = "left"; // OK
    direction = "north"; // Ошибка!
    ```

**Интерфейсы (Interfaces):**
Используются для описания "формы" объекта — какие свойства и методы он должен иметь.

```typescript
// Объявление интерфейса
interface User {
    id: number;
    name: string;
    email?: string; // Опциональное свойство (может быть, а может и нет)
}

// Использование интерфейса
const alice: User = {
    id: 1,
    name: "Alice"
    // email - необязателен, так что его можно не указывать
};

const bob: User = {
    id: "2", // Ошибка! Тип string не может быть присвоен типу number.
    name: "Bob",
    age: 30 // Ошибка! Свойства 'age' нет в интерфейсе 'User'.
};
```

**Псевдонимы типов (Type Aliases):**
Альтернатива интерфейсам для создания псевдонимов для типов.

```typescript
type Point = {
    x: number;
    y: number;
};

type ID = number | string;
```

*Чем `interface` отличается от `type`?* `interface` более мощный для описания объектов и может быть расширен (с помощью `extends`), в то время как `type` более универсален и может описать любой тип, включая объединения и примитивы.

---

#### **4. Функции в TypeScript**

**Типизация параметров и возвращаемого значения:**

```typescript
// Явное указание типов для параметров и возвращаемого значения
function add(x: number, y: number): number {
    return x + y;
}
```

**Опциональные параметры и параметры по умолчанию:**
*   **Опциональные параметры:** Обозначаются символом `?`.
    ```typescript
    function greet(name: string, greeting?: string): string {
        if (greeting) {
            return `${greeting}, ${name}!`;
        }
        return `Hello, ${name}!`;
    }
    greet("Alice"); // OK
    greet("Bob", "Hi"); // OK
    ```
*   **Параметры по умолчанию:** Тип выводится из значения по умолчанию.
    ```typescript
    function createMessage(text: string, priority: "low" | "high" = "low"): string {
        return `[${priority}] ${text}`;
    }
    createMessage("Hello"); // Будет "[low] Hello"
    ```

**Перегрузка функций (Function Overloads):**
Позволяет функции вести себя по-разному в зависимости от количества и типов аргументов.

```typescript
// Сигнатуры перегрузки
function processInput(input: string): string;
function processInput(input: number): number;

// Реализация функции
function processInput(input: string | number): string | number {
    if (typeof input === "string") {
        return input.toUpperCase();
    } else {
        return input * 2;
    }
}

const result1 = processInput("hello"); // result1 имеет тип string
const result2 = processInput(10); // result2 имеет тип number
```

---

#### **5. Компиляция TypeScript в JavaScript**

**Что такое компиляция?**
TypeScript-компилятор (`tsc`) берет ваш `.ts` файл и преобразует его в чистый, работающий в браузере JavaScript-код (`.js`). При этом он удаляет все аннотации типов и проводит проверки.

**Файл `tsconfig.json`:**
Это конфигурационный файл, который сообщает компилятору, *как* компилировать ваш проект.

```json
// Пример tsconfig.json
{
  "compilerOptions": {
    "target": "ES6",        // В какую версию JS компилировать (ES5, ES6, ES2022...)
    "module": "commonjs",   // Система модулей (commonjs, es2015, amd...)
    "outDir": "./dist",     // Папка для скомпилированных JS-файлов
    "rootDir": "./src",     // Папка с исходными TS-файлами
    "strict": true,         // Включает все строгие проверки типов (РЕКОМЕНДУЕТСЯ!)
    "noImplicitAny": true   // Выдавать ошибку, если тип неявно становится 'any'
  },
  "include": ["src/**/*"]   // Какие файлы компилировать
}
```

**Процесс работы:**
1.  Пишете код в файлах `.ts`.
2.  Запускаете `tsc` в терминале (он прочитает `tsconfig.json`).
3.  Получаете готовые `.js` файлы в папке `dist/`.
4.  Запускаете эти `.js` файлы в браузере или Node.js.

---

### **Резюме**

*   **TypeScript — это JavaScript с типами.** Он помогает писать более надежный и сопровождаемый код.
*   **Система типов** является статической и проверяется во время компиляции.
*   **Основные кирпичики системы типов:** примитивы, массивы, кортежи, объединения, интерфейсы и псевдонимы типов.
*   **Функции** могут иметь типизированные параметры, возвращаемые значения и поддерживают перегрузку.
*   **Компилятор TypeScript (`tsc`)** преобразует TS в JS, а его поведение настраивается через `tsconfig.json`.
*   Главное преимущество — **обнаружение ошибок на ранней стадии** и **улучшение опыта разработки**.

---

### **Контрольные вопросы**

1.  Объясните, какую основную проблему JavaScript решает TypeScript? Приведите пример.
2.  Что такое "статическая типизация" и чем она отличается от "динамической типизации" в JavaScript?
3.  В чем разница между типом `any` и `unknown`? Какой из них более безопасен и почему?
4.  Объявите интерфейс `Book` со свойствами `title` (строка), `pages` (число) и опциональным свойством `genre` (строка). Создайте объект, соответствующий этому интерфейсу.
5.  Напишите функцию `multiply`, которая принимает два числа и возвращает их произведение. Добавьте типы для параметров и возвращаемого значения.
6.  Что делает файл `tsconfig.json` и почему он важен в проекте TypeScript?
7.  Какой тип будет у переменной `message` в следующем коде благодаря выводу типов?
    ```typescript
    let message = "This is a string";
    ```
8.  Что такое "перегрузка функций" и в каких сценариях она может быть полезна?