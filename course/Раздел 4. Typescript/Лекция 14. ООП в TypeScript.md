# Лекция 13. Объектно-Ориентированное Программирование в TypeScript

**Цель лекции:** Понимать принципы ООП и уметь применять их на практике в TypeScript для создания хорошо структурированного, переиспользуемого и поддерживаемого кода.

**Целевая аудитория:** Студенты, знакомые с основами TypeScript и JavaScript.

---

### **План лекции:**

1.  **Введение в ООП**
    *   Что такое ООП и зачем оно нужно?
    *   Четыре столпа ООП: инкапсуляция, наследование, полиморфизм, абстракция.
    *   ООП в контексте TypeScript.

2.  **Классы и объекты**
    *   Объявление классов.
    *   Конструктор и свойства.
    *   Создание объектов (экземпляров класса).

3.  **Модификаторы доступа**
    *   `public`, `private`, `protected`.
    *   Readonly свойства.

4.  **Наследование**
    *   Ключевое слово `extends`.
    *   Переопределение методов.
    *   Ключевое слово `super`.

5.  **Абстрактные классы и методы**
    *   Концепция абстракции.
    *   Абстрактные классы.
    *   Абстрактные методы.

6.  **Интерфейсы в ООП**
    *   Интерфейсы vs Абстрактные классы.
    *   Реализация интерфейсов.
    *   Опциональные свойства и readonly в интерфейсах.

7.  **Полиморфизм**
    *   Полиморфизм через наследование.
    *   Полиморфизм через интерфейсы.

8.  **Статические свойства и методы**
    *   Ключевое слово `static`.
    *   Когда использовать статические члены класса.

9.  **Геттеры и сеттеры**
    *   Контроль доступа к свойствам.
    *   Логика при получении и установке значений.

10. **Итоги и лучшие практики**

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Введение в ООП**

**Что такое ООП?**
Объектно-Ориентированное Программирование — это парадигма программирования, в которой программа организована вокруг объектов, содержащих данные и поведение. Вместо того чтобы писать процедуры, которые выполняют операции над данными, мы создаем объекты, которые инкапсулируют и данные, и методы для работы с ними.

**Зачем нужно ООП?**
*   **Структурирование кода:** Помогает организовать сложный код в логические единицы.
*   **Повторное использование:** Классы можно использовать многократно для создания похожих объектов.
*   **Сопровождаемость:** Изменения в одной части системы меньше влияют на другие.
*   **Моделирование реального мира:** Позволяет создавать программные модели реальных сущностей.

**Четыре столпа ООП:**
1.  **Инкапсуляция:** Сокрытие внутренней реализации и предоставление контролируемого доступа.
2.  **Наследование:** Возможность создавать новые классы на основе существующих.
3.  **Полиморфизм:** Возможность объектов с одинаковой спецификацией иметь различную реализацию.
4.  **Абстракция:** Сокрытие сложной реализации и предоставление простого интерфейса.

**ООП в TypeScript:**
TypeScript предоставляет полноценную поддержку ООП с классами, интерфейсами и модификаторами доступа, которые компилируются в JavaScript (обычно в ES5/ES6 классы или функции-конструкторы).

---

#### **2. Классы и объекты**

**Класс** — это шаблон или чертеж для создания объектов. Он определяет, какие свойства и методы будут у объектов.

**Объект (экземпляр класса)** — это конкретная реализация класса.

```typescript
class Car {
    // Свойства (данные)
    brand: string;
    model: string;
    year: number;

    // Конструктор - специальный метод для инициализации объекта
    constructor(brand: string, model: string, year: number) {
        this.brand = brand;
        this.model = model;
        this.year = year;
    }

    // Метод (поведение)
    startEngine(): void {
        console.log(`Двигатель ${this.brand} ${this.model} запущен!`);
    }

    getCarInfo(): string {
        return `Марка: ${this.brand}, Модель: ${this.model}, Год: ${this.year}`;
    }
}

// Создание объектов (экземпляров класса)
const myCar = new Car("Toyota", "Camry", 2022);
const yourCar = new Car("Honda", "Civic", 2020);

myCar.startEngine(); // "Двигатель Toyota Camry запущен!"
console.log(yourCar.getCarInfo()); // "Марка: Honda, Модель: Civic, Год: 2020"
```

---

#### **3. Модификаторы доступа**

TypeScript предоставляет модификаторы доступа для контроля видимости свойств и методов класса.

*   **`public`** (по умолчанию): Доступен из любого места.
*   **`private`**: Доступен только внутри самого класса.
*   **`protected`**: Доступен внутри класса и его подклассов (наследников).

```typescript
class BankAccount {
    public readonly accountNumber: string; // readonly - можно читать, но нельзя менять
    private _balance: number; // private - скрыт от внешнего доступа
    protected owner: string; // protected - доступен в наследниках

    constructor(accountNumber: string, owner: string) {
        this.accountNumber = accountNumber;
        this._balance = 0;
        this.owner = owner;
    }

    // Public метод для доступа к private свойству
    public deposit(amount: number): void {
        if (amount > 0) {
            this._balance += amount;
            console.log(`Внесено: ${amount}. Новый баланс: ${this._balance}`);
        }
    }

    public getBalance(): number {
        return this._balance;
    }
}

const account = new BankAccount("12345", "Alice");
account.deposit(1000); // OK
// account._balance = 1000000; // Ошибка! Свойство _balance является private
// account.accountNumber = "67890"; // Ошибка! accountNumber - readonly
console.log(account.getBalance()); // 1000
```

---

#### **4. Наследование**

Наследование позволяет создавать новый класс на основе существующего, перенимая его свойства и методы.

```typescript
// Базовый (родительский) класс
class Animal {
    constructor(public name: string, protected age: number) {}

    public makeSound(): void {
        console.log("Некоторый звук животного");
    }

    public move(): void {
        console.log(`${this.name} двигается`);
    }
}

// Производный (дочерний) класс
class Dog extends Animal {
    private breed: string;

    constructor(name: string, age: number, breed: string) {
        super(name, age); // Вызов конструктора родительского класса
        this.breed = breed;
    }

    // Переопределение метода
    public makeSound(): void {
        console.log("Гав! Гав!");
    }

    // Новый метод, специфичный для Dog
    public fetch(): void {
        console.log(`${this.name} приносит палку`);
    }

    public getInfo(): string {
        // age доступен, т.к. protected
        return `Собака ${this.name}, порода ${this.breed}, возраст ${this.age}`;
    }
}

const myDog = new Dog("Бобик", 3, "Лабрадор");
myDog.makeSound(); // "Гав! Гав!" (переопределенный метод)
myDog.move(); // "Бобик двигается" (унаследованный метод)
myDog.fetch(); // "Бобик приносит палку" (собственный метод)
// myDog.breed; // Ошибка! breed - private
```

---

#### **5. Абстрактные классы и методы**

**Абстрактные классы** не могут быть инстанциированы напрямую. Они служат только как базовые классы для других классов.

**Абстрактные методы** объявляются без реализации и должны быть реализованы в производных классах.

```typescript
abstract class Shape {
    constructor(public color: string) {}

    // Абстрактный метод - без реализации
    abstract calculateArea(): number;

    // Обычный метод
    public displayColor(): void {
        console.log(`Цвет фигуры: ${this.color}`);
    }
}

class Circle extends Shape {
    constructor(color: string, public radius: number) {
        super(color);
    }

    // Реализация абстрактного метода ОБЯЗАТЕЛЬНА
    calculateArea(): number {
        return Math.PI * this.radius * this.radius;
    }
}

class Rectangle extends Shape {
    constructor(color: string, public width: number, public height: number) {
        super(color);
    }

    calculateArea(): number {
        return this.width * this.height;
    }
}

// const shape = new Shape("red"); // Ошибка! Нельзя создать экземпляр абстрактного класса

const circle = new Circle("red", 5);
const rectangle = new Rectangle("blue", 4, 6);

console.log(circle.calculateArea()); // 78.53981633974483
console.log(rectangle.calculateArea()); // 24

// Полиморфизм в действии
const shapes: Shape[] = [circle, rectangle];
shapes.forEach(shape => {
    console.log(`Площадь: ${shape.calculateArea()}`);
});
```

---

#### **6. Интерфейсы в ООП**

**Интерфейсы** определяют контракт, который должны выполнять классы. Они содержат только объявления методов и свойств без реализации.

```typescript
// Интерфейс для транспортных средств
interface Vehicle {
    start(): void;
    stop(): void;
    readonly maxSpeed: number;
}

// Интерфейс для систем навигации
interface Navigable {
    setDestination(destination: string): void;
    getCurrentLocation(): string;
}

// Класс может реализовывать несколько интерфейсов
class SmartCar implements Vehicle, Navigable {
    readonly maxSpeed: number = 200;
    private destination: string = "";
    private location: string = "Гараж";

    constructor(public brand: string) {}

    start(): void {
        console.log(`${this.brand} запущен`);
    }

    stop(): void {
        console.log(`${this.brand} остановлен`);
    }

    setDestination(destination: string): void {
        this.destination = destination;
        console.log(`Назначен пункт назначения: ${destination}`);
    }

    getCurrentLocation(): string {
        return this.location;
    }
}

const mySmartCar = new SmartCar("Tesla");
mySmartCar.start();
mySmartCar.setDestination("Москва");
```

**Интерфейсы vs Абстрактные классы:**
*   **Интерфейсы:** Только контракт, нет реализации, множественное наследование.
*   **Абстрактные классы:** Могут содержать реализацию, только одиночное наследование.

---

#### **7. Полиморфизм**

**Полиморфизм** позволяет объектам разных классов использовать методы с одинаковыми именами, но разной реализацией.

```typescript
class Cat extends Animal {
    constructor(name: string, age: number) {
        super(name, age);
    }

    makeSound(): void {
        console.log("Мяу!");
    }
}

// Полиморфная коллекция
const animals: Animal[] = [
    new Dog("Шарик", 2, "Дворняжка"),
    new Cat("Мурка", 1),
    new Dog("Рекс", 4, "Овчарка")
];

// Один интерфейс - разное поведение
animals.forEach(animal => {
    animal.makeSound(); // Каждое животное издает свой звук
});
```

---

#### **8. Статические свойства и методы**

**Статические члены класса** принадлежат самому классу, а не его экземплярам.

```typescript
class MathHelper {
    // Статическое свойство
    static readonly PI: number = 3.14159;

    // Статический метод
    static calculateCircleArea(radius: number): number {
        return this.PI * radius * radius;
    }

    static instanceCount: number = 0;

    constructor() {
        MathHelper.instanceCount++;
    }
}

// Обращение к статическим членам через имя класса
console.log(MathHelper.PI); // 3.14159
console.log(MathHelper.calculateCircleArea(5)); // 78.53975

// Не требуется создавать экземпляр класса
const helper1 = new MathHelper();
const helper2 = new MathHelper();
console.log(MathHelper.instanceCount); // 2
```

---

#### **9. Геттеры и сеттеры**

Позволяют контролировать доступ к свойствам объекта и добавлять логику при получении или установке значений.

```typescript
class Temperature {
    private _celsius: number = 0;

    constructor(celsius: number) {
        this.celsius = celsius; // Используем сеттер для валидации
    }

    // Геттер
    get celsius(): number {
        return this._celsius;
    }

    // Сеттер
    set celsius(value: number) {
        if (value < -273.15) {
            throw new Error("Температура ниже абсолютного нуля!");
        }
        this._celsius = value;
    }

    // Еще один геттер для вычисляемого значения
    get fahrenheit(): number {
        return (this._celsius * 9) / 5 + 32;
    }
}

const temp = new Temperature(25);
console.log(temp.celsius); // 25 (используется геттер)
console.log(temp.fahrenheit); // 77 (используется геттер)

temp.celsius = 30; // Используется сеттер
// temp.celsius = -300; // Ошибка! Сработает валидация в сеттере
```

---

### **Резюме**

*   **Классы** — это шаблоны для создания объектов с свойствами и методами.
*   **Модификаторы доступа** (`public`, `private`, `protected`) контролируют видимость членов класса.
*   **Наследование** позволяет создавать иерархии классов и переиспользовать код.
*   **Абстрактные классы** определяют общий интерфейс для группы родственных классов.
*   **Интерфейсы** описывают контракты, которые должны выполнять классы.
*   **Полиморфизм** позволяет работать с объектами разных типов через общий интерфейс.
*   **Статические члены** принадлежат классу, а не его экземплярам.
* **Геттеры и сеттеры** предоставляют контролируемый доступ к свойствам.

**Лучшие практики:**
*   Используйте `private` для инкапсуляции внутреннего состояния.
*   Предпочитайте композицию наследованию, где это уместно.
*   Используйте интерфейсы для определения контрактов между компонентами.
*   Абстрактные классы хороши для тесно связанных сущностей, интерфейсы — для слабосвязанных.

---

### **Контрольные вопросы**

1.  В чем разница между классом и объектом? Приведите пример.
2.  Объясните разницу между модификаторами `public`, `private` и `protected`.
3.  Что такое наследование и как оно реализуется в TypeScript?
4.  В чем разница между абстрактным классом и интерфейсом? Когда что использовать?
5.  Что такое полиморфизм и как он проявляется в ООП?
6.  Создайте класс `Person` со свойствами `name` и `age`, затем создайте класс `Student`, который наследует от `Person` и добавляет свойство `studentId`.
7.  Что такое статические методы и свойства? Когда их следует использовать?
8.  Для чего нужны геттеры и сеттеры? Приведите пример с валидацией данных.
9.  Может ли класс реализовывать несколько интерфейсов? Может ли класс наследоваться от нескольких классов?
10. Создайте абстрактный класс `Employee` с абстрактным методом `calculateSalary()`, затем реализуйте его в классах `FullTimeEmployee` и `PartTimeEmployee`.