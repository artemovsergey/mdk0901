# Лекция 12. Система типов и функции в TypeScript

## Тема
Система типов и функции в TypeScript: от основ к продвинутым концепциям

## План
1. Введение в систему типов TypeScript
2. Базовые типы и их аннотации
3. Специальные типы и продвинутые концепции
4. Функции: основные концепции и типизация
5. Перегрузка функций
6. Практические примеры и лучшие практики

## Резюме
TypeScript предоставляет мощную статическую систему типов, которая помогает выявлять ошибки на этапе разработки. Лекция охватывает основные типы, продвинужные концепции (дженерики, объединения, пересечения) и глубоко погружается в типизацию функций, включая перегрузку и лучшие практики.

---

## 1. Введение в систему типов TypeScript

### Что такое TypeScript?
TypeScript — это строго типизированный надмножество JavaScript, которое компилируется в обычный JavaScript.

### Преимущества системы типов:
- **Раннее обнаружение ошибок** — ошибки типов выявляются на этапе компиляции
- **Улучшенная читаемость кода** — типы служат документацией
- **Лучшая поддержка IDE** — автодополнение, рефакторинг
- **Предсказуемость кода** — четкие контракты между компонентами

### Пример базового типа:
```typescript
let userName: string = "John";
let userAge: number = 25;
let isActive: boolean = true;
```

---

## 2. Базовые типы и их аннотации

### Примитивные типы:
```typescript
// Строки
let firstName: string = "Alice";
let lastName: string = 'Smith';
let template: string = `Hello, ${firstName}!`;

// Числа
let decimal: number = 6;
let hex: number = 0xf00d;
let binary: number = 0b1010;

// Булевы значения
let isDone: boolean = false;
let isCompleted: boolean = true;

// Массивы
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];

// Кортежи (Tuples)
let person: [string, number] = ["John", 30];
// person[0] = "Jane"; // OK
// person[1] = "25"; // Ошибка: тип string не может быть присвоен типу number

// Enum
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE"
}
let favoriteColor: Color = Color.Blue;
```

### Тип any и unknown:
```typescript
// any - отключает проверку типов
let flexible: any = 4;
flexible = "maybe a string";
flexible = false;

// unknown - более безопасная альтернатива any
let notSure: unknown = 4;
notSure = "maybe a string";
// let str: string = notSure; // Ошибка: unknown нельзя присвоить string

// Правильное использование unknown
if (typeof notSure === "string") {
  let str: string = notSure; // Теперь OK
}
```

### Тип void и never:
```typescript
// void - для функций, которые не возвращают значение
function logMessage(message: string): void {
  console.log(message);
}

// never - для функций, которые никогда не завершаются
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {
    // бесконечный цикл
  }
}
```

---

## 3. Специальные типы и продвинутые концепции

### Объединения (Union Types):
```typescript
let id: string | number;
id = "ABC123"; // OK
id = 123; // OK
// id = true; // Ошибка

function processId(identifier: string | number) {
  if (typeof identifier === "string") {
    return identifier.toUpperCase();
  } else {
    return identifier.toString();
  }
}
```

### Пересечения (Intersection Types):
```typescript
interface BusinessPartner {
  name: string;
  credit: number;
}

interface Identity {
  id: string;
  email: string;
}

type Employee = BusinessPartner & Identity;

const employee: Employee = {
  name: "John Doe",
  credit: 1000,
  id: "E123",
  email: "john@company.com"
};
```

### Псевдонимы типов (Type Aliases):
```typescript
type StringOrNumber = string | number;
type User = {
  id: StringOrNumber;
  name: string;
  email: string;
};

const user: User = {
  id: "U123",
  name: "Alice",
  email: "alice@example.com"
};
```

### Дженерики (Generics):
```typescript
// Базовая функция с дженериком
function identity<T>(arg: T): T {
  return arg;
}

let output1 = identity<string>("myString");
let output2 = identity<number>(42);
let output3 = identity("type inference"); // TypeScript выведет тип

// Дженерики с ограничениями
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}

// loggingIdentity(3); // Ошибка: number не имеет свойства length
loggingIdentity("string"); // OK
loggingIdentity([1, 2, 3]); // OK

// Дженерики в интерфейсах
interface GenericArray<T> {
  [index: number]: T;
}

let numberArray: GenericArray<number> = [1, 2, 3];
let stringArray: GenericArray<string> = ["a", "b", "c"];
```

---

## 4. Функции: основные концепции и типизация

### Типизация параметров и возвращаемого значения:
```typescript
// Полная аннотация типов
function add(x: number, y: number): number {
  return x + y;
}

// Функциональные выражения
const multiply = function(x: number, y: number): number {
  return x * y;
};

// Стрелочные функции
const divide = (x: number, y: number): number => {
  return x / y;
};
```

### Необязательные и параметры по умолчанию:
```typescript
function buildName(firstName: string, lastName?: string): string {
  if (lastName) {
    return `${firstName} ${lastName}`;
  }
  return firstName;
}

// Параметры по умолчанию
function createGreeting(name: string, greeting: string = "Hello"): string {
  return `${greeting}, ${name}!`;
}

console.log(createGreeting("John")); // "Hello, John!"
console.log(createGreeting("Jane", "Hi")); // "Hi, Jane!"
```

### Rest параметры:
```typescript
function buildAddress(street: string, ...rest: string[]): string {
  return `${street} ${rest.join(" ")}`;
}

const address = buildAddress("123", "Main", "St", "Apt", "4B");
console.log(address); // "123 Main St Apt 4B"
```

### Функции как типы:
```typescript
type MathOperation = (a: number, b: number) => number;

const add: MathOperation = (a, b) => a + b;
const subtract: MathOperation = (a, b) => a - b;

function calculate(operation: MathOperation, x: number, y: number): number {
  return operation(x, y);
}

console.log(calculate(add, 5, 3)); // 8
console.log(calculate(subtract, 10, 4)); // 6
```

### Контекст this:
```typescript
interface User {
  name: string;
  age: number;
  greet(this: User): void;
}

const user: User = {
  name: "John",
  age: 30,
  greet: function(this: User) {
    console.log(`Hello, my name is ${this.name}`);
  }
};

user.greet(); // "Hello, my name is John"
```

---

## 5. Перегрузка функций

### Базовый пример перегрузки:
```typescript
// Объявления перегрузок
function processInput(input: string): string[];
function processInput(input: number): number[];
function processInput(input: boolean): boolean[];

// Реализация функции
function processInput(input: any): any[] {
  if (typeof input === "string") {
    return input.split("");
  } else if (typeof input === "number") {
    return [input, input * 2, input * 3];
  } else {
    return [input, !input];
  }
}

const stringResult = processInput("hello"); // string[]
const numberResult = processInput(5); // number[]
const booleanResult = processInput(true); // boolean[]
```

### Практический пример с датами:
```typescript
// Перегрузки
function formatDate(timestamp: number): string;
function formatDate(date: Date): string;
function formatDate(dateString: string): string;

// Реализация
function formatDate(input: number | Date | string): string {
  if (typeof input === "number") {
    return new Date(input * 1000).toISOString();
  } else if (input instanceof Date) {
    return input.toISOString();
  } else {
    return new Date(input).toISOString();
  }
}

console.log(formatDate(1609459200)); // timestamp
console.log(formatDate(new Date())); // Date object
console.log(formatDate("2023-01-01")); // date string
```

### Перегрузка с разным количеством параметров:
```typescript
// Перегрузки
function createElement(tag: string): HTMLElement;
function createElement(tag: string, className: string): HTMLElement;
function createElement(tag: string, className: string, id: string): HTMLElement;

// Реализация
function createElement(tag: string, className?: string, id?: string): HTMLElement {
  const element = document.createElement(tag);
  
  if (className) {
    element.className = className;
  }
  
  if (id) {
    element.id = id;
  }
  
  return element;
}

const div1 = createElement("div");
const div2 = createElement("div", "container");
const div3 = createElement("div", "container", "main");
```

---

## 6. Практические примеры и лучшие практики

### Типизация обработчиков событий:
```typescript
type ClickHandler = (event: MouseEvent) => void;
type FormSubmitHandler = (event: SubmitEvent) => void;

const handleClick: ClickHandler = (event) => {
  console.log(`Clicked at: ${event.clientX}, ${event.clientY}`);
};

const handleSubmit: FormSubmitHandler = (event) => {
  event.preventDefault();
  console.log("Form submitted!");
};
```

### Функции высшего порядка:
```typescript
type Transformer<T, U> = (value: T) => U;

function mapArray<T, U>(array: T[], transform: Transformer<T, U>): U[] {
  return array.map(transform);
}

const numbers = [1, 2, 3, 4, 5];
const doubled = mapArray(numbers, (x) => x * 2); // number[]
const strings = mapArray(numbers, (x) => x.toString()); // string[]
```

### Асинхронные функции:
```typescript
async function fetchUserData(userId: number): Promise<{ name: string; email: string }> {
  const response = await fetch(`/api/users/${userId}`);
  if (!response.ok) {
    throw new Error("Failed to fetch user data");
  }
  return response.json();
}

// Использование с обработкой ошибок
async function displayUser(userId: number): Promise<void> {
  try {
    const user = await fetchUserData(userId);
    console.log(`User: ${user.name}, Email: ${user.email}`);
  } catch (error) {
    console.error("Error fetching user:", error);
  }
}
```

### Лучшие практики:

1. **Используйте strict mode**:
```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "noImplicitReturns": true
  }
}
```

2. **Предпочитайте interface для объектов**:
```typescript
interface User {
  id: number;
  name: string;
  email: string;
}

type UserRole = "admin" | "user" | "guest";
```

3. **Используйте type guards**:
```typescript
function isString(value: any): value is string {
  return typeof value === "string";
}

function processValue(value: string | number) {
  if (isString(value)) {
    // TypeScript знает, что value - string
    return value.toUpperCase();
  } else {
    // TypeScript знает, что value - number
    return value.toFixed(2);
  }
}
```

4. **Избегайте any, используйте unknown**:
```typescript
// Плохо
function parseData(data: any) {
  return JSON.parse(data);
}

// Хорошо
function parseDataSafe(data: unknown) {
  if (typeof data === "string") {
    return JSON.parse(data);
  }
  throw new Error("Data must be a string");
}
```

---

## Контрольные вопросы

1. **Какие преимущества предоставляет статическая типизация в TypeScript по сравнению с JavaScript?**
   - Раннее обнаружение ошибок, улучшенная читаемость, лучшая поддержка IDE, предсказуемость кода

2. **В чем разница между типами `any` и `unknown`?**
   - `any` отключает проверку типов, `unknown` требует проверки типа перед использованием

3. **Как работают объединения (union types) и когда их следует использовать?**
   - Позволяют переменной иметь несколько типов, полезны когда значение может быть разных типов

4. **Что такое дженерики и как они помогают создавать переиспользуемый код?**
   - Позволяют создавать компоненты, работающие с разными типами, сохраняя типобезопасность

5. **Как работает перегрузка функций и в каких сценариях она полезна?**
   - Позволяет функции иметь разные сигнатуры для разных типов параметров, полезна когда функция ведет себя по-разному в зависимости от типов входных данных

6. **Какие есть способы типизации стрелочных функций?**
   - Явная аннотация параметров и возвращаемого типа, использование type aliases для функциональных типов

7. **Как правильно типизировать асинхронные функции?**
   - Использовать `Promise<T>` как возвращаемый тип, где T - тип разрешенного значения

8. **В чем разница между `interface` и `type` и когда что использовать?**
   - `interface` лучше для объектов и расширения через объявление, `type` для объединений, пересечений и сложных типов

9. **Как работают type guards и зачем они нужны?**
   - Позволяют сужать типы в условных блоках, обеспечивая типобезопасность при работе с union types

10. **Какие лучшие практики типизации функций вы узнали?**
    - Использование strict mode, избегание any, правильное использование перегрузок, типизация колбэков