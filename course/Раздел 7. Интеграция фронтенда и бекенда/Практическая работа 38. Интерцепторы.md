# Практическая работа. Интерцепторы в Angular

### **Тема:** Создание и применение HTTP интерцепторов для обработки запросов и ответов

### **Цель:** 
Научиться создавать HTTP интерцепторы в Angular для централизованной обработки запросов и ответов. Освоить паттерны для аутентификации, кэширования, логирования, обработки ошибок и модификации запросов.

### **Теоретическая часть:**

**HTTP интерцепторы** - это middleware, которые перехватывают HTTP запросы и ответы для их обработки перед отправкой на сервер или перед передачей в приложение.

**Основные сценарии использования:**
- Добавление заголовков авторизации
- Глобальная обработка ошибок
- Кэширование запросов
- Логирование
- Модификация запросов/ответов
- Показатель загрузки

**Создание интерцептора:**
```typescript
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Логика обработки запроса
    const modifiedReq = req.clone({
      headers: req.headers.set('Authorization', 'Bearer token')
    });
    
    return next.handle(modifiedReq);
  }
}
```

**Регистрация интерцепторов:**
```typescript
@NgModule({
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true }
  ]
})
```

### **Ход работы:**

1. Создать Angular проект для демонстрации интерцепторов
2. Реализовать различные типы интерцепторов
3. Создать сервисы для работы с API
4. Реализовать обработку ошибок и состояний
5. Создать демонстрационные компоненты
6. Протестировать все сценарии работы интерцепторов
7. Оформить README.md с описанием работы

### **Практический пример:**

**1. Базовый интерцептор для логирования:**
```typescript
// logging.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse, HttpErrorResponse } from '@angular/common/http';
import { Observable, tap } from 'rxjs';
import { LoggerService } from '../services/logger.service';

@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  constructor(private logger: LoggerService) {}

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const startTime = Date.now();
    const requestId = this.generateRequestId();

    // Логирование запроса
    this.logger.info(`[${requestId}] HTTP ${req.method} ${req.url}`, {
      headers: this.getSafeHeaders(req.headers),
      body: this.getSafeBody(req.body),
      timestamp: new Date().toISOString()
    });

    return next.handle(req).pipe(
      tap({
        next: (event) => {
          if (event instanceof HttpResponse) {
            const duration = Date.now() - startTime;
            
            // Логирование успешного ответа
            this.logger.info(`[${requestId}] HTTP ${req.method} ${req.url} - ${event.status} (${duration}ms)`, {
              status: event.status,
              duration: `${duration}ms`,
              body: this.getSafeBody(event.body)
            });
          }
        },
        error: (error: HttpErrorResponse) => {
          const duration = Date.now() - startTime;
          
          // Логирование ошибки
          this.logger.error(`[${requestId}] HTTP ${req.method} ${req.url} - ${error.status} (${duration}ms)`, {
            status: error.status,
            duration: `${duration}ms`,
            error: error.message,
            url: error.url
          });
        }
      })
    );
  }

  private generateRequestId(): string {
    return Math.random().toString(36).substring(2, 9);
  }

  private getSafeHeaders(headers: any): any {
    const safeHeaders = { ...headers };
    // Удаляем чувствительные данные
    if (safeHeaders['authorization']) {
      safeHeaders['authorization'] = '***';
    }
    return safeHeaders;
  }

  private getSafeBody(body: any): any {
    if (!body) return body;
    
    // Создаем безопасную копию без чувствительных данных
    const safeBody = { ...body };
    
    if (safeBody.password) {
      safeBody.password = '***';
    }
    if (safeBody.token) {
      safeBody.token = '***';
    }
    if (safeBody.creditCard) {
      safeBody.creditCard = '***';
    }
    
    return safeBody;
  }
}
```

**2. Интерцептор для аутентификации:**
```typescript
// auth.interceptor.ts
import { Injectable, inject } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, BehaviorSubject, switchMap, take, filter, catchError } from 'rxjs';
import { AuthService } from '../services/auth.service';
import { Router } from '@angular/router';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);
  private router = inject(Router);
  
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<string | null> = new BehaviorSubject<string | null>(null);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Не добавляем токен для публичных запросов
    if (this.isPublicRequest(req)) {
      return next.handle(req);
    }

    const authReq = this.addAuthHeader(req);

    return next.handle(authReq).pipe(
      catchError((error: HttpErrorResponse) => {
        // Обработка ошибки 401 Unauthorized
        if (error.status === 401 && this.authService.isLoggedIn()) {
          return this.handle401Error(authReq, next);
        }
        
        // Обработка ошибки 403 Forbidden
        if (error.status === 403) {
          this.handle403Error();
          return throwError(() => error);
        }
        
        return throwError(() => error);
      })
    );
  }

  private isPublicRequest(req: HttpRequest<any>): boolean {
    const publicEndpoints = [
      '/api/auth/login',
      '/api/auth/register',
      '/api/auth/refresh',
      '/api/public/'
    ];

    return publicEndpoints.some(endpoint => req.url.includes(endpoint));
  }

  private addAuthHeader(req: HttpRequest<any>): HttpRequest<any> {
    const token = this.authService.getAccessToken();
    
    if (token) {
      return req.clone({
        headers: req.headers.set('Authorization', `Bearer ${token}`)
      });
    }
    
    return req;
  }

  private handle401Error(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);

      return this.authService.refreshToken().pipe(
        switchMap((newToken: string) => {
          this.isRefreshing = false;
          this.refreshTokenSubject.next(newToken);
          
          // Повторяем оригинальный запрос с новым токеном
          const authReq = this.addAuthHeader(req);
          return next.handle(authReq);
        }),
        catchError((error) => {
          this.isRefreshing = false;
          this.authService.logout();
          this.router.navigate(['/login']);
          return throwError(() => error);
        })
      );
    } else {
      // Ждем пока токен обновится
      return this.refreshTokenSubject.pipe(
        filter(token => token !== null),
        take(1),
        switchMap(token => {
          const authReq = this.addAuthHeader(req);
          return next.handle(authReq);
        })
      );
    }
  }

  private handle403Error(): void {
    this.authService.logout();
    this.router.navigate(['/login'], {
      queryParams: { message: 'access_denied' }
    });
  }
}
```

**3. Интерцептор для кэширования:**
```typescript
// cache.interceptor.ts
import { Injectable, inject } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse } from '@angular/common/http';
import { Observable, of, tap } from 'rxjs';
import { CacheService } from '../services/cache.service';

interface CacheEntry {
  response: HttpResponse<any>;
  expiry: number;
}

@Injectable()
export class CacheInterceptor implements HttpInterceptor {
  private cacheService = inject(CacheService);
  private defaultCacheTime = 5 * 60 * 1000; // 5 минут

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Кэшируем только GET запросы
    if (req.method !== 'GET') {
      return next.handle(req);
    }

    // Проверяем нужно ли кэшировать этот запрос
    if (!this.shouldCache(req)) {
      return next.handle(req);
    }

    const cacheKey = this.generateCacheKey(req);
    const cached = this.cacheService.get<CacheEntry>(cacheKey);

    // Возвращаем закэшированный ответ если он есть и не истек
    if (cached && cached.expiry > Date.now()) {
      return of(cached.response.clone());
    }

    // Выполняем запрос и кэшируем ответ
    return next.handle(req).pipe(
      tap(event => {
        if (event instanceof HttpResponse) {
          const cacheTime = this.getCacheTime(req);
          const cacheEntry: CacheEntry = {
            response: event.clone(),
            expiry: Date.now() + cacheTime
          };
          
          this.cacheService.set(cacheKey, cacheEntry, cacheTime);
        }
      })
    );
  }

  private shouldCache(req: HttpRequest<any>): boolean {
    // Не кэшируем запросы с определенными заголовками
    if (req.headers.get('no-cache') === 'true') {
      return false;
    }

    // Кэшируем только определенные endpoints
    const cacheableEndpoints = [
      '/api/products',
      '/api/categories',
      '/api/config',
      '/api/static'
    ];

    return cacheableEndpoints.some(endpoint => req.url.includes(endpoint));
  }

  private generateCacheKey(req: HttpRequest<any>): string {
    // Создаем уникальный ключ на основе URL и параметров
    const params = req.params.toString();
    const key = params ? `${req.url}?${params}` : req.url;
    return btoa(key); // Кодируем в base64 для безопасности
  }

  private getCacheTime(req: HttpRequest<any>): number {
    // Можно задать разное время кэширования для разных endpoints
    const cacheHeader = req.headers.get('cache-time');
    
    if (cacheHeader) {
      return parseInt(cacheHeader, 10);
    }

    if (req.url.includes('/api/config')) {
      return 30 * 60 * 1000; // 30 минут для конфигурации
    }

    if (req.url.includes('/api/static')) {
      return 24 * 60 * 60 * 1000; // 24 часа для статики
    }

    return this.defaultCacheTime;
  }
}
```

**4. Интерцептор для обработки ошибок:**
```typescript
// error.interceptor.ts
import { Injectable, inject } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { NotificationService } from '../services/notification.service';

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  private notificationService = inject(NotificationService);

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(req).pipe(
      catchError((error: HttpErrorResponse) => {
        const errorMessage = this.getErrorMessage(error);
        
        // Показываем уведомление пользователю
        this.showErrorMessage(error, errorMessage);
        
        // Логируем ошибку
        console.error('HTTP Error:', {
          url: error.url,
          status: error.status,
          message: error.message,
          timestamp: new Date().toISOString()
        });

        return throwError(() => new Error(errorMessage));
      })
    );
  }

  private getErrorMessage(error: HttpErrorResponse): string {
    if (error.error instanceof ErrorEvent) {
      // Клиентская ошибка
      return `Ошибка: ${error.error.message}`;
    }

    // Серверная ошибка
    switch (error.status) {
      case 0:
        return 'Нет соединения с сервером. Проверьте подключение к интернету.';
      
      case 400:
        return this.getBadRequestMessage(error);
      
      case 401:
        return 'Не авторизован. Пожалуйста, войдите в систему.';
      
      case 403:
        return 'Доступ запрещен. Недостаточно прав.';
      
      case 404:
        return 'Запрашиваемый ресурс не найден.';
      
      case 409:
        return 'Конфликт данных. Возможно, запись уже существует.';
      
      case 422:
        return this.getValidationErrorMessage(error);
      
      case 429:
        return 'Слишком много запросов. Попробуйте позже.';
      
      case 500:
        return 'Внутренняя ошибка сервера. Попробуйте позже.';
      
      case 502:
        return 'Проблемы с сервером. Попробуйте позже.';
      
      case 503:
        return 'Сервис временно недоступен. Попробуйте позже.';
      
      default:
        return `Произошла ошибка: ${error.status} ${error.statusText}`;
    }
  }

  private getBadRequestMessage(error: HttpErrorResponse): string {
    if (error.error && error.error.message) {
      return error.error.message;
    }
    
    if (error.error && error.error.errors) {
      const errors = error.error.errors;
      return `Ошибка валидации: ${Object.values(errors).join(', ')}`;
    }
    
    return 'Неверный запрос. Проверьте введенные данные.';
  }

  private getValidationErrorMessage(error: HttpErrorResponse): string {
    if (error.error && error.error.errors) {
      const errors = error.error.errors;
      const errorMessages = Object.entries(errors)
        .map(([field, messages]) => `${field}: ${(messages as string[]).join(', ')}`)
        .join('; ');
      
      return `Ошибки валидации: ${errorMessages}`;
    }
    
    return 'Ошибка валидации данных.';
  }

  private showErrorMessage(error: HttpErrorResponse, message: string): void {
    // Не показываем уведомления для определенных статусов
    const silentErrors = [401, 403]; // Эти ошибки обрабатываются в AuthInterceptor
    
    if (silentErrors.includes(error.status)) {
      return;
    }

    this.notificationService.showError(message, 'Ошибка');
  }
}
```

**5. Интерцептор для показателя загрузки:**
```typescript
// loading.interceptor.ts
import { Injectable, inject } from '@angular/core';
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';
import { finalize } from 'rxjs/operators';
import { LoadingService } from '../services/loading.service';

@Injectable()
export class LoadingInterceptor implements HttpInterceptor {
  private loadingService = inject(LoadingService);
  private activeRequests = 0;

  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Игнорируем запросы для которых не нужно показывать индикатор
    if (this.shouldIgnoreLoading(req)) {
      return next.handle(req);
    }

    this.activeRequests++;
    
    // Показываем индикатор загрузки с небольшой задержкой
    setTimeout(() => {
      if (this.activeRequests > 0) {
        this.loadingService.show();
      }
    }, 100);

    return next.handle(req).pipe(
      finalize(() => {
        this.activeRequests--;
        
        if (this.activeRequests === 0) {
          this.loadingService.hide();
        }
      })
    );
  }

  private shouldIgnoreLoading(req: HttpRequest<any>): boolean {
    const ignoreEndpoints = [
      '/api/notifications',
      '/api/analytics',
      '/api/heartbeat'
    ];

    return ignoreEndpoints.some(endpoint => req.url.includes(endpoint)) ||
           req.headers.has('ignore-loading');
  }
}
```

**6. Сервис для логирования:**
```typescript
// logger.service.ts
import { Injectable } from '@angular/core';

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3
}

@Injectable({
  providedIn: 'root'
})
export class LoggerService {
  private logLevel: LogLevel = LogLevel.DEBUG;

  debug(message: string, data?: any): void {
    if (this.logLevel <= LogLevel.DEBUG) {
      console.debug(`[DEBUG] ${message}`, data || '');
    }
  }

  info(message: string, data?: any): void {
    if (this.logLevel <= LogLevel.INFO) {
      console.info(`[INFO] ${message}`, data || '');
    }
  }

  warn(message: string, data?: any): void {
    if (this.logLevel <= LogLevel.WARN) {
      console.warn(`[WARN] ${message}`, data || '');
    }
  }

  error(message: string, data?: any): void {
    if (this.logLevel <= LogLevel.ERROR) {
      console.error(`[ERROR] ${message}`, data || '');
    }
  }

  setLogLevel(level: LogLevel): void {
    this.logLevel = level;
  }
}
```

**7. Сервис для кэширования:**
```typescript
// cache.service.ts
import { Injectable } from '@angular/core';

interface CacheItem<T> {
  data: T;
  timestamp: number;
  expiresIn: number;
}

@Injectable({
  providedIn: 'root'
})
export class CacheService {
  private cache = new Map<string, CacheItem<any>>();

  set<T>(key: string, data: T, expiresIn: number = 5 * 60 * 1000): void {
    const cacheItem: CacheItem<T> = {
      data,
      timestamp: Date.now(),
      expiresIn
    };
    
    this.cache.set(key, cacheItem);
  }

  get<T>(key: string): T | null {
    const cacheItem = this.cache.get(key) as CacheItem<T>;
    
    if (!cacheItem) {
      return null;
    }

    if (this.isExpired(cacheItem)) {
      this.remove(key);
      return null;
    }

    return cacheItem.data;
  }

  remove(key: string): boolean {
    return this.cache.delete(key);
  }

  clear(): void {
    this.cache.clear();
  }

  clearExpired(): void {
    const now = Date.now();
    
    this.cache.forEach((value, key) => {
      if (this.isExpired(value)) {
        this.remove(key);
      }
    });
  }

  private isExpired(cacheItem: CacheItem<any>): boolean {
    return Date.now() - cacheItem.timestamp > cacheItem.expiresIn;
  }

  getStats(): { total: number; expired: number } {
    let expired = 0;
    const now = Date.now();

    this.cache.forEach(item => {
      if (this.isExpired(item)) {
        expired++;
      }
    });

    return {
      total: this.cache.size,
      expired
    };
  }
}
```

**8. Демонстрационный компонент:**
```typescript
// interceptors-demo.component.ts
import { Component, inject, OnInit, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { HttpClient, HttpParams, HttpHeaders } from '@angular/common/http';
import { FormsModule } from '@angular/forms';

interface ApiResponse {
  message: string;
  timestamp: string;
  data?: any;
}

@Component({
  selector: 'app-interceptors-demo',
  templateUrl: './interceptors-demo.component.html',
  styleUrls: ['./interceptors-demo.component.css'],
  standalone: true,
  imports: [CommonModule, FormsModule]
})
export class InterceptorsDemoComponent implements OnInit {
  private http = inject(HttpClient);

  // Состояние компонента
  responses = signal<ApiResponse[]>([]);
  isLoading = signal(false);
  selectedEndpoint = signal('users');
  customHeaders = signal<{key: string, value: string}[]>([
    { key: 'X-Custom-Header', value: 'custom-value' }
  ]);
  cacheTime = signal(300000); // 5 минут

  endpoints = [
    { value: 'users', label: '👥 Пользователи', method: 'GET' },
    { value: 'products', label: '📦 Товары', method: 'GET' },
    { value: 'auth/login', label: '🔐 Логин (ошибка)', method: 'POST' },
    { value: 'admin', label: '⚡ Админка (403)', method: 'GET' },
    { value: 'slow', label: '🐌 Медленный запрос', method: 'GET' },
    { value: 'config', label: '⚙️ Конфигурация', method: 'GET' }
  ];

  ngOnInit() {
    this.loadInitialData();
  }

  private loadInitialData() {
    // Загружаем начальные данные для демонстрации кэширования
    this.http.get<ApiResponse>('/api/config').subscribe();
    this.http.get<ApiResponse>('/api/products').subscribe();
  }

  makeRequest() {
    this.isLoading.set(true);
    
    const endpoint = this.selectedEndpoint();
    const url = `/api/${endpoint}`;
    const headers = this.buildHeaders();

    let request$;

    switch (endpoint) {
      case 'auth/login':
        request$ = this.http.post<ApiResponse>(url, {
          username: 'testuser',
          password: 'wrongpassword'
        }, { headers });
        break;
      
      case 'admin':
        request$ = this.http.get<ApiResponse>(url, { headers });
        break;
      
      case 'slow':
        request$ = this.http.get<ApiResponse>(url, { 
          headers: headers.set('X-Slow-Request', 'true')
        });
        break;
      
      case 'config':
        request$ = this.http.get<ApiResponse>(url, { 
          headers: headers.set('cache-time', this.cacheTime().toString())
        });
        break;
      
      default:
        request$ = this.http.get<ApiResponse>(url, { headers });
    }

    const startTime = Date.now();

    request$.subscribe({
      next: (response) => {
        const duration = Date.now() - startTime;
        this.responses.update(responses => [{
          ...response,
          message: `${response.message} (${duration}ms)`
        }, ...responses.slice(0, 9)]); // Храним только последние 10 ответов
      },
      error: (error) => {
        const duration = Date.now() - startTime;
        this.responses.update(responses => [{
          message: `❌ Ошибка: ${error.message} (${duration}ms)`,
          timestamp: new Date().toISOString()
        }, ...responses.slice(0, 9)]);
      },
      complete: () => {
        this.isLoading.set(false);
      }
    });
  }

  private buildHeaders(): HttpHeaders {
    let headers = new HttpHeaders();
    
    this.customHeaders().forEach(header => {
      if (header.key && header.value) {
        headers = headers.set(header.key, header.value);
      }
    });

    return headers;
  }

  addCustomHeader() {
    this.customHeaders.update(headers => [
      ...headers,
      { key: '', value: '' }
    ]);
  }

  removeCustomHeader(index: number) {
    this.customHeaders.update(headers => 
      headers.filter((_, i) => i !== index)
    );
  }

  trackByHeader(index: number, header: any): string {
    return `${header.key}-${index}`;
  }

  clearCache() {
    this.http.get('/api/clear-cache').subscribe({
      next: () => {
        this.responses.update(responses => [{
          message: '✅ Кэш очищен',
          timestamp: new Date().toISOString()
        }, ...responses.slice(0, 9)]);
      }
    });
  }

  clearResponses() {
    this.responses.set([]);
  }

  getSelectedEndpointMethod(): string {
    const endpoint = this.endpoints.find(e => e.value === this.selectedEndpoint());
    return endpoint?.method || 'GET';
  }
}
```

```html
<!-- interceptors-demo.component.html -->
<div class="interceptors-demo">
  <header class="demo-header">
    <h1>🛡️ Демонстрация HTTP интерцепторов</h1>
    <p>Тестирование различных сценариев работы интерцепторов</p>
  </header>

  <div class="demo-content">
    <!-- Панель управления -->
    <section class="control-panel">
      <div class="request-config">
        <h2>⚡ Настройка запроса</h2>
        
        <div class="form-group">
          <label for="endpoint">Endpoint:</label>
          <select 
            id="endpoint"
            [value]="selectedEndpoint()"
            (change)="selectedEndpoint.set($any($event.target).value)"
          >
            @for (endpoint of endpoints; track endpoint.value) {
              <option [value]="endpoint.value">
                {{ endpoint.label }} ({{ endpoint.method }})
              </option>
            }
          </select>
        </div>

        <!-- Кастомные заголовки -->
        <div class="headers-section">
          <h3>📋 Кастомные заголовки</h3>
          <div class="headers-list">
            @for (header of customHeaders(); track trackByHeader($index, header); let i = $index) {
              <div class="header-row">
                <input 
                  type="text" 
                  [value]="header.key"
                  (input)="header.key = $any($event.target).value"
                  placeholder="Header name"
                  class="header-input"
                >
                <input 
                  type="text" 
                  [value]="header.value"
                  (input)="header.value = $any($event.target).value"
                  placeholder="Header value"
                  class="header-input"
                >
                <button 
                  (click)="removeCustomHeader(i)"
                  class="btn-danger btn-sm"
                >
                  🗑️
                </button>
              </div>
            }
            <button (click)="addCustomHeader()" class="btn-secondary btn-sm">
              ➕ Добавить заголовок
            </button>
          </div>
        </div>

        <!-- Настройки кэширования -->
        <div class="cache-settings">
          <h3>💾 Настройки кэширования</h3>
          <div class="form-group">
            <label for="cacheTime">Время кэширования (мс):</label>
            <input 
              type="number" 
              id="cacheTime"
              [value]="cacheTime()"
              (input)="cacheTime.set($any($event.target).value)"
              min="0"
            >
          </div>
        </div>

        <!-- Кнопки управления -->
        <div class="action-buttons">
          <button 
            (click)="makeRequest()"
            [disabled]="isLoading()"
            class="btn-primary"
          >
            @if (isLoading()) {
              <span class="spinner"></span>
              Выполняется...
            } @else {
              🚀 Выполнить {{ getSelectedEndpointMethod() }} запрос
            }
          </button>

          <button (click)="clearCache()" class="btn-secondary">
            🗑️ Очистить кэш
          </button>

          <button (click)="clearResponses()" class="btn-secondary">
            📋 Очистить логи
          </button>
        </div>
      </div>
    </section>

    <!-- Результаты запросов -->
    <section class="results-panel">
      <h2>📊 Результаты запросов</h2>
      
      <div class="responses-list">
        @if (responses().length === 0) {
          <div class="empty-state">
            <p>📭 Нет выполненных запросов</p>
            <p>Нажмите "Выполнить запрос" чтобы начать</p>
          </div>
        } @else {
          @for (response of responses(); track response.timestamp) {
            <div class="response-item" [class.error]="response.message.includes('❌')">
              <div class="response-header">
                <span class="response-timestamp">
                  {{ response.timestamp | date:'mediumTime' }}
                </span>
                <span class="response-status">
                  {{ response.message.includes('❌') ? '❌ Ошибка' : '✅ Успех' }}
                </span>
              </div>
              <div class="response-body">
                <pre>{{ response.message }}</pre>
                @if (response.data) {
                  <details class="response-details">
                    <summary>Детали ответа</summary>
                    <pre>{{ response.data | json }}</pre>
                  </details>
                }
              </div>
            </div>
          }
        }
      </div>
    </section>

    <!-- Информация об интерцепторах -->
    <section class="interceptors-info">
      <h2>🔧 Активные интерцепторы</h2>
      
      <div class="interceptors-grid">
        <div class="interceptor-card">
          <h3>📝 Logging Interceptor</h3>
          <p>Логирует все HTTP запросы и ответы в консоль</p>
          <ul>
            <li>Время выполнения запроса</li>
            <li>Статус код ответа</li>
            <li>URL и метод запроса</li>
          </ul>
        </div>

        <div class="interceptor-card">
          <h3>🔐 Auth Interceptor</h3>
          <p>Добавляет JWT токен к запросам</p>
          <ul>
            <li>Автоматическое обновление токена</li>
            <li>Обработка 401/403 ошибок</li>
            <li>Перенаправление на логин</li>
          </ul>
        </div>

        <div class="interceptor-card">
          <h3>💾 Cache Interceptor</h3>
          <p>Кэширует GET запросы</p>
          <ul>
            <li>Настраиваемое время кэширования</li>
            <li>Умное инвалидирование кэша</li>
            <li>Игнорирование определенных запросов</li>
          </ul>
        </div>

        <div class="interceptor-card">
          <h3>🚨 Error Interceptor</h3>
          <p>Централизованная обработка ошибок</p>
          <ul>
            <li>Пользовательские сообщения об ошибках</li>
            <li>Логирование ошибок</li>
            <li>Уведомления пользователя</li>
          </ul>
        </div>

        <div class="interceptor-card">
          <h3>⏳ Loading Interceptor</h3>
          <p>Управление индикатором загрузки</p>
          <ul>
            <li>Глобальный индикатор загрузки</li>
            <li>Игнорирование определенных запросов</li>
            <li>Задержка показа индикатора</li>
          </ul>
        </div>
      </div>
    </section>
  </div>
</div>
```

```css
/* interceptors-demo.component.css */
.interceptors-demo {
  min-height: 100vh;
  background: #f8f9fa;
  color: #333;
}

.demo-header {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  padding: 2rem;
  text-align: center;
}

.demo-header h1 {
  margin: 0 0 0.5rem 0;
  font-size: 2.5rem;
}

.demo-header p {
  margin: 0;
  opacity: 0.9;
  font-size: 1.1rem;
}

.demo-content {
  max-width: 1200px;
  margin: 0 auto;
  padding: 2rem;
  display: grid;
  gap: 2rem;
}

/* Панель управления */
.control-panel {
  background: white;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.request-config h2 {
  margin: 0 0 1.5rem 0;
  color: #2c3e50;
  border-bottom: 2px solid #ecf0f1;
  padding-bottom: 0.5rem;
}

.form-group {
  margin-bottom: 1.5rem;
}

.form-group label {
  display: block;
  font-weight: 600;
  margin-bottom: 0.5rem;
  color: #2c3e50;
}

.form-group select,
.form-group input {
  width: 100%;
  padding: 0.75rem;
  border: 2px solid #e9ecef;
  border-radius: 6px;
  font-size: 1rem;
  transition: border-color 0.3s ease;
}

.form-group select:focus,
.form-group input:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
}

/* Заголовки */
.headers-section {
  margin: 2rem 0;
  padding: 1.5rem;
  background: #f8f9fa;
  border-radius: 8px;
  border-left: 4px solid #667eea;
}

.headers-section h3 {
  margin: 0 0 1rem 0;
  color: #2c3e50;
}

.header-row {
  display: grid;
  grid-template-columns: 1fr 1fr auto;
  gap: 0.5rem;
  margin-bottom: 0.5rem;
  align-items: center;
}

.header-input {
  padding: 0.5rem;
  border: 1px solid #ddd;
  border-radius: 4px;
  font-size: 0.9rem;
}

/* Настройки кэширования */
.cache-settings {
  margin: 1.5rem 0;
  padding: 1rem;
  background: #fff3cd;
  border-radius: 6px;
  border-left: 4px solid #ffc107;
}

.cache-settings h3 {
  margin: 0 0 1rem 0;
  color: #856404;
}

/* Кнопки действий */
.action-buttons {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  margin-top: 2rem;
}

/* Результаты запросов */
.results-panel {
  background: white;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.results-panel h2 {
  margin: 0 0 1.5rem 0;
  color: #2c3e50;
  border-bottom: 2px solid #ecf0f1;
  padding-bottom: 0.5rem;
}

.responses-list {
  max-height: 400px;
  overflow-y: auto;
  border: 1px solid #e9ecef;
  border-radius: 8px;
}

.empty-state {
  padding: 3rem;
  text-align: center;
  color: #6c757d;
}

.empty-state p {
  margin: 0.5rem 0;
}

.response-item {
  padding: 1rem;
  border-bottom: 1px solid #e9ecef;
  transition: background-color 0.3s ease;
}

.response-item:hover {
  background: #f8f9fa;
}

.response-item.error {
  background: #f8d7da;
  border-left: 4px solid #dc3545;
}

.response-item:last-child {
  border-bottom: none;
}

.response-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 0.5rem;
}

.response-timestamp {
  font-size: 0.8rem;
  color: #6c757d;
}

.response-status {
  font-weight: 600;
  font-size: 0.9rem;
}

.response-body pre {
  margin: 0;
  font-family: 'Courier New', monospace;
  font-size: 0.9rem;
  white-space: pre-wrap;
  word-break: break-all;
}

.response-details {
  margin-top: 0.5rem;
}

.response-details summary {
  cursor: pointer;
  font-weight: 600;
  color: #667eea;
}

.response-details pre {
  background: #2d3748;
  color: #e2e8f0;
  padding: 1rem;
  border-radius: 4px;
  margin-top: 0.5rem;
  font-size: 0.8rem;
  max-height: 200px;
  overflow-y: auto;
}

/* Информация об интерцепторах */
.interceptors-info {
  background: white;
  padding: 2rem;
  border-radius: 12px;
  box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.interceptors-info h2 {
  margin: 0 0 1.5rem 0;
  color: #2c3e50;
  border-bottom: 2px solid #ecf0f1;
  padding-bottom: 0.5rem;
}

.interceptors-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: 1.5rem;
}

.interceptor-card {
  background: #f8f9fa;
  padding: 1.5rem;
  border-radius: 8px;
  border-left: 4px solid #667eea;
  transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.interceptor-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0,0,0,0.1);
}

.interceptor-card h3 {
  margin: 0 0 1rem 0;
  color: #2c3e50;
}

.interceptor-card p {
  margin: 0 0 1rem 0;
  color: #6c757d;
  line-height: 1.5;
}

.interceptor-card ul {
  margin: 0;
  padding-left: 1.2rem;
  color: #495057;
}

.interceptor-card li {
  margin-bottom: 0.25rem;
  line-height: 1.4;
}

/* Кнопки */
button {
  padding: 0.75rem 1.5rem;
  border: none;
  border-radius: 6px;
  font-size: 1rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.btn-primary {
  background: #667eea;
  color: white;
}

.btn-primary:hover:not(:disabled) {
  background: #5a6fd8;
  transform: translateY(-1px);
}

.btn-secondary {
  background: #6c757d;
  color: white;
}

.btn-secondary:hover {
  background: #5a6268;
}

.btn-danger {
  background: #dc3545;
  color: white;
}

.btn-danger:hover {
  background: #c82333;
}

.btn-sm {
  padding: 0.5rem 1rem;
  font-size: 0.9rem;
}

button:disabled {
  opacity: 0.6;
  cursor: not-allowed;
  transform: none !important;
}

/* Спиннер */
.spinner {
  width: 16px;
  height: 16px;
  border: 2px solid transparent;
  border-top: 2px solid white;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Адаптивность */
@media (max-width: 768px) {
  .demo-content {
    padding: 1rem;
    grid-template-columns: 1fr;
  }
  
  .control-panel,
  .results-panel,
  .interceptors-info {
    padding: 1.5rem;
  }
  
  .header-row {
    grid-template-columns: 1fr;
    gap: 0.5rem;
  }
  
  .action-buttons {
    flex-direction: column;
  }
  
  .interceptors-grid {
    grid-template-columns: 1fr;
  }
  
  .response-header {
    flex-direction: column;
    align-items: flex-start;
    gap: 0.5rem;
  }
}
```

**9. Модуль приложения с регистрацией интерцепторов:**
```typescript
// app.config.ts
import { ApplicationConfig, importProvidersFrom } from '@angular/core';
import { provideRouter } from '@angular/router';
import { provideHttpClient, withInterceptorsFromDi, HTTP_INTERCEPTORS } from '@angular/common/http';
import { routes } from './app.routes';

import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { AuthInterceptor } from './interceptors/auth.interceptor';
import { CacheInterceptor } from './interceptors/cache.interceptor';
import { ErrorInterceptor } from './interceptors/error.interceptor';
import { LoadingInterceptor } from './interceptors/loading.interceptor';

export const appConfig: ApplicationConfig = {
  providers: [
    provideRouter(routes),
    provideHttpClient(
      withInterceptorsFromDi()
    ),
    // Регистрация интерцепторов
    {
      provide: HTTP_INTERCEPTORS,
      useClass: LoggingInterceptor,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: AuthInterceptor,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: CacheInterceptor,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: ErrorInterceptor,
      multi: true
    },
    {
      provide: HTTP_INTERCEPTORS,
      useClass: LoadingInterceptor,
      multi: true
    }
  ]
};
```

---

## **Варианты заданий:**

### **Вариант 1: Интерцепторы для e-commerce**
Создайте интерцепторы для:
- Кэширования каталога товаров
- Обработки корзины покупок
- Ретрей запросов при ошибках
- Аналитики запросов

### **Вариант 2: Интерцепторы для социальной сети**
Создайте интерцепторы для:
- Обработки медиа-запросов
- Кэширования ленты новостей
- Оффлайн-режима
- Социальной авторизации

### **Вариант 3: Интерцепторы для финансового приложения**
Создайте интерцепторы для:
- Шифрования чувствительных данных
- Валидации финансовых операций
- Аудита запросов
- Ограничения частоты запросов

### **Вариант 4: Интерцепторы для IoT платформы**
Создайте интерцепторы для:
- Обработки потоковых данных
- Кэширования телеметрии
- Обработки оффлайн-данных
- Приоритизации запросов

### **Вариант 5: Интерцепторы для игровой платформы**
Создайте интерцепторы для:
- Кэширования игровых данных
- Обработки мультиплеерных запросов
- Анти-чит защиты
- Игровой аналитики

---

## **Критерии оценки:**

### **5 (Отлично):**
- Полная реализация всех видов интерцепторов
- Корректная обработка всех сценариев запросов/ответов
- Оптимальная архитектура и производительность
- Полная обработка ошибок и edge cases
- Качественные тесты для всех интерцепторов

### **4 (Хорошо):**
- Основные интерцепторы реализованы
- Правильная обработка основных сценариев
- Хорошая архитектура
- Базовая обработка ошибок

### **3 (Удовлетворительно):**
- Базовые интерцепторы созданы
- Есть ошибки в логике обработки
- Неполная обработка ошибок
- Минимальное тестирование

### **2 (Неудовлетворительно):**
- Интерцепторы не работают
- Критические ошибки в логике
- Отсутствие обработки ошибок
- Код не соответствует требованиям

---

## **Контрольные вопросы:**

1. В чем преимущества использования интерцепторов?
2. Как работает цепочка интерцепторов?
3. Когда использовать интерцепторы vs сервисы?
4. Как тестировать HTTP интерцепторы?
5. Какие лучшие практики создания интерцепторов?
6. Как обрабатывать асинхронные операции в интерцепторах?
7. В чем разница между `tap` и `catchError` в интерцепторах?
8. Как модифицировать запросы и ответы?
9. Как организовать зависимые интерцепторы?
10. Какие проблемы производительности могут быть с интерцепторами?

---

## **Инструкция по выполнению:**

1. **Создание проекта:**
```bash
ng new interceptors-practice --standalone
cd interceptors-practice
```

2. **Создание интерцепторов:**
```bash
ng generate interceptor interceptors/logging
ng generate interceptor interceptors/auth
ng generate interceptor interceptors/cache
ng generate interceptor interceptors/error
ng generate interceptor interceptors/loading
```

3. **Создание сервисов:**
```bash
ng generate service services/logger
ng generate service services/cache
```

4. **Реализация интерцепторов согласно варианту**

5. **Создание демонстрационных компонентов**

6. **Написание тестов**

7. **Оформление README.md**

### **Пример README.md:**

```markdown
# Практическая работа №10: HTTP интерцепторы в Angular

## Вариант 1: Комплексная система интерцепторов

### Задание:
Создать систему HTTP интерцепторов для обработки запросов и ответов

### Реализованные интерцепторы:
- ✅ `LoggingInterceptor` - логирование запросов и ответов
- ✅ `AuthInterceptor` - обработка аутентификации и авторизации
- ✅ `CacheInterceptor` - кэширование GET запросов
- ✅ `ErrorInterceptor` - централизованная обработка ошибок
- ✅ `LoadingInterceptor` - управление индикатором загрузки

### Использованные техники:
- Обработка цепочки запросов-ответов
- Модификация HTTP заголовков
- Кэширование и инвалидация
- Обработка асинхронных операций
- Глобальное состояние приложения

### Архитектура:
```
HTTP Request
    ↓
LoggingInterceptor
    ↓
AuthInterceptor
    ↓
CacheInterceptor
    ↓
LoadingInterceptor
    ↓
Server
    ↓
HTTP Response
    ↓
ErrorInterceptor
    ↓
Application
```

### Скриншоты:

![Демонстрация интерцепторов](./assets/images/interceptors-demo.png)

### Запуск проекта:
```bash
npm install
ng serve
```

### Тестирование:
```bash
ng test
```
```