# Практическая работа. Реализация JWT аутентификации в Angular

## Тема
Реализация системы аутентификации и авторизации с использованием JWT токенов в Angular приложении

## Цель
Освоить практические навыки реализации полного цикла аутентификации, работы с JWT токенами, защитой роутов и взаимодействием с защищенными API endpoints

## Теоретическая часть

### JWT (JSON Web Token)
JWT состоит из трех частей:
- **Header** - алгоритм и тип токена
- **Payload** - данные пользователя и claims
- **Signature** - подпись для верификации

### Flow аутентификации
1. Пользователь вводит credentials
2. Сервер проверяет и возвращает JWT токен
3. Клиент сохраняет токен (localStorage, cookies)
4. Токен добавляется в заголовки последующих запросов
5. Сервер проверяет токен и возвращает данные

### Механизмы хранения токена
- **LocalStorage** - простота использования, уязвимость к XSS
- **SessionStorage** - очищается при закрытии вкладки
- **HttpOnly Cookies** - защита от XSS, сложнее в реализации
- **In-memory** - максимальная безопасность, токен теряется при refresh

## Ход работы

1. Создать Angular проект с роутингом
2. Реализовать сервис аутентификации
3. Создать guards для защиты роутов
4. Реализовать интерцептор для JWT токенов
5. Создать компоненты логина, регистрации и профиля
6. Настроить обработку состояний аутентификации
7. Протестировать все сценарии
8. Сделать скриншоты результатов
9. Оформить README.md

## Практический пример

### Сервис аутентификации

```typescript
// auth.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { BehaviorSubject, Observable, tap } from 'rxjs';
import { Router } from '@angular/router';

export interface User {
  id: number;
  email: string;
  name: string;
}

export interface AuthResponse {
  access_token: string;
  user: User;
}

export interface LoginData {
  email: string;
  password: string;
}

export interface RegisterData {
  name: string;
  email: string;
  password: string;
  password_confirmation: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private apiUrl = 'http://localhost:3000/api/auth';
  private currentUserSubject = new BehaviorSubject<User | null>(null);
  public currentUser$ = this.currentUserSubject.asObservable();

  constructor(
    private http: HttpClient,
    private router: Router
  ) {
    this.loadUserFromStorage();
  }

  login(credentials: LoginData): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(`${this.apiUrl}/login`, credentials).pipe(
      tap(response => {
        this.setToken(response.access_token);
        this.currentUserSubject.next(response.user);
      })
    );
  }

  register(userData: RegisterData): Observable<AuthResponse> {
    return this.http.post<AuthResponse>(`${this.apiUrl}/register`, userData).pipe(
      tap(response => {
        this.setToken(response.access_token);
        this.currentUserSubject.next(response.user);
      })
    );
  }

  logout(): void {
    localStorage.removeItem('access_token');
    this.currentUserSubject.next(null);
    this.router.navigate(['/login']);
  }

  getToken(): string | null {
    return localStorage.getItem('access_token');
  }

  isAuthenticated(): boolean {
    const token = this.getToken();
    if (!token) return false;

    // Проверка expiration токена (базовая)
    const payload = JSON.parse(atob(token.split('.')[1]));
    return payload.exp > Date.now() / 1000;
  }

  private setToken(token: string): void {
    localStorage.setItem('access_token', token);
  }

  private loadUserFromStorage(): void {
    const token = this.getToken();
    if (token && this.isAuthenticated()) {
      // В реальном приложении здесь был бы запрос к API для получения данных пользователя
      const payload = JSON.parse(atob(token.split('.')[1]));
      this.currentUserSubject.next({
        id: payload.sub,
        email: payload.email,
        name: payload.name
      });
    }
  }
}
```

### JWT Интерцептор

```typescript
// jwt.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, BehaviorSubject } from 'rxjs';
import { catchError, filter, take, switchMap } from 'rxjs/operators';
import { AuthService } from './auth.service';

@Injectable()
export class JwtInterceptor implements HttpInterceptor {
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);

  constructor(private authService: AuthService) {}

  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const token = this.authService.getToken();
    
    if (token && this.authService.isAuthenticated()) {
      request = this.addToken(request, token);
    }

    return next.handle(request).pipe(
      catchError((error: HttpErrorResponse) => {
        if (error.status === 401 && token) {
          return this.handle401Error(request, next);
        }
        return throwError(() => error);
      })
    );
  }

  private addToken(request: HttpRequest<any>, token: string) {
    return request.clone({
      setHeaders: {
        Authorization: `Bearer ${token}`
      }
    });
  }

  private handle401Error(request: HttpRequest<any>, next: HttpHandler) {
    if (!this.isRefreshing) {
      this.isRefreshing = true;
      this.refreshTokenSubject.next(null);

      // Здесь была бы логика refresh токена
      // return this.authService.refreshToken().pipe(
      //   switchMap((token: any) => {
      //     this.isRefreshing = false;
      //     this.refreshTokenSubject.next(token.access_token);
      //     return next.handle(this.addToken(request, token.access_token));
      //   }),
      //   catchError((err) => {
      //     this.isRefreshing = false;
      //     this.authService.logout();
      //     return throwError(() => err);
      //   })
      // );

      // Для демо просто разлогиниваем
      this.authService.logout();
      return throwError(() => new Error('Session expired'));
    }

    return this.refreshTokenSubject.pipe(
      filter(token => token != null),
      take(1),
      switchMap(token => next.handle(this.addToken(request, token)))
    );
  }
}
```

### Auth Guard

```typescript
// auth.guard.ts
import { Injectable } from '@angular/core';
import { CanActivate, Router, ActivatedRouteSnapshot } from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate {
  
  constructor(
    private authService: AuthService,
    private router: Router
  ) {}

  canActivate(route: ActivatedRouteSnapshot): boolean {
    if (this.authService.isAuthenticated()) {
      // Проверка ролей если нужно
      const expectedRole = route.data['expectedRole'];
      if (expectedRole) {
        // Логика проверки роли
        return true; // Упрощенно
      }
      return true;
    }

    this.router.navigate(['/login'], { 
      queryParams: { returnUrl: route.url } 
    });
    return false;
  }
}
```

### Компонент логина

```typescript
// login.component.ts
import { Component } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { Router, ActivatedRoute } from '@angular/router';
import { AuthService, LoginData } from '../auth.service';

@Component({
  selector: 'app-login',
  template: `
    <div class="login-container">
      <form [formGroup]="loginForm" (ngSubmit)="onSubmit()" class="login-form">
        <h2>Вход в систему</h2>
        
        <div class="form-group">
          <label>Email</label>
          <input 
            type="email" 
            formControlName="email"
            class="form-control"
            [class.error]="email.invalid && email.touched">
          <div *ngIf="email.invalid && email.touched" class="error-message">
            <div *ngIf="email.errors?.['required']">Email обязателен</div>
            <div *ngIf="email.errors?.['email']">Некорректный email</div>
          </div>
        </div>

        <div class="form-group">
          <label>Пароль</label>
          <input 
            type="password" 
            formControlName="password"
            class="form-control"
            [class.error]="password.invalid && password.touched">
          <div *ngIf="password.invalid && password.touched" class="error-message">
            <div *ngIf="password.errors?.['required']">Пароль обязателен</div>
            <div *ngIf="password.errors?.['minlength']">
              Минимум {{password.errors?.['minlength'].requiredLength}} символов
            </div>
          </div>
        </div>

        <div *ngIf="error" class="alert alert-error">
          {{ error }}
        </div>

        <button 
          type="submit" 
          class="btn btn-primary"
          [disabled]="loginForm.invalid || loading">
          {{ loading ? 'Вход...' : 'Войти' }}
        </button>

        <div class="links">
          <a routerLink="/register">Нет аккаунта? Зарегистрируйтесь</a>
        </div>
      </form>
    </div>
  `,
  styles: [`
    .login-container { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: #f5f5f5; 
    }
    .login-form { 
      background: white; 
      padding: 2rem; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      width: 100%; 
      max-width: 400px; 
    }
    .form-group { margin-bottom: 1rem; }
    .form-control { 
      width: 100%; 
      padding: 0.5rem; 
      border: 1px solid #ddd; 
      border-radius: 4px; 
    }
    .form-control.error { border-color: #dc3545; }
    .error-message { color: #dc3545; font-size: 0.875rem; }
    .alert-error { 
      background: #f8d7da; 
      color: #721c24; 
      padding: 0.75rem; 
      border-radius: 4px; 
      margin-bottom: 1rem; 
    }
    .btn { 
      width: 100%; 
      padding: 0.75rem; 
      background: #007bff; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
    }
    .btn:disabled { background: #6c757d; cursor: not-allowed; }
    .links { text-align: center; margin-top: 1rem; }
  `]
})
export class LoginComponent {
  loginForm: FormGroup;
  loading = false;
  error = '';
  returnUrl = '';

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router,
    private route: ActivatedRoute
  ) {
    this.loginForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', [Validators.required, Validators.minLength(6)]]
    });

    this.returnUrl = this.route.snapshot.queryParams['returnUrl'] || '/profile';
  }

  get email() { return this.loginForm.get('email')!; }
  get password() { return this.loginForm.get('password')!; }

  onSubmit() {
    if (this.loginForm.invalid) return;

    this.loading = true;
    this.error = '';

    const credentials: LoginData = this.loginForm.value;

    this.authService.login(credentials).subscribe({
      next: () => {
        this.router.navigate([this.returnUrl]);
      },
      error: (error) => {
        this.error = error.error?.message || 'Ошибка входа';
        this.loading = false;
      }
    });
  }
}
```

## 15 вариантов заданий

### Вариант 1
**Задание:** Реализуйте полный цикл аутентификации (логин, регистрация, логаут) с JWT токенами и защитой роутов.

### Вариант 2
**Задание:** Создайте систему refresh токенов с автоматическим обновлением access токена при истечении срока действия.

### Вариант 3
**Задание:** Реализуйте ролевую модель (User, Admin) с разными уровнями доступа к роутам и функциям.

### Вариант 4
**Задание:** Создайте интерцептор для обработки 401 ошибок с автоматическим редиректом на логин.

### Вариант 5
**Задание:** Реализуйте "Remember me" функционал с долгоживущими токенами.

### Вариант 6
**Задание:** Создайте сервис для управления сессиями с возможностью просмотра активных сессий и удаления.

### Вариант 7
**Задание:** Реализуйте OAuth2 аутентификацию через Google/GitHub с JWT токенами.

### Вариант 8
**Задание:** Создайте систему двухфакторной аутентификации (2FA) с подтверждением по email/SMS.

### Вариант 9
**Задание:** Реализуйте принудительный логаут при смене пароля или блокировке аккаунта.

### Вариант 10
**Задание:** Создайте middleware для проверки прав доступа к API endpoints на основе JWT claims.

### Вариант 11
**Задание:** Реализуйте безопасное хранение токенов с использованием HttpOnly cookies вместо localStorage.

### Вариант 12
**Задание:** Создайте систему ограничения попыток входа (rate limiting) и блокировки при подозрительной активности.

### Вариант 13
**Задание:** Реализуйте функционал "Forgot password" с отправкой reset ссылки на email.

### Вариант 14
**Задание:** Создайте административную панель для управления пользователями и их правами.

### Вариант 15
**Задание:** Реализуйте аудит действий пользователя с логированием важных событий аутентификации.

## Критерии оценки

### 5 (Отлично)
- Полностью реализовано задание согласно варианту
- Корректная работа с JWT токенами (сохранение, передача, обновление)
- Надежная защита роутов с помощью guards
- Правильная обработка ошибок аутентификации
- Безопасное хранение токенов
- Чистый, хорошо структурированный код
- Полностью оформленный README.md со скриншотами

### 4 (Хорошо)
- Задание реализовано, но есть незначительные ошибки
- Основная функциональность аутентификации работает корректно
- Защита роутов реализована, но могут быть недочеты
- README.md оформлен, но может не хватать некоторых деталей

### 3 (Удовлетворительно)
- Основная функциональность реализована
- Есть существенные ошибки в безопасности или работе с токенами
- Защита роутов работает частично
- Код требует значительных улучшений
- README.md оформлен минимально

### 2 (Неудовлетворительно)
- Задание не выполнено или выполнено некорректно
- Критические ошибки в системе аутентификации
- Нет защиты роутов или она не работает
- README.md отсутствует или оформлен неполно

## Контрольные вопросы

1. Что такое JWT и из каких частей он состоит?
2. Какие преимущества и недостатки у JWT перед session-based аутентификацией?
3. Как безопасно хранить JWT токен на клиенте?
4. Что такое XSS и CSRF атаки и как от них защищаться?
5. Как работает механизм refresh токенов?
6. Что такое HttpOnly cookies и чем они безопаснее localStorage?
7. Как реализовать проверку прав доступа на основе JWT claims?
8. Что такое CORS и как он влияет на аутентификацию?
9. Как обрабатывать истечение срока действия токена?
10. Какие best practices для безопасности JWT аутентификации?

---

# Пример README.md для варианта 1

```markdown
# Практическая работа: Реализация JWT аутентификации в Angular

**Номер варианта:** 1  
**Студент:** [ФИО]  
**Группа:** [Номер группы]

## Задание
Реализуйте полный цикл аутентификации (логин, регистрация, логаут) с JWT токенами и защитой роутов.

## Реализация

### Настройка модуля
```typescript
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { ReactiveFormsModule } from '@angular/forms';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { LoginComponent } from './components/login/login.component';
import { RegisterComponent } from './components/register/register.component';
import { ProfileComponent } from './components/profile/profile.component';
import { JwtInterceptor } from './interceptors/jwt.interceptor';

@NgModule({
  declarations: [
    AppComponent,
    LoginComponent,
    RegisterComponent,
    ProfileComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule,
    ReactiveFormsModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### Настройка роутинга
```typescript
// app-routing.module.ts
import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { LoginComponent } from './components/login/login.component';
import { RegisterComponent } from './components/register/register.component';
import { ProfileComponent } from './components/profile/profile.component';
import { AuthGuard } from './guards/auth.guard';

const routes: Routes = [
  { path: 'login', component: LoginComponent },
  { path: 'register', component: RegisterComponent },
  { path: 'profile', component: ProfileComponent, canActivate: [AuthGuard] },
  { path: '', redirectTo: '/profile', pathMatch: 'full' },
  { path: '**', redirectTo: '/profile' }
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

### Компонент профиля
```typescript
// profile.component.ts
import { Component, OnInit } from '@angular/core';
import { AuthService, User } from '../auth.service';

@Component({
  selector: 'app-profile',
  template: `
    <div class="profile-container">
      <div class="profile-card">
        <h2>Профиль пользователя</h2>
        
        <div *ngIf="user; else loading">
          <div class="user-info">
            <p><strong>ID:</strong> {{ user.id }}</p>
            <p><strong>Имя:</strong> {{ user.name }}</p>
            <p><strong>Email:</strong> {{ user.email }}</p>
          </div>
          
          <button (click)="logout()" class="btn btn-logout">
            Выйти
          </button>
        </div>

        <ng-template #loading>
          <p>Загрузка данных...</p>
        </ng-template>
      </div>
    </div>
  `,
  styles: [`
    .profile-container { 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      min-height: 100vh; 
      background: #f5f5f5; 
    }
    .profile-card { 
      background: white; 
      padding: 2rem; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0,0,0,0.1); 
      width: 100%; 
      max-width: 400px; 
    }
    .user-info { margin-bottom: 1.5rem; }
    .btn-logout { 
      width: 100%; 
      padding: 0.75rem; 
      background: #dc3545; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
    }
  `]
})
export class ProfileComponent implements OnInit {
  user: User | null = null;

  constructor(private authService: AuthService) {}

  ngOnInit() {
    this.authService.currentUser$.subscribe(user => {
      this.user = user;
    });
  }

  logout() {
    this.authService.logout();
  }
}
```

## Результат работы

### Скриншот 1: Страница логина
![Страница логина](images/login-page.png)

### Скриншот 2: Успешная аутентификация
![Профиль пользователя](images/profile-page.png)

### Скриншот 3: Защита роутов
![Редирект на логин](images/auth-redirect.png)
```

## Структура репозитория
```
practical-work-jwt-auth/
├── src/
│   ├── app/
│   │   ├── services/
│   │   │   └── auth.service.ts
│   │   ├── components/
│   │   │   ├── login/
│   │   │   ├── register/
│   │   │   └── profile/
│   │   ├── guards/
│   │   │   └── auth.guard.ts
│   │   ├── interceptors/
│   │   │   └── jwt.interceptor.ts
│   │   └── models/
│   └── ...
├── images/
│   ├── login-page.png
│   ├── profile-page.png
│   └── auth-redirect.png
├── README.md
└── package.json
```

## Команды для развертывания в Gogs

```bash
# Инициализация репозитория
git init
git add .
git commit -m "Практическая работа: Реализация JWT аутентификации"
git remote add origin http://gogs-server/username/practical-work-jwt-auth.git
git push -u origin master
```
