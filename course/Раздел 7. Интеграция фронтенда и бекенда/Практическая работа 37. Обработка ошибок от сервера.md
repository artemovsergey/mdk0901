# Практическая работа. Обработка ошибок от сервера API в Angular

## Тема
Систематическая обработка и управление ошибками, поступающими от серверного API в Angular приложении

## Цель
Освоить практические навыки обработки различных типов ошибок HTTP, создание универсальных механизмов обработки ошибок, пользовательского интерфейса для отображения ошибок и стратегий восстановления

## Теоретическая часть

### Типы HTTP ошибок
- **4xx (Client Errors)**: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict
- **5xx (Server Errors)**: 500 Internal Server, 502 Bad Gateway, 503 Service Unavailable
- **Network Errors**: timeout, CORS, DNS issues

### Подходы к обработке ошибок
1. **Глобальная обработка** - HTTP интерцепторы
2. **Локальная обработка** - обработка в компонентах
3. **User-friendly сообщения** - преобразование технических ошибок
4. **Стратегии восстановления** - retry, fallback, cache

### Структура ошибки API
```typescript
interface ApiError {
  message: string;
  code: string;
  details?: any;
  timestamp?: string;
}
```

## Ход работы

1. Создать Angular проект с HttpClientModule
2. Реализовать сервис для работы с API
3. Создать глобальный интерцептор для обработки ошибок
4. Реализовать сервис уведомлений об ошибках
5. Создать компоненты для отображения ошибок
6. Добавить стратегии retry и fallback
7. Протестировать различные сценарии ошибок
8. Сделать скриншоты результатов
9. Оформить README.md

## Практический пример

### Модели ошибок

```typescript
// models/error.models.ts
export interface ApiErrorResponse {
  status: number;
  message: string;
  errors?: ValidationError[];
  code?: string;
  timestamp?: string;
}

export interface ValidationError {
  field: string;
  message: string;
}

export enum ErrorType {
  NETWORK = 'NETWORK_ERROR',
  SERVER = 'SERVER_ERROR',
  CLIENT = 'CLIENT_ERROR',
  VALIDATION = 'VALIDATION_ERROR',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  NOT_FOUND = 'NOT_FOUND',
  TIMEOUT = 'TIMEOUT_ERROR',
  UNKNOWN = 'UNKNOWN_ERROR'
}
```

### Сервис обработки ошибок

```typescript
// services/error.service.ts
import { Injectable, Injector } from '@angular/core';
import { HttpErrorResponse } from '@angular/common/http';
import { Router } from '@angular/router';
import { ApiErrorResponse, ErrorType, ValidationError } from '../models/error.models';

@Injectable({
  providedIn: 'root'
})
export class ErrorService {
  
  constructor(
    private injector: Injector
  ) {}

  getClientMessage(error: Error): string {
    if (!navigator.onLine) {
      return 'Отсутствует подключение к интернету';
    }
    return error.message ? error.message : error.toString();
  }

  getClientStack(error: Error): string {
    return error.stack || '';
  }

  getServerMessage(error: HttpErrorResponse): string {
    if (error.error instanceof ErrorEvent) {
      // Client-side error
      return error.error.message;
    } else {
      // Server-side error
      return this.getUserFriendlyMessage(error);
    }
  }

  getServerStack(error: HttpErrorResponse): string {
    // В продакшене stack trace не должен показываться пользователям
    return 'Server error stack trace';
  }

  getUserFriendlyMessage(error: HttpErrorResponse): string {
    const status = error.status;
    
    switch (status) {
      case 0:
        return 'Не удалось подключиться к серверу. Проверьте подключение к интернету.';
      
      case 400:
        if (error.error?.errors) {
          return 'Ошибка валидации данных';
        }
        return error.error?.message || 'Некорректный запрос';
      
      case 401:
        return 'Требуется авторизация';
      
      case 403:
        return 'Доступ запрещен';
      
      case 404:
        return 'Запрашиваемый ресурс не найден';
      
      case 409:
        return 'Конфликт данных';
      
      case 422:
        return 'Ошибка валидации данных';
      
      case 429:
        return 'Слишком много запросов. Попробуйте позже.';
      
      case 500:
        return 'Внутренняя ошибка сервера';
      
      case 502:
        return 'Сервер временно недоступен';
      
      case 503:
        return 'Сервер перегружен. Попробуйте позже.';
      
      default:
        return error.error?.message || 'Произошла неизвестная ошибка';
    }
  }

  getErrorType(error: HttpErrorResponse): ErrorType {
    const status = error.status;
    
    if (status === 0) return ErrorType.NETWORK;
    if (status >= 500) return ErrorType.SERVER;
    if (status === 401) return ErrorType.UNAUTHORIZED;
    if (status === 403) return ErrorType.FORBIDDEN;
    if (status === 404) return ErrorType.NOT_FOUND;
    if (status === 400 || status === 422) return ErrorType.VALIDATION;
    if (status >= 400 && status < 500) return ErrorType.CLIENT;
    
    return ErrorType.UNKNOWN;
  }

  getValidationErrors(error: HttpErrorResponse): ValidationError[] {
    if (error.error?.errors && Array.isArray(error.error.errors)) {
      return error.error.errors;
    }
    return [];
  }

  shouldRetry(error: HttpErrorResponse): boolean {
    const errorType = this.getErrorType(error);
    return [ErrorType.NETWORK, ErrorType.TIMEOUT, ErrorType.SERVER].includes(errorType);
  }

  handleError(error: HttpErrorResponse): void {
    const router = this.injector.get(Router);
    const errorType = this.getErrorType(error);

    switch (errorType) {
      case ErrorType.UNAUTHORIZED:
        router.navigate(['/login']);
        break;
      
      case ErrorType.FORBIDDEN:
        router.navigate(['/access-denied']);
        break;
      
      case ErrorType.NOT_FOUND:
        router.navigate(['/not-found']);
        break;
      
      default:
        // Другие ошибки обрабатываются локально
        break;
    }
  }
}
```

### Глобальный интерцептор ошибок

```typescript
// interceptors/error.interceptor.ts
import { Injectable } from '@angular/core';
import { HttpRequest, HttpHandler, HttpEvent, HttpInterceptor, HttpErrorResponse } from '@angular/common/http';
import { Observable, throwError, BehaviorSubject, of } from 'rxjs';
import { catchError, switchMap, take, filter, retryWhen, delay, scan } from 'rxjs/operators';
import { ErrorService } from '../services/error.service';
import { NotificationService } from '../services/notification.service';

@Injectable()
export class ErrorInterceptor implements HttpInterceptor {
  
  private isRefreshing = false;
  private refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);

  constructor(
    private errorService: ErrorService,
    private notificationService: NotificationService
  ) {}

  intercept(request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    return next.handle(request).pipe(
      retryWhen(errors => errors.pipe(
        scan((retryCount, error) => {
          if (retryCount >= 3 || !this.errorService.shouldRetry(error)) {
            throw error;
          }
          retryCount++;
          console.log(`Retry attempt ${retryCount} for ${request.url}`);
          return retryCount;
        }, 0),
        delay(1000)
      )),
      catchError((error: HttpErrorResponse) => {
        return this.handleError(error, request, next);
      })
    );
  }

  private handleError(error: HttpErrorResponse, request: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    
    // Логирование ошибки
    console.error('HTTP Error:', {
      url: request.url,
      status: error.status,
      message: error.message,
      timestamp: new Date().toISOString()
    });

    const userFriendlyMessage = this.errorService.getUserFriendlyMessage(error);
    const errorType = this.errorService.getErrorType(error);

    // Показ уведомления пользователю
    if (this.shouldShowNotification(error)) {
      this.notificationService.showError(userFriendlyMessage);
    }

    // Глобальная обработка определенных ошибок
    this.errorService.handleError(error);

    // Возврат ошибки для локальной обработки
    const apiError: ApiErrorResponse = {
      status: error.status,
      message: userFriendlyMessage,
      errors: this.errorService.getValidationErrors(error),
      code: errorType,
      timestamp: new Date().toISOString()
    };

    return throwError(() => apiError);
  }

  private shouldShowNotification(error: HttpErrorResponse): boolean {
    const status = error.status;
    // Не показываем уведомления для 401 (перенаправляем на логин)
    // и для ошибок валидации (обрабатываются в формах)
    return status !== 401 && status !== 422 && status !== 400;
  }
}
```

### Сервис уведомлений

```typescript
// services/notification.service.ts
import { Injectable, TemplateRef } from '@angular/core';
import { BehaviorSubject, Observable } from 'rxjs';

export interface Notification {
  id: number;
  type: 'success' | 'error' | 'warning' | 'info';
  message: string;
  duration?: number;
  dismissible?: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class NotificationService {
  private notificationsSubject = new BehaviorSubject<Notification[]>([]);
  public notifications$ = this.notificationsSubject.asObservable();
  private nextId = 1;

  showSuccess(message: string, duration: number = 5000): void {
    this.showNotification('success', message, duration);
  }

  showError(message: string, duration: number = 10000): void {
    this.showNotification('error', message, duration);
  }

  showWarning(message: string, duration: number = 7000): void {
    this.showNotification('warning', message, duration);
  }

  showInfo(message: string, duration: number = 5000): void {
    this.showNotification('info', message, duration);
  }

  private showNotification(type: Notification['type'], message: string, duration: number = 5000): void {
    const notification: Notification = {
      id: this.nextId++,
      type,
      message,
      duration,
      dismissible: true
    };

    const currentNotifications = this.notificationsSubject.value;
    this.notificationsSubject.next([...currentNotifications, notification]);

    if (duration > 0) {
      setTimeout(() => {
        this.removeNotification(notification.id);
      }, duration);
    }
  }

  removeNotification(id: number): void {
    const currentNotifications = this.notificationsSubject.value;
    const filteredNotifications = currentNotifications.filter(notification => notification.id !== id);
    this.notificationsSubject.next(filteredNotifications);
  }

  clearAll(): void {
    this.notificationsSubject.next([]);
  }
}
```

### Компонент уведомлений

```typescript
// components/notification/notification.component.ts
import { Component, OnInit } from '@angular/core';
import { NotificationService, Notification } from '../../services/notification.service';

@Component({
  selector: 'app-notification',
  template: `
    <div class="notifications-container">
      <div 
        *ngFor="let notification of notifications"
        class="notification"
        [class]="'notification-' + notification.type"
        (click)="remove(notification.id)">
        
        <div class="notification-icon">
          <span *ngIf="notification.type === 'success'">✓</span>
          <span *ngIf="notification.type === 'error'">✕</span>
          <span *ngIf="notification.type === 'warning'">⚠</span>
          <span *ngIf="notification.type === 'info'">ℹ</span>
        </div>
        
        <div class="notification-content">
          {{ notification.message }}
        </div>
        
        <button 
          *ngIf="notification.dismissible"
          class="notification-close"
          (click)="remove(notification.id)">
          ×
        </button>
      </div>
    </div>
  `,
  styles: [`
    .notifications-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 1000;
      max-width: 400px;
    }
    .notification {
      display: flex;
      align-items: center;
      padding: 12px 16px;
      margin-bottom: 10px;
      border-radius: 4px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      cursor: pointer;
      transition: transform 0.3s ease;
    }
    .notification:hover {
      transform: translateX(-5px);
    }
    .notification-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .notification-error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .notification-warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeaa7;
    }
    .notification-info {
      background: #d1ecf1;
      color: #0c5460;
      border: 1px solid #bee5eb;
    }
    .notification-icon {
      margin-right: 10px;
      font-weight: bold;
    }
    .notification-content {
      flex: 1;
    }
    .notification-close {
      background: none;
      border: none;
      font-size: 18px;
      cursor: pointer;
      margin-left: 10px;
    }
  `]
})
export class NotificationComponent implements OnInit {
  notifications: Notification[] = [];

  constructor(private notificationService: NotificationService) {}

  ngOnInit() {
    this.notificationService.notifications$.subscribe(notifications => {
      this.notifications = notifications;
    });
  }

  remove(id: number): void {
    this.notificationService.removeNotification(id);
  }
}
```

### Компонент с обработкой ошибок

```typescript
// components/user-profile/user-profile.component.ts
import { Component, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators } from '@angular/forms';
import { UserService } from '../../services/user.service';
import { ApiErrorResponse, ValidationError } from '../../models/error.models';

@Component({
  selector: 'app-user-profile',
  template: `
    <div class="user-profile">
      <h2>Профиль пользователя</h2>
      
      <!-- Состояние загрузки -->
      <div *ngIf="loading" class="loading-state">
        <div class="spinner"></div>
        <p>Загрузка данных...</p>
      </div>

      <!-- Основной контент -->
      <div *ngIf="!loading" class="profile-content">
        
        <!-- Глобальная ошибка -->
        <div *ngIf="globalError" class="error-card">
          <h3>Ошибка загрузки</h3>
          <p>{{ globalError }}</p>
          <button (click)="loadUserProfile()" class="btn btn-retry">
            Попробовать снова
          </button>
        </div>

        <!-- Форма профиля -->
        <form 
          *ngIf="!globalError && user" 
          [formGroup]="profileForm" 
          (ngSubmit)="onSubmit()"
          class="profile-form">
          
          <div class="form-group">
            <label>Имя</label>
            <input 
              type="text" 
              formControlName="name"
              [class.error]="hasFieldError('name')">
            <div *ngIf="hasFieldError('name')" class="field-error">
              {{ getFieldError('name') }}
            </div>
          </div>

          <div class="form-group">
            <label>Email</label>
            <input 
              type="email" 
              formControlName="email"
              [class.error]="hasFieldError('email')">
            <div *ngIf="hasFieldError('email')" class="field-error">
              {{ getFieldError('email') }}
            </div>
          </div>

          <div class="form-actions">
            <button 
              type="submit" 
              [disabled]="profileForm.invalid || saving"
              class="btn btn-primary">
              {{ saving ? 'Сохранение...' : 'Сохранить' }}
            </button>
            
            <button 
              type="button" 
              (click)="resetForm()"
              [disabled]="saving"
              class="btn btn-secondary">
              Отмена
            </button>
          </div>

          <!-- Ошибка сохранения -->
          <div *ngIf="saveError" class="save-error">
            {{ saveError }}
          </div>
        </form>
      </div>
    </div>
  `,
  styles: [`
    .user-profile { max-width: 500px; margin: 0 auto; padding: 20px; }
    .loading-state { text-align: center; padding: 40px; }
    .spinner { 
      border: 4px solid #f3f3f3; 
      border-top: 4px solid #007bff; 
      border-radius: 50%; 
      width: 40px; 
      height: 40px; 
      animation: spin 1s linear infinite; 
      margin: 0 auto 20px; 
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    .error-card { 
      background: #f8d7da; 
      color: #721c24; 
      padding: 20px; 
      border-radius: 8px; 
      text-align: center; 
    }
    .profile-form { margin-top: 20px; }
    .form-group { margin-bottom: 20px; }
    .form-group label { display: block; margin-bottom: 5px; font-weight: bold; }
    .form-group input { 
      width: 100%; 
      padding: 8px 12px; 
      border: 1px solid #ddd; 
      border-radius: 4px; 
    }
    .form-group input.error { border-color: #dc3545; }
    .field-error { color: #dc3545; font-size: 0.875rem; margin-top: 5px; }
    .form-actions { display: flex; gap: 10px; margin-top: 20px; }
    .btn { padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .btn-primary { background: #007bff; color: white; }
    .btn-secondary { background: #6c757d; color: white; }
    .btn-retry { background: #28a745; color: white; }
    .save-error { 
      background: #f8d7da; 
      color: #721c24; 
      padding: 10px; 
      border-radius: 4px; 
      margin-top: 15px; 
    }
  `]
})
export class UserProfileComponent implements OnInit {
  profileForm: FormGroup;
  loading = false;
  saving = false;
  globalError: string | null = null;
  saveError: string | null = null;
  validationErrors: ValidationError[] = [];
  user: any = null;

  constructor(
    private fb: FormBuilder,
    private userService: UserService
  ) {
    this.profileForm = this.fb.group({
      name: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]]
    });
  }

  ngOnInit() {
    this.loadUserProfile();
  }

  loadUserProfile(): void {
    this.loading = true;
    this.globalError = null;

    this.userService.getUserProfile().subscribe({
      next: (user) => {
        this.user = user;
        this.profileForm.patchValue(user);
        this.loading = false;
      },
      error: (error: ApiErrorResponse) => {
        this.globalError = error.message;
        this.loading = false;
      }
    });
  }

  onSubmit(): void {
    if (this.profileForm.invalid) return;

    this.saving = true;
    this.saveError = null;
    this.validationErrors = [];

    this.userService.updateUserProfile(this.profileForm.value).subscribe({
      next: (user) => {
        this.user = user;
        this.saving = false;
        // Показ успешного уведомления
      },
      error: (error: ApiErrorResponse) => {
        this.saving = false;
        
        if (error.errors && error.errors.length > 0) {
          this.validationErrors = error.errors;
        } else {
          this.saveError = error.message;
        }
      }
    });
  }

  resetForm(): void {
    if (this.user) {
      this.profileForm.patchValue(this.user);
    }
    this.saveError = null;
    this.validationErrors = [];
  }

  hasFieldError(fieldName: string): boolean {
    return this.validationErrors.some(error => error.field === fieldName);
  }

  getFieldError(fieldName: string): string {
    const error = this.validationErrors.find(error => error.field === fieldName);
    return error ? error.message : '';
  }
}
```

## 15 вариантов заданий

### Вариант 1
**Задание:** Реализуйте глобальный интерцептор ошибок с классификацией ошибок по типам и автоматическим показом уведомлений.

### Вариант 2
**Задание:** Создайте систему retry механизма с экспоненциальной задержкой для сетевых ошибок и ошибок сервера.

### Вариант 3
**Задание:** Реализуйте обработку ошибок валидации форм с отображением ошибок для конкретных полей.

### Вариант 4
**Задание:** Создайте сервис уведомлений с разными типами сообщений (success, error, warning, info) и возможностью автоматического скрытия.

### Вариант 5
**Задание:** Реализуйте fallback стратегии для критических данных (например, показ кэшированных данных при ошибке сети).

### Вариант 6
**Задание:** Создайте страницы для обработки специфических HTTP ошибок (404, 500, 403) с пользовательским дизайном.

### Вариант 7
**Задание:** Реализуйте механизм логирования ошибок на клиенте с отправкой в сервис мониторинга.

### Вариант 8
**Задание:** Создайте систему обработки ошибок для upload файлов с отображением прогресса и детальных ошибок.

### Вариант 9
**Задание:** Реализуйте обработку CORS ошибок и ошибок сети с соответствующими пользовательскими сообщениями.

### Вариант 10
**Задание:** Создайте механизм обработки таймаутов запросов с возможностью настройки времени для разных endpoints.

### Вариант 11
**Задание:** Реализуйте систему кэширования запросов для обеспечения работы приложения при отсутствии сети.

### Вариант 12
**Задание:** Создайте обработчик для rate limiting ошибок (429) с автоматическим ожиданием и повторением.

### Вариант 13
**Задание:** Реализуйте стратегию circuit breaker для предотвращения повторяющихся запросов к недоступному сервису.

### Вариант 14
**Задание:** Создайте систему пользовательских обработчиков ошибок для разных модулей приложения.

### Вариант 15
**Задание:** Реализуйте A/B тестирование различных стратегий обработки ошибок и их влияния на пользовательский опыт.

## Критерии оценки

### 5 (Отлично)
- Полностью реализовано задание согласно варианту
- Корректная обработка всех типов HTTP ошибок
- Эффективный механизм retry и fallback
- Пользователь-friendly сообщения об ошибках
- Чистый, хорошо структурированный код с правильной типизацией
- Глобальная и локальная обработка ошибок
- Полностью оформленный README.md со скриншотами

### 4 (Хорошо)
- Задание реализовано, но есть незначительные ошибки
- Основные типы ошибок обрабатываются корректно
- Пользовательские сообщения адекватны
- README.md оформлен, но может не хватать некоторых деталей

### 3 (Удовлетворительно)
- Основная функциональность реализована
- Есть существенные ошибки в обработке определенных типов ошибок
- Не все сценарии покрыты
- Код требует улучшений
- README.md оформлен минимально

### 2 (Неудовлетворительно)
- Задание не выполнено или выполнено некорректно
- Критические ошибки в системе обработки ошибок
- Нет пользовательских сообщений или они неинформативны
- README.md отсутствует или оформлен неполно

## Контрольные вопросы

1. Какие основные категории HTTP ошибок существуют?
2. В чем разница между глобальной и локальной обработкой ошибок?
3. Как работает механизм retry в RxJS?
4. Что такое exponential backoff и когда его применять?
5. Как обрабатывать ошибки валидации форм?
6. Какие стратегии fallback можно использовать при ошибках сети?
7. Как обеспечить безопасность при логировании ошибок?
8. Что такое Circuit Breaker паттерн и как его реализовать?
9. Как тестировать обработку ошибок в Angular?
10. Какие best practices для пользовательских сообщений об ошибках?

---

# Пример README.md для варианта 1

```markdown
# Практическая работа: Обработка ошибок от сервера API в Angular

**Номер варианта:** 1  
**Студент:** [ФИО]  
**Группа:** [Номер группы]

## Задание
Реализуйте глобальный интерцептор ошибок с классификацией ошибок по типам и автоматическим показом уведомлений.

## Реализация

### Настройка модуля
```typescript
// app.module.ts
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { HttpClientModule, HTTP_INTERCEPTORS } from '@angular/common/http';
import { ReactiveFormsModule } from '@angular/forms';

import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { NotificationComponent } from './components/notification/notification.component';
import { UserProfileComponent } from './components/user-profile/user-profile.component';
import { ErrorInterceptor } from './interceptors/error.interceptor';

@NgModule({
  declarations: [
    AppComponent,
    NotificationComponent,
    UserProfileComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule,
    ReactiveFormsModule
  ],
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: ErrorInterceptor, multi: true }
  ],
  bootstrap: [AppComponent]
})
export class AppModule { }
```

### Пример использования в компоненте
```typescript
// example.component.ts
import { Component } from '@angular/core';
import { UserService } from '../services/user.service';
import { ApiErrorResponse } from '../models/error.models';

@Component({
  selector: 'app-example',
  template: `
    <div>
      <button (click)="makeRequest()" [disabled]="loading">
        {{ loading ? 'Загрузка...' : 'Сделать запрос' }}
      </button>
      
      <div *ngIf="error" class="error-message">
        Ошибка: {{ error }}
      </div>
      
      <div *ngIf="data">
        <h3>Данные:</h3>
        <pre>{{ data | json }}</pre>
      </div>
    </div>
  `
})
export class ExampleComponent {
  data: any;
  error: string | null = null;
  loading = false;

  constructor(private userService: UserService) {}

  makeRequest(): void {
    this.loading = true;
    this.error = null;

    this.userService.getUsers().subscribe({
      next: (data) => {
        this.data = data;
        this.loading = false;
      },
      error: (error: ApiErrorResponse) => {
        this.error = error.message;
        this.loading = false;
      }
    });
  }
}
```

## Результат работы

### Скриншот 1: Уведомление об ошибке сети
![Ошибка сети](images/network-error.png)

### Скриншот 2: Ошибка сервера 500
![Ошибка сервера](images/server-error.png)

### Скриншот 3: Ошибка валидации формы
![Ошибка валидации](images/validation-error.png)

### Скриншот 4: Успешное уведомление
![Успешное уведомление](images/success-notification.png)
```

## Структура репозитория
```
practical-work-error-handling/
├── src/
│   ├── app/
│   │   ├── services/
│   │   │   ├── error.service.ts
│   │   │   ├── notification.service.ts
│   │   │   └── user.service.ts
│   │   ├── components/
│   │   │   ├── notification/
│   │   │   └── user-profile/
│   │   ├── interceptors/
│   │   │   └── error.interceptor.ts
│   │   ├── models/
│   │   │   └── error.models.ts
│   │   └── guards/
│   └── ...
├── images/
│   ├── network-error.png
│   ├── server-error.png
│   ├── validation-error.png
│   └── success-notification.png
├── README.md
└── package.json
```

## Команды для развертывания в Gogs

```bash
# Инициализация репозитория
git init
git add .
git commit -m "Практическая работа: Обработка ошибок от сервера API"
git remote add origin http://gogs-server/username/practical-work-error-handling.git
git push -u origin master
```
