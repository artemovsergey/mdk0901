# Лекция. RxJs в Angular: Реактивное программирование для эффективных приложений

**Цель:** Понять философию реактивного программирования, изучить ключевые понятия и операторы RxJs и научиться применять их для решения реальных задач в Angular-приложениях.

---

### **План лекции:**

1.  **Введение: Почему RxJs?**
    *   Проблемы асинхронного кода (Callback Hell, сложность с Promises).
    *   Что такое Reactive Programming?
    *   RxJs как реализация реактивных расширений для JavaScript.

2.  **Основные строительные блоки: Observable, Observer, Subscription**
    *   `Observable` (Поток): Поток данных во времени.
    *   `Observer`: Объект с обработчиками для значений, ошибок и завершения потока.
    *   `Subscription`: Результат подписки на Observable. Управление жизненным циклом.

3.  **Создание Observable (Создание потоков)**
    *   Ручное создание с `new Observable()`.
    *   Использование функций-создателей: `of`, `from`, `fromEvent`, `interval`, `ajax`.

4.  **Операторы RxJs: Сила преобразования и композиции**
    *   Что такое операторы? Чистые функции.
    *   Категории операторов: Creation, Transformation, Filtering, Combination, Utility, Error Handling.
    *   **Подробный разбор ключевых операторов:**
        *   `map`, `filter`, `tap`
        *   `debounceTime`, `distinctUntilChanged`
        *   `switchMap`, `mergeMap`, `concatMap`
        *   `catchError`, `retry`
    *   Пайпинг с помощью `pipe()`.

5.  **Субъекты (Subjects): Особый тип Observable**
    *   Что такое Subject? Одновременно Observable и Observer.
    *   `Subject`, `BehaviorSubject`, `ReplaySubject`.
    *   Практическое применение для межкомпонентной коммуникации через сервис.

6.  **Интеграция RxJs с Angular**
    *   `AsyncPipe` — лучший друг фронтенд-разработчика.
    *   Отписка автоматически.
    *   Работа с HTTP-клиентом (который возвращает Observable).
    *   Реактивные формы ( `valueChanges`, `statusChanges`).

7.  **Паттерны и лучшие практики**
    *   Главное правило: Не забывать отписываться (кроме случаев с `AsyncPipe`).
    *   Избегайте "подписки внутри подписки" (используйте операторы для преобразования).
    *   Использование `takeUntil` для управления множественными подписками.

---

### **Детальное рассмотрение пунктов плана:**

#### **1. Введение: Почему RxJs?**

**Проблема:** Традиционный асинхронный код (колбэки, Promise) хорошо работает для одиночных операций, но становится сложным для:
*   Последовательных/параллельных запросов.
*   Отмены операций (например, уход со страницы до завершения HTTP-запроса).
*   Работы с событиями, которые происходят много раз (клики, ввод в поле).

**Решение:** Реактивное программирование — это программирование с асинхронными потоками данных.
*   **Поток (Stream)** — это всё: переменные, пользовательские события, HTTP-запросы.
*   **RxJs (Reactive Extensions for JavaScript)** — библиотека для композиции асинхронных и событийных программ с помощью observable-последовательностей.

**Аналог:** Представьте, что `Promise` — это одно письмо, которое вы ждете от друга. `Observable` — это почтовый ящик, в который постоянно приходят письма, журналы, счета, и вы можете решать, что с ними делать: фильтровать, комбинировать, преобразовывать.

---

#### **2. Основные строительные блоки**

*   **`Observable`:** Представляет собой ленивую коллекцию будущих значений или событий.
    ```typescript
    // Создание Observable, который испустит три числа
    const numberStream$ = new Observable<number>(subscriber => {
      subscriber.next(1);
      subscriber.next(2);
      subscriber.next(3);
      subscriber.complete(); // Завершает поток
    });
    ```

*   **`Observer`:** Объект, который определяет, как реагировать на данные из Observable. У него три возможных метода:
    ```typescript
    const myObserver = {
      next: (value) => console.log('Получили значение:', value), // 1, 2, 3
      error: (err) => console.error('Произошла ошибка:', err),
      complete: () => console.log('Поток завершен.')
    };
    ```

*   **`Subscription`:** Результат вызова метода `subscribe()`. Связывает Observable и Observer. Управляет ресурсами.
    ```typescript
    const subscription: Subscription = numberStream$.subscribe(myObserver);

    // Чтобы отписаться и освободить ресурсы (очень важно!)
    subscription.unsubscribe();
    ```

---

#### **3. Создание Observable**

Редко создаем вручную. Чаще используем функции-создатели:

```typescript
import { of, from, fromEvent, interval, ajax } from 'rxjs';

// of: Создает из переданных значений
const data$ = of(1, 2, 3, 'hello'); // Испустит 1,2,3,'hello' и завершится.

// from: Создает из массива, Promise, итератора
const fromArray$ = from([10, 20, 30]);
const fromPromise$ = from(fetch('/api/data'));

// fromEvent: Создает из событий DOM
const click$ = fromEvent(document, 'click');

// interval: Создает поток, испускающий числа через заданные интервалы
const timer$ = interval(1000); // 0, 1, 2, ... каждую секунду

// ajax: Для HTTP-запросов
const apiData$ = ajax.getJSON('/api/users');
```

---

#### **4. Операторы RxJs**

Операторы — это чистые функции, которые преобразуют один Observable в другой. Они комбинируются внутри `pipe()`.

```typescript
import { map, filter, tap, debounceTime, distinctUntilChanged, switchMap, catchError } from 'rxjs/operators';

// Допустим, у нас есть поток ввода с поисковой строки
const searchTerm$ = fromEvent(searchInputElement, 'input').pipe(
  // Получаем значение из события
  map((event: any) => event.target.value),

  // tap - для сайд-эффектов (логирование), не меняет поток
  tap(value => console.log('Пользователь ввел:', value)),

  // Ждем 300мс после последнего нажатия, чтобы не спамить на сервер
  debounceTime(300),

  // Отправляем запрос только если значение изменилось
  distinctUntilChanged(),

  // switchMap - отменяет предыдущий HTTP-запрос, если пришел новый
  switchMap(searchTerm => 
    ajax.getJSON(`/api/search?q=${searchTerm}`).pipe(
      // Обработка ошибок на уровне конкретного запроса
      catchError(error => of([])) // В случае ошибки возвращаем пустой массив
    )
  )
);

// Подписываемся на итоговый поток
searchTerm$.subscribe(users => {
  console.log('Найдены пользователи:', users);
  // Обновляем UI
});
```

**Разбор операторов:**
*   `map` - как `Array.map`, но для потока. Преобразует каждое значение.
*   `filter` - пропускает только значения, удовлетворяющие условию.
*   `debounceTime` - "поглощение дребезга". Игнорирует значения, пока поток не "успокоится".
*   `distinctUntilChanged` - испускает значение только если оно отличается от предыдущего.
*   `switchMap` (и другие операторы высшего порядка) - получает значение из внешнего потока, создает новый ("внутренний") поток (например, HTTP-запрос) и переключает подписку на него. **Ключевая особенность:** отменяет предыдущий внутренний поток.
*   `catchError` - перехватывает ошибку во внутреннем потоке и позволяет вернуть новый поток.

---

#### **5. Субъекты (Subjects)**

*   **`Subject`:** Мультикаст-поток. Все подписчики получают одни и те же данные, начиная с момента подписки.
    ```typescript
    const subject = new Subject<string>();

    subject.subscribe(value => console.log('Подписчик A:', value));
    subject.next('Hello'); // Подписчик A: Hello

    subject.subscribe(value => console.log('Подписчик B:', value));
    subject.next('World'); // Подписчик A: World, Подписчик B: World
    ```

*   **`BehaviorSubject`:** Хранит текущее значение. Новые подписчики сразу получают последнее emitted значение.
    ```typescript
    // Идеально для хранения "состояния" (например, данные пользователя)
    const userState = new BehaviorSubject<{name: string} | null>(null);

    // Где-то при логине:
    userState.next({ name: 'Alice' });

    // В компоненте, даже если подпишемся позже:
    userState.subscribe(user => console.log(user)); // Сразу получит {name: 'Alice'}
    ```

*   **`ReplaySubject`:** Запоминает и воспроизводит несколько предыдущих значений для новых подписчиков.

---

#### **6. Интеграция RxJs с Angular**

*   **Async Pipe:** Автоматически подписывается и отписывается в шаблоне.
    ```typescript
    // component.ts
    export class UserListComponent {
      users$: Observable<User[]>;

      constructor(private userService: UserService) {
        this.users$ = this.userService.getUsers();
      }
    }
    ```
    ```html
    <!-- component.html -->
    <ul>
      <li *ngFor="let user of users$ | async">{{ user.name }}</li>
    </ul>
    ```
    **Больше не нужно manually unsubscribe!**

*   **HTTP-клиент:**
    ```typescript
    // service.ts
    getUsers(): Observable<User[]> {
      return this.http.get<User[]>('/api/users').pipe(
        catchError(this.handleError)
      );
    }
    ```

*   **Реактивные формы:**
    ```typescript
    searchForm = new FormGroup({
      searchTerm: new FormControl('')
    });

    ngOnInit() {
      this.searchForm.get('searchTerm')!.valueChanges.pipe(
        debounceTime(300),
        distinctUntilChanged(),
        switchMap(term => this.searchService.search(term))
      ).subscribe(results => this.results = results);
    }
    ```

---

#### **7. Паттерны и лучшие практики**

*   **Отписка:**
    *   **Плохо:** Подписка в `ngOnInit` без отписки в `ngOnDestroy` -> утечка памяти.
    *   **Хорошо:** Использование `AsyncPipe` в шаблоне.
    *   **Хорошо (для ручных подписок):** Использование `takeUntil`:
    ```typescript
    private destroy$ = new Subject<void>();

    ngOnInit() {
      this.someStream$.pipe(
        takeUntil(this.destroy$)
      ).subscribe(/* ... */);
    }

    ngOnDestroy() {
      this.destroy$.next();
      this.destroy$.complete();
    }
    ```

*   **Избегайте "подписки внутри подписки" (Nested Subscription):**
    ```typescript
    // ПЛОХО
    this.userId$.subscribe(id => {
      this.getUserDetails(id).subscribe(details => { // Вложенная подписка
        // ...
      });
    });

    // ХОРОШО (используйте операторы преобразования)
    this.userDetails$ = this.userId$.pipe(
      switchMap(id => this.getUserDetails(id))
    );
    ```

---

### **Резюме**

*   **RxJs** — это мощная библиотека для управления асинхронными операциями и событиями как потоками данных.
*   **Observable** представляет поток, **Observer** его обрабатывает, а **Subscription** управляет исполнением.
*   **Операторы** (внутри `pipe()`) — это инструменты для преобразования, фильтрации и комбинирования потоков. `switchMap`, `debounceTime`, `catchError` — одни из самых важных.
*   **Subjects** используются для мультикастинга и часто служат "реактивным состояниям" в сервисах.
*   В **Angular** используйте `AsyncPipe` везде, где возможно, чтобы избежать ручного управления подписками.
*   Всегда помните об **отписке** от Observable, кроме случаев с `AsyncPipe`.

---

### **Контрольные вопросы:**

1.  В чем основное концептуальное отличие `Observable` от `Promise`?
2.  Что произойдет, если не отписаться от `interval()`? Как можно избежать утечки памяти?
3.  Объясните разницу между операторами `switchMap`, `mergeMap` и `concatMap`. В каком сценарии `switchMap` является идеальным выбором?
4.  Какой Subject вы бы использовали для хранения текущего авторизованного пользователя в сервисе? Объясните, почему.
5.  У вас есть текстовое поле для поиска. Опишите, с помощью каких операторов RxJs вы бы реализовали логику, чтобы минимизировать количество запросов к серверу и избежать дублирующих запросов.
6.  Как работает `AsyncPipe` и почему его использование считается "best practice"?
7.  Что делает оператор `distinctUntilChanged()` и в чем его практическая польза?
8.  Как бы вы обработали ошибку в HTTP-запросе, используя RxJs, чтобы приложение не "сломалось"?