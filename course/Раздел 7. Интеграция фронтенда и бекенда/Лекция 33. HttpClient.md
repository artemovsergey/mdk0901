# Лекция. HttpClient в Angular: Эффективная работа с REST API

**Целевая аудитория:** Студенты, знакомые с основами Angular (компоненты, сервисы, модули) и TypeScript.

**Цель:** Научиться использовать HttpClient для выполнения HTTP-запросов, обрабатывать ответы, ошибки и применять лучшие практики в реальных Angular-приложениях.

---

### **План лекции:**

1.  **Введение: Зачем нужен HttpClient?**
    *   Эволюция от XMLHttpRequest к Fetch API и HttpClient.
    *   Преимущества HttpClient: типизация, интерсепторы, тестирование.

2.  **Настройка и базовое использование**
    *   Импорт `HttpClientModule`.
    *   Инжектирование `HttpClient` в сервис.
    *   Первый GET-запрос.

3.  **Типы HTTP-запросов (CRUD)**
    *   GET: Получение данных.
    *   POST: Создание новых данных.
    *   PUT/PATCH: Обновление данных.
    *   DELETE: Удаление данных.

4.  **Типизация и обработка ответов**
    *   Использование дженериков для типизации ответов.
    *   Обработка различных типов данных: JSON, текст, blob.
    *   Парсинг ответов.

5.  **Обработка ошибок**
    *   Использование оператора `catchError` из RxJs.
    *   Классификация ошибок (клиентские, серверные, сетевые).
    *   Создание универсального обработчика ошибок.

6.  **Параметры запроса**
    *   `HttpParams`: Добавление query-параметров.
    *   `HttpHeaders`: Установка заголовков запроса.

7.  **Интерсепторы (Interceptors)**
    *   Что такое интерсептор и для чего он нужен?
    *   Практические примеры: добавление токена авторизации, логирование, глобальная обработка ошибок.

8.  **Прогресс загрузки**
    *   Отслеживание прогресса загрузки файлов.

9.  **Лучшие практики и паттерны**
    *   Вынесение HTTP-логики в сервисы.
    *   Использование `AsyncPipe` в компонентах.
    *   Отписка от запросов.
    * * *Обработка состояний загрузки и ошибок в UI.

---

### **Детальное рассмотрение пунктов плана:**

#### **1. Введение: Зачем нужен HttpClient?**

**Проблема:** Раньше для HTTP-запросов использовали:
*   `XMLHttpRequest` (громоздкий, callback-based API)
*   `fetch()` (более современный, но требует ручного преобразования JSON, lacks interceptors)

**Решение:** Angular `HttpClient` — это мощная, удобная обертка для работы с HTTP, которая предоставляет:
*   **Типизацию** всех запросов и ответов через TypeScript дженерики.
*   **Интерсепторы** для глобальной обработки запросов/ответов.
*   **Тестируемость** через `HttpClientTestingModule`.
*   **Упрощенный API** для всех CRUD операций.

---

#### **2. Настройка и базовое использование**

**Шаг 1: Импорт модуля**
```typescript
// app.module.ts
import { HttpClientModule } from '@angular/common/http';

@NgModule({
  imports: [
    HttpClientModule // ← Добавляем модуль
  ],
  // ...
})
export class AppModule { }
```

**Шаг 2: Создание сервиса и инжектирование HttpClient**
```typescript
// user.service.ts
import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';

@Injectable({ providedIn: 'root' })
export class UserService {
  
  private apiUrl = 'https://api.example.com/users';
  
  constructor(private http: HttpClient) { } // ← Инжектируем HttpClient

  // Базовый GET-запрос
  getUsers() {
    return this.http.get(this.apiUrl);
  }
}
```

**Шаг 3: Использование в компоненте**
```typescript
// user-list.component.ts
export class UserListComponent implements OnInit {
  users: any[] = [];

  constructor(private userService: UserService) {}

  ngOnInit() {
    this.userService.getUsers().subscribe({
      next: (data) => {
        this.users = data;
      },
      error: (error) => {
        console.error('Ошибка загрузки пользователей:', error);
      }
    });
  }
}
```

---

#### **3. Типы HTTP-запросов (CRUD)**

```typescript
// user.service.ts
export class UserService {
  private apiUrl = 'https://api.example.com/users';

  constructor(private http: HttpClient) {}

  // GET - получение всех пользователей
  getUsers() {
    return this.http.get<any[]>(this.apiUrl);
  }

  // GET - получение одного пользователя по ID
  getUserById(id: number) {
    return this.http.get<any>(`${this.apiUrl}/${id}`);
  }

  // POST - создание нового пользователя
  createUser(userData: { name: string; email: string }) {
    return this.http.post<any>(this.apiUrl, userData);
  }

  // PUT - полное обновление пользователя
  updateUser(id: number, userData: any) {
    return this.http.put<any>(`${this.apiUrl}/${id}`, userData);
  }

  // PATCH - частичное обновление пользователя
  patchUser(id: number, partialData: any) {
    return this.http.patch<any>(`${this.apiUrl}/${id}`, partialData);
  }

  // DELETE - удаление пользователя
  deleteUser(id: number) {
    return this.http.delete<void>(`${this.apiUrl}/${id}`);
  }
}
```

**Пример использования в компоненте:**
```typescript
// user-form.component.ts
export class UserFormComponent {
  constructor(private userService: UserService) {}

  onCreateUser(userData: any) {
    this.userService.createUser(userData).subscribe({
      next: (newUser) => {
        console.log('Пользователь создан:', newUser);
        // Обновляем UI или перенаправляем
      },
      error: (error) => {
        console.error('Ошибка создания:', error);
      }
    });
  }

  onDeleteUser(userId: number) {
    if (confirm('Вы уверены?')) {
      this.userService.deleteUser(userId).subscribe({
        next: () => {
          console.log('Пользователь удален');
          // Удаляем из локального массива
          this.users = this.users.filter(user => user.id !== userId);
        },
        error: (error) => {
          console.error('Ошибка удаления:', error);
        }
      });
    }
  }
}
```

---

#### **4. Типизация и обработка ответов**

**Сильная типизация:**
```typescript
// models/user.model.ts
export interface User {
  id: number;
  name: string;
  email: string;
  createdAt: Date;
}

// user.service.ts
export class UserService {
  // Указываем тип возвращаемых данных
  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }

  getUserById(id: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${id}`);
  }

  createUser(userData: Omit<User, 'id' | 'createdAt'>): Observable<User> {
    return this.http.post<User>(this.apiUrl, userData);
  }
}
```

**Работа с различными типами ответов:**
```typescript
// Получение текстового ответа
getPlainText(): Observable<string> {
  return this.http.get('api/status', { responseType: 'text' });
}

// Скачивание файла
downloadFile(): Observable<Blob> {
  return this.http.get('api/report', { 
    responseType: 'blob' 
  });
}

// Получение заголовков ответа
getWithHeaders(): Observable<any> {
  return this.http.get('api/data', { observe: 'response' });
}
```

---

#### **5. Обработка ошибок**

**Базовая обработка с catchError:**
```typescript
import { catchError } from 'rxjs/operators';
import { throwError } from 'rxjs';

// user.service.ts
getUsers(): Observable<User[]> {
  return this.http.get<User[]>(this.apiUrl).pipe(
    catchError((error: HttpErrorResponse) => {
      console.error('HTTP Error:', error);
      
      let errorMessage = 'Произошла ошибка';
      if (error.error instanceof ErrorEvent) {
        // Клиентская ошибка
        errorMessage = `Ошибка: ${error.error.message}`;
      } else {
        // Серверная ошибка
        errorMessage = `Код ошибки: ${error.status}\nСообщение: ${error.message}`;
      }
      
      // Пробрасываем ошибку дальше
      return throwError(() => new Error(errorMessage));
    })
  );
}
```

**Универсальный обработчик ошибок:**
```typescript
// error-handler.service.ts
@Injectable({ providedIn: 'root' })
export class ErrorHandlerService {
  
  handleError(error: HttpErrorResponse) {
    let userMessage = 'Произошла непредвиденная ошибка';
    
    switch (error.status) {
      case 0:
        userMessage = 'Отсутствует подключение к интернету';
        break;
      case 404:
        userMessage = 'Ресурс не найден';
        break;
      case 500:
        userMessage = 'Ошибка на сервере';
        break;
      case 401:
        userMessage = 'Неавторизованный доступ';
        // Можно перенаправить на страницу логина
        break;
    }
    
    // Можно показать уведомление пользователю
    console.error('Обработанная ошибка:', userMessage);
    
    return throwError(() => new Error(userMessage));
  }
}

// Использование в сервисе
getUsers(): Observable<User[]> {
  return this.http.get<User[]>(this.apiUrl).pipe(
    catchError(this.errorHandler.handleError.bind(this.errorHandler))
  );
}
```

---

#### **6. Параметры запроса**

**Добавление query-параметров:**
```typescript
// Поиск пользователей с фильтрацией
searchUsers(filters: { name?: string; email?: string; page?: number }): Observable<User[]> {
  let params = new HttpParams();
  
  if (filters.name) {
    params = params.append('name_like', filters.name);
  }
  
  if (filters.email) {
    params = params.append('email_like', filters.email);
  }
  
  if (filters.page) {
    params = params.append('_page', filters.page.toString());
    params = params.append('_limit', '10'); // Пагинация
  }
  
  return this.http.get<User[]>(this.apiUrl, { params });
}
```

**Установка заголовков:**
```typescript
// Установка заголовков для конкретного запроса
createUserWithAuth(userData: any): Observable<User> {
  const headers = new HttpHeaders()
    .set('Authorization', 'Bearer ' + this.authToken)
    .set('Content-Type', 'application/json')
    .set('X-Custom-Header', 'custom-value');

  return this.http.post<User>(this.apiUrl, userData, { headers });
}

// Или более компактно:
createUserWithAuth(userData: any): Observable<User> {
  return this.http.post<User>(this.apiUrl, userData, {
    headers: {
      'Authorization': `Bearer ${this.authToken}`,
      'X-Custom-Header': 'custom-value'
    }
  });
}
```

---

#### **7. Интерсепторы (Interceptors)**

**Интерсептор для добавления токена авторизации:**
```typescript
// auth.interceptor.ts
import { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable()
export class AuthInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    // Клонируем запрос и добавляем заголовок
    const authToken = localStorage.getItem('auth_token');
    
    if (authToken) {
      const authReq = req.clone({
        headers: req.headers.set('Authorization', `Bearer ${authToken}`)
      });
      return next.handle(authReq);
    }
    
    return next.handle(req);
  }
}
```

**Интерсептор для логирования:**
```typescript
// logging.interceptor.ts
export class LoggingInterceptor implements HttpInterceptor {
  
  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {
    const startTime = Date.now();
    
    return next.handle(req).pipe(
      tap(event => {
        if (event instanceof HttpResponse) {
          const duration = Date.now() - startTime;
          console.log(`${req.method} ${req.url} - ${event.status} (${duration}ms)`);
        }
      })
    );
  }
}
```

**Регистрация интерсепторов:**
```typescript
// app.module.ts
@NgModule({
  providers: [
    { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
    { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true }
  ]
})
export class AppModule { }
```

---

#### **8. Прогресс загрузки**

```typescript
// file-upload.service.ts
uploadFile(file: File): Observable<HttpEvent<any>> {
  const formData = new FormData();
  formData.append('file', file);

  return this.http.post('api/upload', formData, {
    reportProgress: true,
    observe: 'events'
  }).pipe(
    tap(event => {
      if (event.type === HttpEventType.UploadProgress && event.total) {
        const progress = Math.round(100 * event.loaded / event.total);
        console.log(`Прогресс загрузки: ${progress}%`);
        // Можно эмитировать прогресс через Subject или BehaviorSubject
      } else if (event.type === HttpEventType.Response) {
        console.log('Файл успешно загружен!');
      }
    })
  );
}
```

---

#### **9. Лучшие практики и паттерны**

**1. Сервисы для HTTP-логики:**
```typescript
// Хорошо: вся HTTP-логика в сервисе
export class DataService {
  getData(): Observable<Data[]> {
    return this.http.get<Data[]>('/api/data');
  }
}

// Плохо: HTTP-запросы прямо в компоненте
export class MyComponent {
  constructor(private http: HttpClient) {} // ← Не делайте так!
  
  ngOnInit() {
    this.http.get('/api/data').subscribe(); // ← Очень плохо!
  }
}
```

**2. Использование AsyncPipe:**
```typescript
// component.ts
export class UserListComponent {
  users$: Observable<User[]>;
  isLoading$ = new BehaviorSubject<boolean>(true);

  constructor(private userService: UserService) {
    this.users$ = this.userService.getUsers().pipe(
      tap(() => this.isLoading$.next(false)),
      catchError(error => {
        this.isLoading$.next(false);
        return throwError(() => error);
      })
    );
  }
}
```

```html
<!-- component.html -->
<div *ngIf="isLoading$ | async" class="loading">Загрузка...</div>

<div *ngIf="users$ | async as users">
  <div *ngFor="let user of users">{{ user.name }}</div>
</div>

<div *ngIf="error$ | async as error" class="error">
  {{ error }}
</div>
```

**3. Управление состоянием загрузки и ошибок:**
```typescript
export class UserListComponent {
  users: User[] = [];
  isLoading = false;
  error: string | null = null;

  loadUsers() {
    this.isLoading = true;
    this.error = null;
    
    this.userService.getUsers().subscribe({
      next: (users) => {
        this.users = users;
        this.isLoading = false;
      },
      error: (error) => {
        this.error = error.message;
        this.isLoading = false;
      }
    });
  }
}
```

---

### **Резюме**

*   **HttpClient** — это мощный, типизированный инструмент для работы с HTTP в Angular.
*   Всегда выносите HTTP-логику в **сервисы**.
*   Используйте **типизацию** для повышения надежности кода.
*   Обрабатывайте **ошибки** с помощью `catchError`.
*   Используйте **интерсепторы** для глобальной логики (аутентификация, логирование).
*   Предпочитайте **AsyncPipe** для автоматической отписки.
*   Всегда обрабатывайте **состояния загрузки и ошибок** в UI.

---

### **Контрольные вопросы:**

1.  Как импортировать и настроить HttpClientModule в Angular приложении?
2.  В чем разница между методами PUT и PATCH? Когда какой использовать?
3.  Как добавить query-параметры к GET-запросу с помощью HttpParams?
4.  Как обработать ошибку 404 в HTTP-запросе и показать пользователю понятное сообщение?
5.  Что такое HTTP-интерсепторы и для каких задач они используются?
6.  Как отслеживать прогресс загрузки файла?
7.  Почему рекомендуется использовать AsyncPipe вместо ручной подписки в компонентах?
8.  Как добавить заголовок Authorization ко всем исходящим запросам?
9.  Какие преимущества дает типизация HTTP-запросов с помощью TypeScript дженериков?
10. Как организовать отписку от HTTP-запросов при уничтожении компонента?