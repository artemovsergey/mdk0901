# Лекция. `@Input` и `@Output` - Взаимодействие между компонентами

**Цель лекции:** Научиться передавать данные от родительского компонента к дочернему через `@Input` и обрабатывать события от дочернего компонента в родительском через `@Output`. Понять принципы однонаправленного потока данных.

---

### **План лекции:**

1.  **Введение: Коммуникация между компонентами**
    *   Проблема изолированности компонентов.
    *   Однонаправленный поток данных.
    *   Родительские и дочерние компоненты.

2.  **`@Input()` - Передача данных "сверху вниз"**
    *   Синтаксис и базовое использование.
    *   Input-ы с сигналами.
    *   Изменение Input-ов и жизненный цикл.
    *   Обязательные Input-ы.

3.  **`@Output()` - Отправка событий "снизу вверх"**
    *   Синтаксис и `EventEmitter`.
    *   Передача данных с событиями.
    *   `EventEmitter` с сигналами.

4.  **Практические паттерны**
    *   Компонент-контейнер и презентационные компоненты.
    *   Списки и детали.
    *   Формы и модальные окна.

5.  **Полный пример: Приложение списка пользователей**
    *   Создание компонента пользователя.
    *   Взаимодействие между компонентами.

---

### **Детальное рассмотрение каждого пункта плана:**

#### **1. Введение: Коммуникация между компонентами**

**Проблема изолированности компонентов:**
Каждый компонент в Angular изолирован. Это хорошо для переиспользования, но создает проблему: как компоненты могут общаться друг с другом?

**Однонаправленный поток данных:**
Angular использует архитектуру однонаправленного потока данных:
- **Данные вниз** - через `@Input()`
- **События вверх** - через `@Output()`

**Родительские и дочерние компоненты:**
```html
<!-- Родительский компонент -->
<app-parent>
  <!-- Дочерние компоненты -->
  <app-child [inputData]="data" (outputEvent)="handleEvent($event)"></app-child>
  <app-user-card [user]="currentUser" (userSelected)="onUserSelect($event)"></app-user-card>
</app-parent>
```

---

#### **2. `@Input()` - Передача данных "сверху вниз"**

**Синтаксис и базовое использование:**
```typescript
// child.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-user-card',
  template: `
    <div class="user-card">
      <h3>{{ userName }}</h3>
      <p>Email: {{ email }}</p>
      <p>Возраст: {{ age }}</p>
      <p>Статус: {{ isActive ? 'Активен' : 'Неактивен' }}</p>
    </div>
  `
})
export class UserCardComponent {
  @Input() userName: string = ''; // Input со значением по умолчанию
  @Input() email: string = '';
  @Input() age: number = 0;
  @Input() isActive: boolean = false;
}
```

```typescript
// parent.component.ts
@Component({
  selector: 'app-parent',
  template: `
    <h2>Список пользователей</h2>
    <app-user-card 
      [userName]="currentUser.name"
      [email]="currentUser.email"
      [age]="currentUser.age"
      [isActive]="currentUser.isActive">
    </app-user-card>
  `
})
export class ParentComponent {
  currentUser = {
    name: 'Иван Петров',
    email: 'ivan@example.com',
    age: 30,
    isActive: true
  };
}
```

**Более удобный подход - передача объекта:**
```typescript
// child.component.ts
export class UserCardComponent {
  @Input() user: User = {} as User; // Передача целого объекта
}

interface User {
  id: number;
  name: string;
  email: string;
  age: number;
  isActive: boolean;
}
```

```html
<!-- parent.component.html -->
<app-user-card [user]="currentUser"></app-user-card>
```

**Input-ы с сигналами (Angular 16+):**
```typescript
// child.component.ts
import { Component, input } from '@angular/core';

@Component({
  selector: 'app-user-card',
  template: `
    <div class="user-card">
      <h3>{{ userName() }}</h3>
      <p>Email: {{ email() }}</p>
      <p>Роль: {{ role() }}</p>
    </div>
  `
})
export class UserCardComponent {
  // Input-сигналы
  userName = input.required<string>(); // Обязательный параметр
  email = input<string>(''); // Необязательный с значением по умолчанию
  role = input<'user' | 'admin'>('user'); // Input с ограниченными значениями
}
```

```html
<!-- parent.component.html -->
<app-user-card 
  [userName]="currentUser.name"
  [email]="currentUser.email"
  [role]="'admin'">
</app-user-card>
```

**Изменение Input-ов и жизненный цикл:**
```typescript
import { Component, Input, OnChanges, SimpleChanges, OnInit } from '@angular/core';

@Component({
  selector: 'app-user-profile',
  template: `...`
})
export class UserProfileComponent implements OnChanges, OnInit {
  @Input() user: User = {} as User;
  @Input() isLoading: boolean = false;

  // Отслеживание изменений Input-ов
  ngOnChanges(changes: SimpleChanges) {
    console.log('Изменения в Inputs:', changes);
    
    if (changes['user']) {
      console.log('Пользователь изменился:', changes['user'].currentValue);
      console.log('Предыдущее значение:', changes['user'].previousValue);
    }
    
    if (changes['isLoading'] && !changes['isLoading'].firstChange) {
      console.log('Статус загрузки изменился:', this.isLoading);
    }
  }

  ngOnInit() {
    console.log('Компонент инициализирован с пользователем:', this.user);
  }
}
```

**Обязательные Input-ы:**
```typescript
// Традиционный подход
export class TraditionalComponent {
  @Input({ required: true }) mandatoryInput!: string;
  @Input() optionalInput?: string;
}

// С сигналами (рекомендуется)
export class SignalComponent {
  mandatoryInput = input.required<string>();
  optionalInput = input<string>('default value');
}
```

---

#### **3. `@Output()` - Отправка событий "снизу вверх"**

**Синтаксис и `EventEmitter`:**
```typescript
// child.component.ts
import { Component, Output, EventEmitter } from '@angular/core';

@Component({
  selector: 'app-button',
  template: `
    <button (click)="onClick()" [disabled]="isDisabled">
      {{ buttonText }}
    </button>
  `
})
export class ButtonComponent {
  @Input() buttonText: string = 'Нажми меня';
  @Input() isDisabled: boolean = false;
  
  // Создание Output события
  @Output() buttonClick = new EventEmitter<void>();
  
  onClick() {
    if (!this.isDisabled) {
      this.buttonClick.emit(); // Отправка события
    }
  }
}
```

```html
<!-- parent.component.html -->
<app-button 
  buttonText="Сохранить"
  [isDisabled]="isSaving"
  (buttonClick)="onSave()">
</app-button>
```

**Передача данных с событиями:**
```typescript
// child.component.ts - компонент поиска
@Component({
  selector: 'app-search-box',
  template: `
    <div class="search-box">
      <input 
        type="text" 
        [placeholder]="placeholder"
        [value]="searchText"
        (input)="onInputChange($event)"
      >
      <button (click)="onClear()">×</button>
    </div>
  `
})
export class SearchBoxComponent {
  @Input() placeholder: string = 'Поиск...';
  @Input() searchText: string = '';
  
  // Output с передачей данных
  @Output() searchChange = new EventEmitter<string>();
  @Output() searchClear = new EventEmitter<void>();

  onInputChange(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.searchChange.emit(value); // Передача строки поиска
  }

  onClear() {
    this.searchText = '';
    this.searchClear.emit();
  }
}
```

```typescript
// parent.component.ts
export class ParentComponent {
  searchQuery: string = '';
  users: User[] = [];
  filteredUsers: User[] = [];

  onSearchChange(query: string) {
    this.searchQuery = query;
    this.filteredUsers = this.users.filter(user =>
      user.name.toLowerCase().includes(query.toLowerCase())
    );
  }

  onSearchClear() {
    this.searchQuery = '';
    this.filteredUsers = this.users;
  }
}
```

```html
<!-- parent.component.html -->
<app-search-box
  placeholder="Поиск пользователей..."
  [searchText]="searchQuery"
  (searchChange)="onSearchChange($event)"
  (searchClear)="onSearchClear()">
</app-search-box>
```

**`EventEmitter` с сигналами:**
```typescript
// child.component.ts с сигналами
import { Component, output, input } from '@angular/core';

@Component({
  selector: 'app-rating',
  template: `
    <div class="rating">
      @for (star of [1,2,3,4,5]; track star) {
        <span 
          class="star"
          [class.active]="star <= currentRating()"
          (click)="setRating(star)">
          ★
        </span>
      }
    </div>
    <p>Текущая оценка: {{ currentRating() }} из 5</p>
  `
})
export class RatingComponent {
  // Input-сигналы
  currentRating = input(0);
  
  // Output-сигналы
  ratingChange = output<number>(); // Output с передачей числа

  setRating(rating: number) {
    this.ratingChange.emit(rating);
  }
}
```

```html
<!-- parent.component.html -->
<app-rating 
  [currentRating]="userRating"
  (ratingChange)="onRatingChange($event)">
</app-rating>
<p>Пользователь оценил на: {{ userRating }} звезд</p>
```

---

#### **4. Практические паттерны**

**Компонент-контейнер и презентационные компоненты:**
```typescript
// Контейнер (умный компонент)
@Component({
  selector: 'app-user-list-container',
  template: `
    <div class="container">
      <h2>Управление пользователями</h2>
      
      <app-user-search
        (search)="onSearch($event)">
      </app-user-search>
      
      <app-user-list
        [users]="filteredUsers()"
        [isLoading]="isLoading()"
        (userSelected)="onUserSelect($event)"
        (userDeleted)="onUserDelete($event)">
      </app-user-list>
      
      <app-pagination
        [currentPage]="currentPage()"
        [totalPages]="totalPages()"
        (pageChange)="onPageChange($event)">
      </app-pagination>
    </div>
  `
})
export class UserListContainer {
  // Логика и состояние
  users = signal<User[]>([]);
  filteredUsers = computed(() => this.users());
  isLoading = signal(false);
  currentPage = signal(1);
  totalPages = signal(1);
  
  // Обработчики событий от дочерних компонентов
  onSearch(query: string) { /* логика поиска */ }
  onUserSelect(user: User) { /* логика выбора */ }
  onUserDelete(userId: number) { /* логика удаления */ }
  onPageChange(page: number) { /* логика пагинации */ }
}
```

**Компонент списка с действиями:**
```typescript
// presentation-user-list.component.ts
@Component({
  selector: 'app-user-list',
  template: `
    <div class="user-list">
      @if (isLoading()) {
        <app-loading-spinner></app-loading-spinner>
      } @else {
        @for (user of users(); track user.id) {
          <div class="user-item">
            <span>{{ user.name }}</span>
            <span>{{ user.email }}</span>
            <div class="actions">
              <button (click)="onEdit(user)">✏️</button>
              <button (click)="onDelete(user.id)">🗑️</button>
              <button (click)="onView(user)">👁️</button>
            </div>
          </div>
        } @empty {
          <p>Пользователи не найдены</p>
        }
      }
    </div>
  `
})
export class UserListComponent {
  users = input.required<User[]>();
  isLoading = input.required<boolean>();
  
  userSelected = output<User>();
  userEdited = output<User>();
  userDeleted = output<number>();
  
  onEdit(user: User) {
    this.userEdited.emit(user);
  }
  
  onDelete(userId: number) {
    this.userDeleted.emit(userId);
  }
  
  onView(user: User) {
    this.userSelected.emit(user);
  }
}
```

---

#### **5. Полный пример: Приложение списка пользователей**

**Дочерний компонент - карточка пользователя:**
```typescript
// user-card.component.ts
import { Component, input, output } from '@angular/core';

export interface User {
  id: number;
  name: string;
  email: string;
  avatar: string;
  department: string;
  isOnline: boolean;
}

@Component({
  selector: 'app-user-card',
  template: `
    <div class="user-card" [class.online]="user().isOnline">
      <div class="user-avatar">
        <img [src]="user().avatar" [alt]="user().name">
        <div class="status-indicator" [class.online]="user().isOnline"></div>
      </div>
      
      <div class="user-info">
        <h3>{{ user().name }}</h3>
        <p class="email">{{ user().email }}</p>
        <p class="department">{{ user().department }}</p>
      </div>
      
      <div class="user-actions">
        <button 
          class="btn-primary"
          (click)="onSendMessage.emit(user().id)">
          💬 Написать
        </button>
        <button 
          class="btn-secondary"
          (click)="onViewProfile.emit(user())">
          👁️ Профиль
        </button>
        <button 
          class="btn-danger"
          (click)="onDelete.emit(user().id)">
          🗑️ Удалить
        </button>
      </div>
    </div>
  `,
  styleUrls: ['./user-card.component.css']
})
export class UserCardComponent {
  // Inputs
  user = input.required<User>();
  showDeleteButton = input(true);
  
  // Outputs
  onSendMessage = output<number>();
  onViewProfile = output<User>();
  onDelete = output<number>();
}
```

**Родительский компонент - список пользователей:**
```typescript
// user-list-page.component.ts
import { Component, signal, inject } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-user-list-page',
  template: `
    <div class="user-list-page">
      <header class="page-header">
        <h1>Список пользователей</h1>
        <p>Всего пользователей: {{ users().length }}</p>
      </header>

      <div class="filters">
        <app-search-box
          placeholder="Поиск по имени или email..."
          (searchChange)="onSearch($event)">
        </app-search-box>
        
        <app-department-filter
          [departments]="departments()"
          (departmentChange)="onDepartmentFilter($event)">
        </app-department-filter>
      </div>

      <div class="user-grid">
        @for (user of filteredUsers(); track user.id) {
          <app-user-card
            [user]="user"
            [showDeleteButton]="currentUser().role === 'admin'"
            (onSendMessage)="onSendMessage($event)"
            (onViewProfile)="onViewProfile($event)"
            (onDelete)="onDeleteUser($event)">
          </app-user-card>
        } @empty {
          <div class="empty-state">
            <p>😔 Пользователи не найдены</p>
            <button (click)="resetFilters()">Сбросить фильтры</button>
          </div>
        }
      </div>

      <!-- Модальное окно подтверждения удаления -->
      @if (showDeleteModal()) {
        <app-confirm-modal
          title="Удаление пользователя"
          message="Вы уверены, что хотите удалить этого пользователя?"
          (confirm)="confirmDelete()"
          (cancel)="cancelDelete()">
        </app-confirm-modal>
      }
    </div>
  `
})
export class UserListPageComponent {
  // Состояние компонента
  users = signal<User[]>([]);
  filteredUsers = signal<User[]>([]);
  searchQuery = signal('');
  selectedDepartment = signal<string>('all');
  showDeleteModal = signal(false);
  userToDelete = signal<number | null>(null);
  
  currentUser = signal({
    id: 1,
    name: 'Администратор',
    role: 'admin'
  });

  departments = signal(['IT', 'HR', 'Marketing', 'Sales', 'Finance']);

  constructor() {
    // Загрузка тестовых данных
    this.loadUsers();
  }

  loadUsers() {
    const mockUsers: User[] = [
      {
        id: 1,
        name: 'Анна Иванова',
        email: 'anna@company.com',
        avatar: '/assets/avatars/anna.jpg',
        department: 'IT',
        isOnline: true
      },
      {
        id: 2,
        name: 'Петр Сидоров',
        email: 'petr@company.com',
        avatar: '/assets/avatars/petr.jpg',
        department: 'HR',
        isOnline: false
      },
      {
        id: 3,
        name: 'Мария Козлова',
        email: 'maria@company.com',
        avatar: '/assets/avatars/maria.jpg',
        department: 'Marketing',
        isOnline: true
      }
    ];
    
    this.users.set(mockUsers);
    this.filteredUsers.set(mockUsers);
  }

  // Обработчики событий от дочерних компонентов
  onSearch(query: string) {
    this.searchQuery.set(query);
    this.applyFilters();
  }

  onDepartmentFilter(department: string) {
    this.selectedDepartment.set(department);
    this.applyFilters();
  }

  onSendMessage(userId: number) {
    console.log('Отправка сообщения пользователю:', userId);
    // Навигация к чату или открытие модального окна
  }

  onViewProfile(user: User) {
    console.log('Просмотр профиля:', user);
    // Навигация к странице профиля
  }

  onDeleteUser(userId: number) {
    this.userToDelete.set(userId);
    this.showDeleteModal.set(true);
  }

  confirmDelete() {
    const userId = this.userToDelete();
    if (userId) {
      this.users.update(users => users.filter(u => u.id !== userId));
      this.applyFilters();
    }
    this.showDeleteModal.set(false);
    this.userToDelete.set(null);
  }

  cancelDelete() {
    this.showDeleteModal.set(false);
    this.userToDelete.set(null);
  }

  resetFilters() {
    this.searchQuery.set('');
    this.selectedDepartment.set('all');
    this.filteredUsers.set(this.users());
  }

  // Применение фильтров
  private applyFilters() {
    let filtered = this.users();
    
    const query = this.searchQuery().toLowerCase();
    if (query) {
      filtered = filtered.filter(user =>
        user.name.toLowerCase().includes(query) ||
        user.email.toLowerCase().includes(query)
      );
    }
    
    const department = this.selectedDepartment();
    if (department !== 'all') {
      filtered = filtered.filter(user => user.department === department);
    }
    
    this.filteredUsers.set(filtered);
  }
}
```

**Дополнительные компоненты для примера:**
```typescript
// search-box.component.ts
@Component({
  selector: 'app-search-box',
  template: `
    <div class="search-box">
      <input
        type="text"
        [placeholder]="placeholder"
        (input)="onInput($event)"
        (keyup.enter)="onSearch()"
      >
      <button (click)="onSearch()">🔍</button>
      <button (click)="onClear()" *ngIf="currentValue">×</button>
    </div>
  `
})
export class SearchBoxComponent {
  @Input() placeholder: string = 'Поиск...';
  @Output() searchChange = new EventEmitter<string>();
  
  currentValue: string = '';

  onInput(event: Event) {
    this.currentValue = (event.target as HTMLInputElement).value;
  }

  onSearch() {
    this.searchChange.emit(this.currentValue);
  }

  onClear() {
    this.currentValue = '';
    this.searchChange.emit('');
  }
}
```

---

### **Резюме**

*   **`@Input()`** - передача данных от родителя к дочернему компоненту
*   **`@Output()`** - отправка событий от дочернего компонента к родителю
*   **Однонаправленный поток данных** - основа архитектуры Angular
*   **Сигналы** - современный способ работы с Input/Output (Angular 16+)
*   **`EventEmitter`** - для создания кастомных событий
*   **Паттерн "Контейнер-Презентация"** - разделение логики и отображения

**Ключевые принципы:**
- Родительский компонент управляет состоянием
- Дочерние компоненты получают данные через Input
- Дочерние компоненты сообщают о действиях через Output
- Минимизация прямого взаимодействия между компонентами

---

### **Контрольные вопросы:**

1.  В чем разница между традиционным `@Input()` и Input-сигналами?
2.  Как обработать изменение Input-параметра в дочернем компоненте?
3.  Что такое `EventEmitter` и когда его следует использовать?
4.  Как передать сложный объект через `@Input()`?
5.  Можно ли использовать несколько `@Output()` в одном компоненте?
6.  Как организовать коммуникацию между компонентами, которые не находятся в отношении родитель-потомок?
7.  В чем преимущества использования сигналов для Input/Output?
8.  Как сделать Input-параметр обязательным?
9.  Что произойдет, если родительский компонент не подпишется на Output-событие?
10. Как протестировать компонент с Input и Output параметрами?