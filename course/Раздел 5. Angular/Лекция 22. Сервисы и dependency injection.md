# Лекция. Сервисы и Dependency Injection в Angular

**Цель лекции:** Понять концепцию Dependency Injection (DI) в Angular, научиться создавать и использовать сервисы для разделения бизнес-логики и управления состоянием приложения.

---

### **План лекции:**

1.  **Введение: Зачем нужны сервисы и DI?**
    *   Проблемы без сервисов.
    *   Что такое Dependency Injection?
    *   Преимущества DI.

2.  **Создание и регистрация сервисов**
    *   Создание сервиса с помощью CLI.
    *   Декоратор `@Injectable()`.
    *   Провайдеры и уровни предоставления.

3.  **Dependency Injection в Angular**
    *   Иерархия инжекторов.
    *   Инжектирование сервисов в компоненты.
    *   `inject()` функция vs конструктор.

4.  **Паттерны использования сервисов**
    *   Сервисы для работы с данными.
    *   Сервисы-утилиты.
    *   Сервисы для управления состоянием.
    *   Синглтон vs не-синглтон сервисы.

5.  **Продвинутые темы DI**
    *   InjectionToken.
    *   Фабричные провайдеры.
    *   Optional dependencies.

6.  **Практика: Создание сервиса для работы с API**
    *   HTTP-сервис с обработкой ошибок.
    *   Сервис для управления состоянием приложения.

---

### **Детальное рассмотрение каждого пункта плана:**

#### **1. Введение: Зачем нужны сервисы и DI?**

**Проблемы без сервисов:**
```typescript
// ПЛОХО: Логика внутри компонента
@Component({
  template: `
    <div *ngFor="let user of users">
      {{ user.name }}
    </div>
  `
})
export class UserComponent {
  users: User[] = [];

  constructor(private http: HttpClient) {}

  ngOnInit() {
    // Проблемы:
    // 1. Нарушение Single Responsibility Principle
    // 2. Сложно тестировать
    // 3. Невозможно переиспользовать
    // 4. Загромождение компонента
    this.http.get<User[]>('/api/users').subscribe(users => {
      this.users = users;
    });
  }

  // Еще больше логики...
  sortUsers() { /* ... */ }
  filterUsers() { /* ... */ }
  calculateStats() { /* ... */ }
}
```

**Что такое Dependency Injection?**
DI - это паттерн проектирования, при котором зависимости не создаются внутри класса, а передаются извне (инжектируются).

**Преимущества DI:**
- ✅ **Разделение ответственности** - бизнес-логика в сервисах, UI-логика в компонентах
- ✅ **Переиспользование** - один сервис можно использовать в разных компонентах
- ✅ **Тестируемость** - легко мокировать зависимости в тестах
- ✅ **Поддерживаемость** - изменения в одном месте влияют на все использование
- ✅ **Гибкость** - легко менять реализации

---

#### **2. Создание и регистрация сервисов**

**Создание сервиса с помощью CLI:**
```bash
ng generate service services/user
# или короче:
ng g s services/user
```

**Базовый сервис:**
```typescript
// user.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root' // Автоматическая регистрация в корневом инжекторе
})
export class UserService {
  private apiUrl = 'api/users';

  constructor() { 
    console.log('UserService создан!');
  }

  getUsers(): User[] {
    return [
      { id: 1, name: 'Анна', email: 'anna@example.com' },
      { id: 2, name: 'Иван', email: 'ivan@example.com' }
    ];
  }
}
```

**Декоратор `@Injectable()`:**
- Указывает, что класс может иметь зависимости
- Без него Angular не сможет инжектировать зависимости в сервис
- Обязателен для сервисов, которые сами имеют зависимости

**Провайдеры и уровни предоставления:**
```typescript
// 1. providedIn: 'root' (рекомендуется) - синглтон на все приложение
@Injectable({
  providedIn: 'root'
})

// 2. providedIn: 'platform' - синглтон для всей платформы
@Injectable({
  providedIn: 'platform'
})

// 3. Регистрация в модуле
@NgModule({
  providers: [UserService] // Один экземпляр на весь модуль
})

// 4. Регистрация в компоненте
@Component({
  providers: [UserService] // Новый экземпляр для каждого компонента
})
```

---

#### **3. Dependency Injection в Angular**

**Иерархия инжекторов:**
```
Root Injector (providedIn: 'root')
│
├── AppModule Injector
│   │
│   └── AppComponent Injector
│       │
│       ├── HeaderComponent
│       │
│       └── UserListComponent Injector
│           │
│           └── UserComponent
```

**Инжектирование сервисов через конструктор:**
```typescript
// user-list.component.ts
import { Component, OnInit } from '@angular/core';
import { UserService } from '../services/user.service';

@Component({
  selector: 'app-user-list',
  template: `...`
})
export class UserListComponent implements OnInit {
  users: User[] = [];

  // Инжектирование сервиса через конструктор
  constructor(private userService: UserService) {}

  ngOnInit() {
    this.users = this.userService.getUsers();
  }
}
```

**Инжектирование через `inject()` функцию (Angular 14+):**
```typescript
// user-list.component.ts
import { Component, OnInit, inject } from '@angular/core';
import { UserService } from '../services/user.service';

@Component({
  selector: 'app-user-list',
  template: `...`
})
export class UserListComponent implements OnInit {
  users: User[] = [];
  
  // Альтернативный способ инжектирования
  private userService = inject(UserService);

  ngOnInit() {
    this.users = this.userService.getUsers();
  }
}
```

**Сравнение подходов:**
```typescript
// Через конструктор (классический)
export class ClassicComponent {
  constructor(
    private userService: UserService,
    private authService: AuthService,
    private logger: LoggerService
  ) {}
}

// Через inject() (современный)
export class ModernComponent {
  private userService = inject(UserService);
  private authService = inject(AuthService);
  private logger = inject(LoggerService);
  
  constructor() {
    // Легче наследование
    // Удобно в функциональном подходе
  }
}
```

---

#### **4. Паттерны использования сервисов**

**Сервис для работы с данными (HTTP):**
```typescript
// data.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';

export interface User {
  id: number;
  name: string;
  email: string;
  role: string;
}

@Injectable({
  providedIn: 'root'
})
export class DataService {
  private http = inject(HttpClient);
  private apiUrl = 'api';

  // GET все пользователи
  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(`${this.apiUrl}/users`).pipe(
      catchError(this.handleError)
    );
  }

  // GET пользователь по ID
  getUser(id: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/users/${id}`);
  }

  // POST создание пользователя
  createUser(user: Omit<User, 'id'>): Observable<User> {
    return this.http.post<User>(`${this.apiUrl}/users`, user);
  }

  // PUT обновление пользователя
  updateUser(user: User): Observable<User> {
    return this.http.put<User>(`${this.apiUrl}/users/${user.id}`, user);
  }

  // DELETE удаление пользователя
  deleteUser(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/users/${id}`);
  }

  private handleError(error: any) {
    console.error('Произошла ошибка:', error);
    return throwError(() => new Error('Ошибка загрузки данных'));
  }
}
```

**Сервис-утилита:**
```typescript
// utils.service.ts
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class UtilsService {
  // Форматирование даты
  formatDate(date: Date, format: string = 'ru-RU'): string {
    return new Intl.DateTimeFormat(format).format(date);
  }

  // Генерация случайного ID
  generateId(): string {
    return Math.random().toString(36).substr(2, 9);
  }

  // Глубокое клонирование
  deepClone<T>(obj: T): T {
    return JSON.parse(JSON.stringify(obj));
  }

  // Проверка на null/undefined
  isNullOrUndefined(value: any): boolean {
    return value === null || value === undefined;
  }

  // Дебаунс функция
  debounce(func: Function, wait: number): Function {
    let timeout: any;
    return function executedFunction(...args: any[]) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
}
```

**Сервис для управления состоянием с сигналами:**
```typescript
// app-state.service.ts
import { Injectable, signal, computed } from '@angular/core';
import { User } from '../models/user.model';

interface AppState {
  users: User[];
  currentUser: User | null;
  isLoading: boolean;
  error: string | null;
}

@Injectable({
  providedIn: 'root'
})
export class AppStateService {
  // Исходное состояние
  private initialState: AppState = {
    users: [],
    currentUser: null,
    isLoading: false,
    error: null
  };

  // Сигналы состояния
  private state = signal<AppState>(this.initialState);

  // Вычисляемые сигналы (геттеры)
  users = computed(() => this.state().users);
  currentUser = computed(() => this.state().currentUser);
  isLoading = computed(() => this.state().isLoading);
  error = computed(() => this.state().error);
  
  // Статистика
  userCount = computed(() => this.state().users.length);
  activeUsers = computed(() => 
    this.state().users.filter(user => user.isActive).length
  );

  // Методы для изменения состояния
  setLoading(loading: boolean) {
    this.state.update(state => ({ ...state, isLoading: loading }));
  }

  setUsers(users: User[]) {
    this.state.update(state => ({ ...state, users, error: null }));
  }

  setCurrentUser(user: User | null) {
    this.state.update(state => ({ ...state, currentUser: user }));
  }

  setError(error: string | null) {
    this.state.update(state => ({ ...state, error }));
  }

  addUser(user: User) {
    this.state.update(state => ({
      ...state,
      users: [...state.users, user]
    }));
  }

  updateUser(updatedUser: User) {
    this.state.update(state => ({
      ...state,
      users: state.users.map(user => 
        user.id === updatedUser.id ? updatedUser : user
      )
    }));
  }

  deleteUser(userId: number) {
    this.state.update(state => ({
      ...state,
      users: state.users.filter(user => user.id !== userId)
    }));
  }

  // Сброс состояния
  reset() {
    this.state.set(this.initialState);
  }
}
```

**Синглтон vs не-синглтон сервисы:**
```typescript
// Синглтон (один экземпляр на все приложение)
@Injectable({
  providedIn: 'root'
})
export class SingletonService {
  constructor() {
    console.log('SingletonService создан');
  }
}

// Не-синглтон (новый экземпляр для каждого компонента)
@Component({
  selector: 'app-user',
  providers: [UserService] // Новый экземпляр для каждого UserComponent
})
export class UserComponent {
  constructor(private userService: UserService) {}
}
```

---

#### **5. Продвинутые темы DI**

**InjectionToken для конфигурации:**
```typescript
// app-config.ts
import { InjectionToken } from '@angular/core';

export interface AppConfig {
  apiUrl: string;
  production: boolean;
  version: string;
  features: {
    auth: boolean;
    payments: boolean;
    analytics: boolean;
  };
}

export const APP_CONFIG = new InjectionToken<AppConfig>('app.config');

// Регистрация в модуле
@NgModule({
  providers: [
    {
      provide: APP_CONFIG,
      useValue: {
        apiUrl: 'https://api.myapp.com',
        production: false,
        version: '1.0.0',
        features: {
          auth: true,
          payments: false,
          analytics: true
        }
      }
    }
  ]
})
```

**Использование InjectionToken:**
```typescript
// config.service.ts
import { Injectable, inject } from '@angular/core';
import { APP_CONFIG, AppConfig } from './app-config';

@Injectable({
  providedIn: 'root'
})
export class ConfigService {
  private config = inject(APP_CONFIG);

  get apiUrl(): string {
    return this.config.apiUrl;
  }

  isFeatureEnabled(feature: keyof AppConfig['features']): boolean {
    return this.config.features[feature];
  }

  get version(): string {
    return this.config.version;
  }
}
```

**Фабричные провайдеры:**
```typescript
// logger.service.ts
import { Injectable } from '@angular/core';

export abstract class Logger {
  abstract log(message: string): void;
  abstract error(message: string): void;
}

@Injectable()
export class ConsoleLogger extends Logger {
  log(message: string): void {
    console.log(`[LOG] ${message}`);
  }

  error(message: string): void {
    console.error(`[ERROR] ${message}`);
  }
}

@Injectable()
export class ApiLogger extends Logger {
  log(message: string): void {
    // Отправка логов на сервер
    fetch('/api/logs', {
      method: 'POST',
      body: JSON.stringify({ message, level: 'info' })
    });
  }

  error(message: string): void {
    fetch('/api/logs', {
      method: 'POST',
      body: JSON.stringify({ message, level: 'error' })
    });
  }
}

// Фабричная функция
export function loggerFactory(isProduction: boolean): Logger {
  return isProduction ? new ApiLogger() : new ConsoleLogger();
}

// Регистрация с фабрикой
@NgModule({
  providers: [
    {
      provide: Logger,
      useFactory: loggerFactory,
      deps: [] // зависимости для фабрики
    }
  ]
})
```

**Optional dependencies:**
```typescript
import { Injectable, Optional, inject } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class AnalyticsService {
  // Опциональная зависимость
  constructor(@Optional() private logger?: Logger) {}

  trackEvent(event: string, data: any) {
    // Если logger предоставлен - используем его
    this.logger?.log(`Event: ${event}, Data: ${JSON.stringify(data)}`);
    
    // Основная логика трекинга
    console.log('Tracking event:', event, data);
  }
}
```

---

#### **6. Практика: Создание сервиса для работы с API**

**Полноценный HTTP-сервис с обработкой ошибок:**
```typescript
// api.service.ts
import { Injectable, inject, signal } from '@angular/core';
import { HttpClient, HttpErrorResponse, HttpParams } from '@angular/common/http';
import { Observable, catchError, throwError, tap } from 'rxjs';

export interface ApiResponse<T> {
  data: T;
  message?: string;
  success: boolean;
}

@Injectable({
  providedIn: 'root'
})
export class ApiService {
  private http = inject(HttpClient);
  private baseUrl = 'https://api.example.com';
  
  // Сигналы для глобального состояния загрузки
  isLoading = signal(false);
  error = signal<string | null>(null);

  // GET запрос
  get<T>(endpoint: string, params?: any): Observable<T> {
    this.setLoading(true);
    
    let httpParams = new HttpParams();
    if (params) {
      Object.keys(params).forEach(key => {
        if (params[key] !== null && params[key] !== undefined) {
          httpParams = httpParams.set(key, params[key].toString());
        }
      });
    }

    return this.http.get<T>(`${this.baseUrl}/${endpoint}`, { params: httpParams })
      .pipe(
        tap(() => this.setLoading(false)),
        catchError(this.handleError.bind(this))
      );
  }

  // POST запрос
  post<T>(endpoint: string, data: any): Observable<T> {
    this.setLoading(true);
    
    return this.http.post<T>(`${this.baseUrl}/${endpoint}`, data)
      .pipe(
        tap(() => this.setLoading(false)),
        catchError(this.handleError.bind(this))
      );
  }

  // PUT запрос
  put<T>(endpoint: string, data: any): Observable<T> {
    this.setLoading(true);
    
    return this.http.put<T>(`${this.baseUrl}/${endpoint}`, data)
      .pipe(
        tap(() => this.setLoading(false)),
        catchError(this.handleError.bind(this))
      );
  }

  // DELETE запрос
  delete<T>(endpoint: string): Observable<T> {
    this.setLoading(true);
    
    return this.http.delete<T>(`${this.baseUrl}/${endpoint}`)
      .pipe(
        tap(() => this.setLoading(false)),
        catchError(this.handleError.bind(this))
      );
  }

  private setLoading(loading: boolean) {
    this.isLoading.set(loading);
    if (!loading) {
      this.error.set(null);
    }
  }

  private handleError(error: HttpErrorResponse): Observable<never> {
    this.setLoading(false);
    
    let errorMessage = 'Произошла ошибка';
    
    if (error.error instanceof ErrorEvent) {
      // Клиентская ошибка
      errorMessage = `Ошибка: ${error.error.message}`;
    } else {
      // Серверная ошибка
      switch (error.status) {
        case 400:
          errorMessage = 'Неверный запрос';
          break;
        case 401:
          errorMessage = 'Не авторизован';
          break;
        case 403:
          errorMessage = 'Доступ запрещен';
          break;
        case 404:
          errorMessage = 'Ресурс не найден';
          break;
        case 500:
          errorMessage = 'Внутренняя ошибка сервера';
          break;
        default:
          errorMessage = `Ошибка ${error.status}: ${error.message}`;
      }
    }
    
    this.error.set(errorMessage);
    console.error('API Error:', errorMessage);
    
    return throwError(() => new Error(errorMessage));
  }

  clearError() {
    this.error.set(null);
  }
}
```

**Использование в компоненте:**
```typescript
// user-management.component.ts
import { Component, inject, signal } from '@angular/core';
import { ApiService } from '../services/api.service';
import { User } from '../models/user.model';

@Component({
  selector: 'app-user-management',
  template: `
    <div class="user-management">
      <!-- Индикатор загрузки -->
      @if (apiService.isLoading()) {
        <div class="loading">Загрузка...</div>
      }

      <!-- Сообщение об ошибке -->
      @if (apiService.error()) {
        <div class="error">
          {{ apiService.error() }}
          <button (click)="apiService.clearError()">×</button>
        </div>
      }

      <!-- Список пользователей -->
      <div class="user-list">
        @for (user of users(); track user.id) {
          <app-user-card 
            [user]="user"
            (edit)="onEditUser($event)"
            (delete)="onDeleteUser($event)">
          </app-user-card>
        }
      </div>

      <!-- Кнопка загрузки -->
      <button (click)="loadUsers()" [disabled]="apiService.isLoading()">
        {{ apiService.isLoading() ? 'Загрузка...' : 'Обновить' }}
      </button>
    </div>
  `
})
export class UserManagementComponent {
  private apiService = inject(ApiService);
  
  users = signal<User[]>([]);

  loadUsers() {
    this.apiService.get<User[]>('users').subscribe({
      next: (users) => {
        this.users.set(users);
      },
      error: (error) => {
        console.error('Ошибка загрузки пользователей:', error);
      }
    });
  }

  onEditUser(user: User) {
    this.apiService.put<User>(`users/${user.id}`, user).subscribe({
      next: (updatedUser) => {
        // Обновляем пользователя в списке
        this.users.update(users => 
          users.map(u => u.id === updatedUser.id ? updatedUser : u)
        );
      },
      error: (error) => {
        console.error('Ошибка обновления пользователя:', error);
      }
    });
  }

  onDeleteUser(userId: number) {
    if (confirm('Вы уверены, что хотите удалить пользователя?')) {
      this.apiService.delete(`users/${userId}`).subscribe({
        next: () => {
          // Удаляем пользователя из списка
          this.users.update(users => 
            users.filter(u => u.id !== userId)
          );
        },
        error: (error) => {
          console.error('Ошибка удаления пользователя:', error);
        }
      });
    }
  }

  ngOnInit() {
    this.loadUsers();
  }
}
```

**Сервис для аутентификации:**
```typescript
// auth.service.ts
import { Injectable, inject, signal } from '@angular/core';
import { Router } from '@angular/router';
import { BehaviorSubject, Observable } from 'rxjs';

export interface User {
  id: number;
  email: string;
  name: string;
  role: 'user' | 'admin';
}

export interface AuthResponse {
  user: User;
  token: string;
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private router = inject(Router);
  private apiService = inject(ApiService);
  
  // Сигналы для состояния аутентификации
  private currentUser = signal<User | null>(null);
  private isAuthenticated = signal(false);

  // Геттеры
  user = this.currentUser.asReadonly();
  authenticated = this.isAuthenticated.asReadonly();

  constructor() {
    // Проверяем наличие токена при инициализации
    this.checkAuthState();
  }

  login(email: string, password: string): Observable<AuthResponse> {
    return this.apiService.post<AuthResponse>('auth/login', { email, password })
      .pipe(
        tap(response => {
          this.handleLoginSuccess(response);
        })
      );
  }

  register(userData: any): Observable<AuthResponse> {
    return this.apiService.post<AuthResponse>('auth/register', userData)
      .pipe(
        tap(response => {
          this.handleLoginSuccess(response);
        })
      );
  }

  logout(): void {
    localStorage.removeItem('auth_token');
    this.currentUser.set(null);
    this.isAuthenticated.set(false);
    this.router.navigate(['/login']);
  }

  private handleLoginSuccess(response: AuthResponse): void {
    localStorage.setItem('auth_token', response.token);
    this.currentUser.set(response.user);
    this.isAuthenticated.set(true);
    this.router.navigate(['/dashboard']);
  }

  private checkAuthState(): void {
    const token = localStorage.getItem('auth_token');
    if (token) {
      // В реальном приложении здесь бы была проверка токена
      this.apiService.get<User>('auth/me').subscribe({
        next: (user) => {
          this.currentUser.set(user);
          this.isAuthenticated.set(true);
        },
        error: () => {
          this.logout();
        }
      });
    }
  }

  hasRole(role: string): boolean {
    return this.currentUser()?.role === role;
  }

  isLoggedIn(): boolean {
    return this.isAuthenticated();
  }
}
```

---

### **Резюме**

*   **Сервисы** - для бизнес-логики, работы с данными и управления состоянием
*   **Dependency Injection** - паттерн для управления зависимостями
*   **`@Injectable()`** - декоратор для классов, которые могут иметь зависимости
*   **Уровни предоставления** - `root`, модуль, компонент
*   **Способы инжектирования** - через конструктор или `inject()` функцию
*   **InjectionToken** - для конфигурации и абстрактных зависимостей
*   **Сервисы с сигналами** - современный способ управления состоянием

**Лучшие практики:**
- Используйте `providedIn: 'root'` для синглтон сервисов
- Разделяйте ответственность между сервисами
- Используйте сигналы для реактивного состояния
- Инжектируйте зависимости, а не создавайте их
- Обрабатывайте ошибки в сервисах

---

### **Контрольные вопросы:**

1.  В чем разница между регистрацией сервиса в `root` и в компоненте?
2.  Почему рекомендуется использовать `providedIn: 'root'`?
3.  Как тестировать компонент, который зависит от сервиса?
4.  В чем преимущество использования `inject()` перед инжектированием через конструктор?
5.  Как создать сервис, который зависит от другого сервиса?
6.  Что такое InjectionToken и когда его следует использовать?
7.  Как организовать глобальное состояние приложения с помощью сервисов?
8.  В чем разница между синглтон и не-синглтон сервисами?
9.  Как обрабатывать ошибки в HTTP-сервисах?
10. Как создать сервис, который требует конфигурацию при инициализации?