# Лекция. Директивы и пайпы в Angular

**Цель лекции:** Понять назначение и научиться создавать собственные директивы и пайпы. Освоить разницу между структурными и атрибутными директивами, чистыми и нечистыми пайпами.

---

### **План лекции:**

1.  **Введение: Что такое директивы и пайпы?**
    *   Назначение и классификация.
    *   Встроенные директивы и пайпы.

2.  **Атрибутные директивы**
    *   Создание кастомной атрибутной директивы.
    *   Работа с Host-элементом.
    *   Обработка событий в директивах.

3.  **Структурные директивы**
    *   Принцип работы структурных директив.
    *   Создание кастомной структурной директивы.

4.  **Пайпы (Pipes)**
    *   Назначение и синтаксис.
    *   Чистые и нечистые пайпы.
    *   Создание кастомных пайпов.
    *   Цепочки пайпов.

5.  **Практические примеры**
    *   Директива для тултипов.
    *   Пайп для форматирования номеров телефонов.

---

### **Детальное рассмотрение каждого пункта плана:**

#### **1. Введение: Что такое директивы и пайпы?**

**Директивы** - это классы, которые добавляют дополнительное поведение элементам в Angular приложениях.

**Типы директив:**
- **Компоненты** - директивы с шаблоном
- **Атрибутные директивы** - меняют внешний вид или поведение элемента
- **Структурные директивы** - меняют структуру DOM

**Пайпы** - функции для трансформации данных прямо в шаблонах.

**Встроенные директивы:**
```html
<!-- Атрибутные -->
<div [ngClass]="{'active': isActive}">Элемент с классами</div>
<div [ngStyle]="{'color': textColor}">Текст с стилями</div>

<!-- Структурные (устаревшие, но пока используются) -->
<div *ngIf="isVisible">Условное отображение</div>
<div *ngFor="let item of items">Цикл</div>
```

**Встроенные пайпы:**
```html
<p>{{ price | currency }}</p>                    <!-- $100.00 -->
<p>{{ currentDate | date:'fullDate' }}</p>      <!-- Monday, January 1, 2024 -->
<p>{{ text | uppercase }}</p>                   <!-- ТЕКСТ БОЛЬШИМИ БУКВАМИ -->
<p>{{ percentage | percent }}</p>               <!-- 50% -->
<p>{{ user | json }}</p>                        <!-- {"name":"John","age":30} -->
```

---

#### **2. Атрибутные директивы**

**Создание кастомной атрибутной директивы:**
```typescript
// highlight.directive.ts
import { Directive, ElementRef, Input, OnInit, Renderer2 } from '@angular/core';

@Directive({
  selector: '[appHighlight]',
  standalone: true // Для standalone-директив
})
export class HighlightDirective implements OnInit {
  @Input() appHighlight: string = 'yellow'; // Цвет по умолчанию
  @Input() textColor: string = 'black';

  constructor(
    private elementRef: ElementRef,
    private renderer: Renderer2
  ) {}

  ngOnInit() {
    // Устанавливаем стили безопасным способом
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'background-color',
      this.appHighlight
    );
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'color',
      this.textColor
    );
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'padding',
      '10px'
    );
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'border-radius',
      '5px'
    );
  }
}
```

**Использование директивы:**
```html
<!-- component.html -->
<p appHighlight>Просто выделенный текст</p>
<p [appHighlight]="'lightblue'" [textColor]="'darkblue'">
  Текст с синим фоном
</p>
<p [appHighlight]="highlightColor" [textColor]="textColor">
  Динамическое выделение
</p>
```

**Директива для ротации элемента:**
```typescript
// rotate.directive.ts
import { Directive, ElementRef, Input, Renderer2, HostListener } from '@angular/core';

@Directive({
  selector: '[appRotate]'
})
export class RotateDirective {
  @Input() appRotate: number = 0;
  @Input() rotationStep: number = 90;
  
  private currentRotation = 0;

  constructor(
    private elementRef: ElementRef,
    private renderer: Renderer2
  ) {}

  ngOnInit() {
    this.applyRotation();
  }

  @HostListener('click') onClick() {
    this.currentRotation += this.rotationStep;
    this.applyRotation();
  }

  @HostListener('mouseenter') onMouseEnter() {
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'cursor',
      'pointer'
    );
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'transition',
      'transform 0.3s ease'
    );
  }

  private applyRotation() {
    this.renderer.setStyle(
      this.elementRef.nativeElement,
      'transform',
      `rotate(${this.currentRotation}deg)`
    );
  }
}
```

```html
<!-- Использование -->
<img src="logo.png" appRotate [rotationStep]="45" alt="Логотип">
<!-- Кликните на изображение чтобы повернуть его -->
```

**Директива для отслеживания кликов снаружи элемента:**
```typescript
// click-outside.directive.ts
import { Directive, ElementRef, Output, EventEmitter, HostListener } from '@angular/core';

@Directive({
  selector: '[appClickOutside]'
})
export class ClickOutsideDirective {
  @Output() appClickOutside = new EventEmitter<void>();

  constructor(private elementRef: ElementRef) {}

  @HostListener('document:click', ['$event.target'])
  onClick(target: any) {
    const clickedInside = this.elementRef.nativeElement.contains(target);
    if (!clickedInside) {
      this.appClickOutside.emit();
    }
  }
}
```

```html
<!-- Использование -->
<div class="dropdown" appClickOutside (appClickOutside)="closeDropdown()">
  <button (click)="toggleDropdown()">Меню ▼</button>
  <div class="dropdown-content" *ngIf="isOpen">
    <!-- содержимое dropdown -->
  </div>
</div>
```

---

#### **3. Структурные директивы**

**Создание кастомной структурной директивы:**
```typescript
// app-if.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appIf]'
})
export class AppIfDirective {
  private hasView = false;

  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) {}

  @Input() set appIf(condition: boolean) {
    if (condition && !this.hasView) {
      // Показываем элемент
      this.viewContainer.createEmbeddedView(this.templateRef);
      this.hasView = true;
    } else if (!condition && this.hasView) {
      // Скрываем элемент
      this.viewContainer.clear();
      this.hasView = false;
    }
  }
}
```

```html
<!-- Использование -->
<div *appIf="isVisible">Этот элемент условно отображается</div>
```

**Директива для повторения элемента N раз:**
```typescript
// repeat.directive.ts
import { Directive, Input, TemplateRef, ViewContainerRef } from '@angular/core';

@Directive({
  selector: '[appRepeat]'
})
export class RepeatDirective {
  constructor(
    private templateRef: TemplateRef<any>,
    private viewContainer: ViewContainerRef
  ) {}

  @Input() set appRepeat(times: number) {
    this.viewContainer.clear();
    
    for (let i = 0; i < times; i++) {
      this.viewContainer.createEmbeddedView(this.templateRef, {
        // Контекстные переменные
        $implicit: i,
        index: i,
        first: i === 0,
        last: i === times - 1,
        even: i % 2 === 0,
        odd: i % 2 === 1
      });
    }
  }
}
```

```html
<!-- Использование -->
<ul>
  <li *appRepeat="5; let index; let first = first">
    Элемент {{ index }} 
    <span *appIf="first">⭐ Первый элемент!</span>
  </li>
</ul>
```

---

#### **4. Пайпы (Pipes)**

**Создание кастомного пайпа:**
```typescript
// truncate.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'truncate',
  standalone: true
})
export class TruncatePipe implements PipeTransform {
  transform(value: string, limit: number = 50, completeWords: boolean = false, ellipsis: string = '...'): string {
    if (!value) return '';
    
    if (value.length <= limit) {
      return value;
    }

    if (completeWords) {
      limit = value.substr(0, limit).lastIndexOf(' ');
    }

    return value.substr(0, limit) + ellipsis;
  }
}
```

```html
<!-- Использование -->
<p>{{ longText | truncate }}</p>
<!-- "Это очень длинный текст который нужно обрезать..." -->

<p>{{ longText | truncate:30 }}</p>
<!-- "Это очень длинный текст ко..." -->

<p>{{ longText | truncate:30:true }}</p>
<!-- "Это очень длинный текст..." -->

<p>{{ longText | truncate:30:true:' >>>' }}</p>
<!-- "Это очень длинный текст >>>" -->
```

**Пайп для форматирования номеров телефонов:**
```typescript
// phone-format.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'phoneFormat'
})
export class PhoneFormatPipe implements PipeTransform {
  transform(phone: string, country: string = 'ru'): string {
    if (!phone) return '';
    
    // Удаляем все нецифровые символы
    const cleaned = phone.replace(/\D/g, '');
    
    switch (country) {
      case 'ru':
        return this.formatRussianPhone(cleaned);
      case 'us':
        return this.formatUSPhone(cleaned);
      default:
        return phone;
    }
  }

  private formatRussianPhone(phone: string): string {
    if (phone.length === 11) {
      return `+7 (${phone.slice(1, 4)}) ${phone.slice(4, 7)}-${phone.slice(7, 9)}-${phone.slice(9)}`;
    } else if (phone.length === 10) {
      return `+7 (${phone.slice(0, 3)}) ${phone.slice(3, 6)}-${phone.slice(6, 8)}-${phone.slice(8)}`;
    }
    return phone;
  }

  private formatUSPhone(phone: string): string {
    if (phone.length === 10) {
      return `+1 (${phone.slice(0, 3)}) ${phone.slice(3, 6)}-${phone.slice(6)}`;
    }
    return phone;
  }
}
```

```html
<!-- Использование -->
<p>{{ '79123456789' | phoneFormat }}</p>
<!-- +7 (912) 345-67-89 -->

<p>{{ '9123456789' | phoneFormat:'ru' }}</p>
<!-- +7 (912) 345-67-89 -->

<p>{{ '1234567890' | phoneFormat:'us' }}</p>
<!-- +1 (123) 456-7890 -->
```

**Чистые и нечистые пайпы:**
```typescript
// Чистый пайп (по умолчанию) - пересчитывается только при изменении входных значений
@Pipe({
  name: 'purePipe',
  pure: true // можно не указывать, это значение по умолчанию
})

// Нечистый пайп - пересчитывается при каждом цикле изменений
@Pipe({
  name: 'impurePipe', 
  pure: false
})
```

**Нечистый пайп для фильтрации массива:**
```typescript
// filter-array.pipe.ts
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'filterArray',
  pure: false // Нечистый пайп - обновляется при любом изменении массива
})
export class FilterArrayPipe implements PipeTransform {
  transform(items: any[], field: string, value: any): any[] {
    if (!items || !field || value === undefined) {
      return items;
    }
    
    return items.filter(item => item[field] === value);
  }
}
```

```html
<!-- Использование -->
<div *ngFor="let user of users | filterArray:'department':'IT'">
  {{ user.name }} - {{ user.department }}
</div>
```

**Цепочки пайпов:**
```html
<!-- Можно комбинировать несколько пайпов -->
<p>{{ currentDate | date:'fullDate' | uppercase }}</p>
<!-- "MONDAY, JANUARY 1, 2024" -->

<p>{{ price | currency:'EUR':'symbol':'1.2-2' | lowercase }}</p>
<!-- "€100.00" -->

<div *ngFor="let user of users | filterArray:'active':true | slice:0:5">
  {{ user.name | uppercase }} - {{ user.salary | currency }}
</div>
```

---

#### **5. Практические примеры**

**Директива для тултипов:**
```typescript
// tooltip.directive.ts
import { Directive, ElementRef, Input, Renderer2, HostListener, ComponentRef, ViewContainerRef, ComponentFactoryResolver, Injector } from '@angular/core';
import { TooltipComponent } from './tooltip.component';

@Directive({
  selector: '[appTooltip]'
})
export class TooltipDirective {
  @Input() appTooltip: string = '';
  @Input() tooltipPosition: 'top' | 'bottom' | 'left' | 'right' = 'top';
  @Input() tooltipDelay: number = 300;
  
  private tooltipComponentRef: ComponentRef<TooltipComponent> | null = null;
  private timeoutId: any;

  constructor(
    private elementRef: ElementRef,
    private renderer: Renderer2,
    private viewContainerRef: ViewContainerRef,
    private componentFactoryResolver: ComponentFactoryResolver,
    private injector: Injector
  ) {}

  @HostListener('mouseenter') onMouseEnter() {
    this.timeoutId = setTimeout(() => {
      this.showTooltip();
    }, this.tooltipDelay);
  }

  @HostListener('mouseleave') onMouseLeave() {
    if (this.timeoutId) {
      clearTimeout(this.timeoutId);
    }
    this.hideTooltip();
  }

  private showTooltip() {
    if (this.tooltipComponentRef) return;

    const factory = this.componentFactoryResolver.resolveComponentFactory(TooltipComponent);
    this.tooltipComponentRef = this.viewContainerRef.createComponent(factory);
    
    const tooltipInstance = this.tooltipComponentRef.instance;
    tooltipInstance.text = this.appTooltip;
    tooltipInstance.position = this.tooltipPosition;

    // Позиционирование тултипа
    this.positionTooltip();
  }

  private hideTooltip() {
    if (this.tooltipComponentRef) {
      this.tooltipComponentRef.destroy();
      this.tooltipComponentRef = null;
    }
  }

  private positionTooltip() {
    // Логика позиционирования тултипа относительно элемента
    const hostPos = this.elementRef.nativeElement.getBoundingClientRect();
    // ... расчет позиции
  }
}
```

```typescript
// tooltip.component.ts
import { Component, Input } from '@angular/core';

@Component({
  selector: 'app-tooltip',
  template: `
    <div class="tooltip" [class]="'tooltip-' + position">
      {{ text }}
      <div class="tooltip-arrow"></div>
    </div>
  `,
  styles: [`
    .tooltip {
      position: fixed;
      background: #333;
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      z-index: 1000;
      max-width: 200px;
    }
    .tooltip-arrow {
      /* стили для стрелочки */
    }
  `]
})
export class TooltipComponent {
  @Input() text: string = '';
  @Input() position: string = 'top';
}
```

```html
<!-- Использование -->
<button 
  appTooltip="Это подсказка для кнопки"
  tooltipPosition="top"
  tooltipDelay="500">
  Наведи на меня
</button>
```

**Пайп для форматирования времени относительно текущего:**
```typescript
// relative-time.pipe.ts
import { Pipe, PipeTransform, OnDestroy } from '@angular/core';

@Pipe({
  name: 'relativeTime',
  pure: false // Нечистый пайп, так как время постоянно меняется
})
export class RelativeTimePipe implements PipeTransform, OnDestroy {
  private timer: number | null = null;

  transform(value: string | Date): string {
    if (!value) return '';
    
    const date = new Date(value);
    const now = new Date();
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    // Очищаем предыдущий таймер
    if (this.timer) {
      clearTimeout(this.timer);
    }

    // Устанавливаем таймер для обновления
    this.setUpdateTimer(diffInSeconds);

    return this.getRelativeTimeString(diffInSeconds);
  }

  ngOnDestroy() {
    if (this.timer) {
      clearTimeout(this.timer);
    }
  }

  private setUpdateTimer(diffInSeconds: number) {
    let updateIn = 60000; // Обновлять каждую минуту по умолчанию

    if (diffInSeconds < 60) {
      updateIn = 1000; // Каждую секунду для "только что"
    } else if (diffInSeconds < 3600) {
      updateIn = 60000; // Каждую минуту
    }

    this.timer = window.setTimeout(() => {
      // Принудительно обновляем пайп
      // В реальном приложении нужно использовать ChangeDetectorRef
    }, updateIn);
  }

  private getRelativeTimeString(diffInSeconds: number): string {
    const intervals = {
      год: 31536000,
      месяц: 2592000,
      неделя: 604800,
      день: 86400,
      час: 3600,
      минута: 60,
      секунда: 1
    };

    if (diffInSeconds < 5) {
      return 'только что';
    }

    for (const [unit, secondsInUnit] of Object.entries(intervals)) {
      const count = Math.floor(diffInSeconds / secondsInUnit);
      
      if (count >= 1) {
        let unitName = unit;
        
        // Склонение единиц измерения
        if (count === 1) {
          unitName = unit;
        } else if (count >= 2 && count <= 4 && ['месяц', 'день', 'час'].includes(unit)) {
          unitName = this.declineUnit(unit);
        } else if (count >= 5) {
          unitName = this.declineUnit(unit, true);
        }

        return `${count} ${unitName} назад`;
      }
    }

    return 'только что';
  }

  private declineUnit(unit: string, plural: boolean = false): string {
    const declensions: { [key: string]: [string, string, string] } = {
      год: ['год', 'года', 'лет'],
      месяц: ['месяц', 'месяца', 'месяцев'],
      неделя: ['неделя', 'недели', 'недель'],
      день: ['день', 'дня', 'дней'],
      час: ['час', 'часа', 'часов'],
      минута: ['минута', 'минуты', 'минут'],
      секунда: ['секунда', 'секунды', 'секунд']
    };

    if (!plural) {
      return declensions[unit][1]; // для 2-4
    } else {
      return declensions[unit][2]; // для 5 и более
    }
  }
}
```

```html
<!-- Использование -->
<p>Сообщение отправлено: {{ messageDate | relativeTime }}</p>
<!-- "5 минут назад" -->
<!-- "2 часа назад" -->
<!-- "1 день назад" -->
<!-- "только что" -->
```

---

### **Резюме**

*   **Директивы** добавляют поведение элементам:
    - **Атрибутные** - меняют внешний вид/поведение
    - **Структурные** - меняют структуру DOM
*   **Пайпы** трансформируют данные в шаблонах:
    - **Чистые** - пересчитываются только при изменении входных данных
    - **Нечистые** - пересчитываются при каждом цикле изменений
*   **`ElementRef` и `Renderer2`** - для безопасной работы с DOM в директивах
*   **`TemplateRef` и `ViewContainerRef`** - для создания структурных директив
*   **Цепочки пайпов** - мощный инструмент для преобразования данных

---

### **Контрольные вопросы:**

1.  В чем разница между атрибутными и структурными директивами?
2.  Почему для работы с DOM в директивах рекомендуется использовать `Renderer2` вместо прямого доступа?
3.  Как создать структурную директиву, аналогичную `*ngIf`?
4.  В каких случаях следует использовать нечистые пайпы?
5.  Как передавать параметры в кастомные пайпы?
6.  Что такое `HostListener` и для чего он используется в директивах?
7.  Как организовать взаимодействие между директивой и компонентом через `@Output`?
8.  В чем преимущество использования `ViewContainerRef` для создания динамических компонентов?
9.  Как тестировать кастомные директивы и пайпы?
10. Когда следует создавать кастомную директиву вместо компонента?