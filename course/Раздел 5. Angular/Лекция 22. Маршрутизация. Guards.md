# Лекция. Маршрутизация и Guards в Angular

**Цель лекции:** Научиться настраивать маршрутизацию в Angular приложениях, создавать многостраничные SPA и защищать маршруты с помощью guards.

---

### **План лекции:**

1.  **Введение: Роутинг в SPA**
    *   Что такое маршрутизация в SPA.
    *   Преимущества Angular Router.

2.  **Основы маршрутизации**
    *   Настройка маршрутов.
    *   `RouterOutlet` и `RouterLink`.
    *   Навигация программно.

3.  **Параметры маршрутов**
    *   Параметры (`/users/:id`).
    *   Query-параметры (`/search?q=angular`).
    *   Получение параметров в компонентах.

4.  **Стратегии загрузки**
    *   Eager Loading.
    *   Lazy Loading модулей.

5.  **Guards - защита маршрутов**
    *   `CanActivate` - доступ к маршруту.
    *   `CanActivateChild` - доступ к дочерним маршрутам.
    *   `CanDeactivate` - подтверждение ухода.
    *   `CanLoad` - загрузка lazy-модулей.
    *   `Resolve` - предзагрузка данных.

6.  **Практика: Приложение с защищенными маршрутами**
    *   Система аутентификации.
    *   Роли пользователей.
    *   Защита маршрутов.

---

### **Детальное рассмотрение каждого пункта плана:**

#### **1. Введение: Роутинг в SPA**

**Что такое маршрутизация в SPA:**
SPA (Single Page Application) - это приложение, которое загружает одну HTML-страницу и динамически обновляет контент при взаимодействии с пользователем. Маршрутизация эмулирует поведение многостраничного приложения в SPA.

**Преимущества Angular Router:**
- Декларативная конфигурация маршрутов
- Поддержка lazy loading
- Защита маршрутов (guards)
- Поддержка параметров и query-параметров
- История навигации

---

#### **2. Основы маршрутизации**

**Настройка маршрутов:**
```typescript
// app.routes.ts
import { Routes } from '@angular/router';
import { HomeComponent } from './home/home.component';
import { AboutComponent } from './about/about.component';
import { ContactComponent } from './contact/contact.component';
import { PageNotFoundComponent } from './page-not-found/page-not-found.component';

export const routes: Routes = [
  { path: '', component: HomeComponent }, // Маршрут по умолчанию
  { path: 'home', component: HomeComponent },
  { path: 'about', component: AboutComponent },
  { path: 'contact', component: ContactComponent },
  { path: '**', component: PageNotFoundComponent } // Wildcard - 404
];
```

**Регистрация маршрутов:**
```typescript
// main.ts (standalone)
import { bootstrapApplication } from '@angular/platform-browser';
import { provideRouter } from '@angular/router';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes)
  ]
});

// Или в NgModule
@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }
```

**Базовый компонент приложения:**
```typescript
// app.component.ts
import { Component } from '@angular/core';
import { RouterOutlet, RouterLink, RouterLinkActive } from '@angular/router';

@Component({
  selector: 'app-root',
  template: `
    <nav>
      <ul>
        <li>
          <a routerLink="/home" routerLinkActive="active">Главная</a>
        </li>
        <li>
          <a routerLink="/about" routerLinkActive="active">О нас</a>
        </li>
        <li>
          <a routerLink="/contact" routerLinkActive="active">Контакты</a>
        </li>
      </ul>
    </nav>
    
    <main>
      <!-- Здесь будет отображаться компонент маршрута -->
      <router-outlet></router-outlet>
    </main>
  `,
  styles: [`
    .active {
      color: blue;
      font-weight: bold;
    }
  `],
  standalone: true,
  imports: [RouterOutlet, RouterLink, RouterLinkActive]
})
export class AppComponent { }
```

**Навигация программно:**
```typescript
// contact.component.ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  template: `
    <h2>Контакты</h2>
    <button (click)="goToHome()">На главную</button>
    <button (click)="goBack()">Назад</button>
  `
})
export class ContactComponent {
  constructor(private router: Router) {}

  goToHome() {
    // Простая навигация
    this.router.navigate(['/home']);
    
    // Или с абсолютным путем
    this.router.navigateByUrl('/home');
  }

  goBack() {
    // Назад по истории
    this.router.navigate(['../']);
    
    // Или
    // this.router.navigate(['..'], { relativeTo: this.route });
  }
}
```

---

#### **3. Параметры маршрутов**

**Маршруты с параметрами:**
```typescript
// app.routes.ts
export const routes: Routes = [
  { path: 'users', component: UserListComponent },
  { path: 'users/:id', component: UserDetailComponent }, // :id - параметр
  { path: 'products/:category/:id', component: ProductDetailComponent }
];
```

**Получение параметров в компоненте:**
```typescript
// user-detail.component.ts
import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';

@Component({
  template: `
    <h2>Пользователь {{ userId }}</h2>
    <p>Имя: {{ userName }}</p>
    <button (click)="navigateToEdit()">Редактировать</button>
  `
})
export class UserDetailComponent implements OnInit {
  userId: string | null = null;
  userName: string = '';

  constructor(
    private route: ActivatedRoute,
    private router: Router
  ) {}

  ngOnInit() {
    // Получение параметра через snapshot (однократно)
    this.userId = this.route.snapshot.paramMap.get('id');
    
    // Или подписка на изменения параметров
    this.route.paramMap.subscribe(params => {
      this.userId = params.get('id');
      this.loadUser(this.userId!);
    });

    // Получение query-параметров
    this.route.queryParamMap.subscribe(queryParams => {
      const editMode = queryParams.get('edit');
      if (editMode === 'true') {
        this.enableEditMode();
      }
    });
  }

  private loadUser(id: string) {
    // Загрузка данных пользователя
    this.userName = `Пользователь ${id}`;
  }

  navigateToEdit() {
    // Навигация с query-параметрами
    this.router.navigate([], {
      relativeTo: this.route,
      queryParams: { edit: 'true' },
      queryParamsHandling: 'merge' // Сохранить существующие query-params
    });
  }
}
```

**Навигация с параметрами:**
```typescript
// user-list.component.ts
import { Component } from '@angular/core';
import { Router } from '@angular/router';

@Component({
  template: `
    <h2>Список пользователей</h2>
    <ul>
      <li (click)="viewUser(1)">Пользователь 1</li>
      <li (click)="viewUser(2)">Пользователь 2</li>
    </ul>
    
    <button (click)="viewUserWithQuery(3)">Просмотр с параметрами</button>
  `
})
export class UserListComponent {
  constructor(private router: Router) {}

  viewUser(userId: number) {
    // Навигация с параметром
    this.router.navigate(['/users', userId]);
  }

  viewUserWithQuery(userId: number) {
    // Навигация с query-параметрами
    this.router.navigate(['/users', userId], {
      queryParams: { 
        source: 'list', 
        timestamp: new Date().getTime() 
      }
    });
    
    // Или альтернативный синтаксис
    this.router.navigate(['/users', userId], {
      queryParams: { source: 'list' },
      fragment: 'section1' // Якорь
    });
  }
}
```

---

#### **4. Стратегии загрузки**

**Eager Loading (все модули загружаются сразу):**
```typescript
// app.routes.ts (не рекомендуется для больших приложений)
export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'about', component: AboutComponent }
];
```

**Lazy Loading (модули загружаются по требованию):**
```typescript
// app.routes.ts
export const routes: Routes = [
  { path: '', component: HomeComponent },
  
  // Lazy loading модуля
  { 
    path: 'admin', 
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule)
  },
  
  { 
    path: 'products', 
    loadChildren: () => import('./products/products.routes').then(m => m.productRoutes)
  },
  
  // Standalone компоненты с lazy loading
  {
    path: 'settings',
    loadComponent: () => import('./settings/settings.component').then(c => c.SettingsComponent)
  }
];
```

**Модуль с дочерними маршрутами:**
```typescript
// admin/admin.routes.ts
import { Routes } from '@angular/router';
import { AdminDashboardComponent } from './admin-dashboard/admin-dashboard.component';
import { UserManagementComponent } from './user-management/user-management.component';
import { SettingsComponent } from './settings/settings.component';

export const adminRoutes: Routes = [
  { 
    path: '', 
    component: AdminDashboardComponent 
  },
  { 
    path: 'users', 
    component: UserManagementComponent 
  },
  { 
    path: 'settings', 
    component: SettingsComponent 
  }
];
```

```typescript
// admin/admin.module.ts
import { NgModule } from '@angular/core';
import { RouterModule } from '@angular/router';
import { adminRoutes } from './admin.routes';

@NgModule({
  imports: [
    RouterModule.forChild(adminRoutes)
  ],
  exports: [RouterModule]
})
export class AdminModule { }
```

---

#### **5. Guards - защита маршрутов**

**Сервис аутентификации:**
```typescript
// auth.service.ts
import { Injectable, signal } from '@angular/core';
import { Router } from '@angular/router';

export interface User {
  id: number;
  email: string;
  name: string;
  role: 'user' | 'admin';
}

@Injectable({
  providedIn: 'root'
})
export class AuthService {
  private currentUser = signal<User | null>(null);
  private isAuthenticated = signal(false);

  user = this.currentUser.asReadonly();
  authenticated = this.isAuthenticated.asReadonly();

  constructor(private router: Router) {
    // Проверка при инициализации
    this.checkAuthState();
  }

  login(email: string, password: string): boolean {
    // В реальном приложении здесь был бы HTTP-запрос
    if (email === 'admin@example.com' && password === 'admin') {
      const user: User = {
        id: 1,
        email: email,
        name: 'Администратор',
        role: 'admin'
      };
      
      this.currentUser.set(user);
      this.isAuthenticated.set(true);
      localStorage.setItem('auth_token', 'fake-jwt-token');
      return true;
    }
    
    if (email === 'user@example.com' && password === 'user') {
      const user: User = {
        id: 2,
        email: email,
        name: 'Пользователь',
        role: 'user'
      };
      
      this.currentUser.set(user);
      this.isAuthenticated.set(true);
      localStorage.setItem('auth_token', 'fake-jwt-token');
      return true;
    }
    
    return false;
  }

  logout(): void {
    this.currentUser.set(null);
    this.isAuthenticated.set(false);
    localStorage.removeItem('auth_token');
    this.router.navigate(['/login']);
  }

  hasRole(role: string): boolean {
    return this.currentUser()?.role === role;
  }

  private checkAuthState(): void {
    const token = localStorage.getItem('auth_token');
    if (token) {
      // В реальном приложении здесь была бы проверка токена
      this.isAuthenticated.set(true);
    }
  }
}
```

**Guard для аутентификации:**
```typescript
// auth.guard.ts
import { Injectable, inject } from '@angular/core';
import { 
  CanActivate, 
  CanActivateChild, 
  Router, 
  ActivatedRouteSnapshot, 
  RouterStateSnapshot,
  UrlTree 
} from '@angular/router';
import { Observable } from 'rxjs';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class AuthGuard implements CanActivate, CanActivateChild {
  private authService = inject(AuthService);
  private router = inject(Router);

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    
    return this.checkAuth(state.url);
  }

  canActivateChild(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<boolean | UrlTree> | Promise<boolean | UrlTree> | boolean | UrlTree {
    
    return this.canActivate(route, state);
  }

  private checkAuth(url: string): boolean | UrlTree {
    if (this.authService.authenticated()) {
      return true;
    }

    // Сохраняем URL для перенаправления после логина
    this.authService.redirectUrl = url;
    
    // Перенаправляем на страницу логина
    return this.router.createUrlTree(['/login']);
  }
}
```

**Guard для проверки ролей:**
```typescript
// role.guard.ts
import { Injectable, inject } from '@angular/core';
import { 
  CanActivate, 
  ActivatedRouteSnapshot, 
  RouterStateSnapshot, 
  UrlTree,
  Router 
} from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class RoleGuard implements CanActivate {
  private authService = inject(AuthService);
  private router = inject(Router);

  canActivate(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): boolean | UrlTree {
    
    const expectedRole = route.data['expectedRole'];
    const user = this.authService.user();
    
    if (user && this.authService.hasRole(expectedRole)) {
      return true;
    }

    // Если нет прав - перенаправляем на страницу доступа запрещено
    return this.router.createUrlTree(['/access-denied']);
  }
}
```

**Guard для подтверждения ухода:**
```typescript
// unsaved-changes.guard.ts
import { Injectable, inject } from '@angular/core';
import { CanDeactivate } from '@angular/router';
import { Observable } from 'rxjs';

export interface CanComponentDeactivate {
  canDeactivate: () => Observable<boolean> | Promise<boolean> | boolean;
}

@Injectable({
  providedIn: 'root'
})
export class UnsavedChangesGuard implements CanDeactivate<CanComponentDeactivate> {
  
  canDeactivate(
    component: CanComponentDeactivate
  ): Observable<boolean> | Promise<boolean> | boolean {
    
    return component.canDeactivate ? component.canDeactivate() : true;
  }
}
```

**Guard для проверки возможности загрузки модуля:**
```typescript
// can-load.guard.ts
import { Injectable, inject } from '@angular/core';
import { CanLoad, Route, UrlSegment, Router } from '@angular/router';
import { AuthService } from './auth.service';

@Injectable({
  providedIn: 'root'
})
export class CanLoadGuard implements CanLoad {
  private authService = inject(AuthService);
  private router = inject(Router);

  canLoad(route: Route, segments: UrlSegment[]): boolean {
    if (this.authService.authenticated()) {
      return true;
    }
    
    this.router.navigate(['/login']);
    return false;
  }
}
```

**Resolve Guard для предзагрузки данных:**
```typescript
// user-resolve.guard.ts
import { Injectable, inject } from '@angular/core';
import { Resolve, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';
import { Observable, of } from 'rxjs';
import { UserService } from './user.service';
import { User } from './user.model';

@Injectable({
  providedIn: 'root'
})
export class UserResolveGuard implements Resolve<User> {
  private userService = inject(UserService);

  resolve(
    route: ActivatedRouteSnapshot,
    state: RouterStateSnapshot
  ): Observable<User> | Promise<User> | User {
    
    const userId = route.paramMap.get('id');
    if (userId) {
      return this.userService.getUser(+userId);
    }
    
    return of({} as User);
  }
}
```

**Применение guards в маршрутах:**
```typescript
// app.routes.ts
export const routes: Routes = [
  { path: '', component: HomeComponent },
  { path: 'login', component: LoginComponent },
  { path: 'access-denied', component: AccessDeniedComponent },
  
  // Защищенный маршрут с аутентификацией
  {
    path: 'profile',
    component: ProfileComponent,
    canActivate: [AuthGuard]
  },
  
  // Маршрут с проверкой роли
  {
    path: 'admin',
    loadChildren: () => import('./admin/admin.module').then(m => m.AdminModule),
    canActivate: [AuthGuard, RoleGuard],
    canActivateChild: [RoleGuard],
    data: { expectedRole: 'admin' }
  },
  
  // Маршрут с подтверждением ухода
  {
    path: 'edit-user/:id',
    component: UserEditComponent,
    canDeactivate: [UnsavedChangesGuard],
    resolve: {
      user: UserResolveGuard
    }
  },
  
  // Lazy loading с проверкой загрузки
  {
    path: 'dashboard',
    loadChildren: () => import('./dashboard/dashboard.module').then(m => m.DashboardModule),
    canLoad: [CanLoadGuard]
  }
];
```

---

#### **6. Практика: Приложение с защищенными маршрутами**

**Полная конфигурация маршрутов:**
```typescript
// app.routes.ts
import { Routes } from '@angular/router';
import { AuthGuard } from './core/guards/auth.guard';
import { RoleGuard } from './core/guards/role.guard';
import { UnsavedChangesGuard } from './core/guards/unsaved-changes.guard';

export const routes: Routes = [
  // Публичные маршруты
  { path: '', redirectTo: '/home', pathMatch: 'full' },
  { path: 'home', loadComponent: () => import('./features/home/home.component').then(c => c.HomeComponent) },
  { path: 'login', loadComponent: () => import('./features/auth/login/login.component').then(c => c.LoginComponent) },
  { path: 'register', loadComponent: () => import('./features/auth/register/register.component').then(c => c.RegisterComponent) },
  
  // Защищенные маршруты
  {
    path: 'profile',
    loadComponent: () => import('./features/profile/profile.component').then(c => c.ProfileComponent),
    canActivate: [AuthGuard]
  },
  
  {
    path: 'products',
    loadChildren: () => import('./features/products/products.routes').then(m => m.productRoutes),
    canActivate: [AuthGuard]
  },
  
  // Админские маршруты
  {
    path: 'admin',
    loadChildren: () => import('./features/admin/admin.routes').then(m => m.adminRoutes),
    canActivate: [AuthGuard, RoleGuard],
    data: { expectedRole: 'admin' }
  },
  
  // Маршрут с подтверждением ухода
  {
    path: 'settings',
    loadComponent: () => import('./features/settings/settings.component').then(c => c.SettingsComponent),
    canActivate: [AuthGuard],
    canDeactivate: [UnsavedChangesGuard]
  },
  
  // 404
  { path: '**', loadComponent: () => import('./core/components/not-found/not-found.component').then(c => c.NotFoundComponent) }
];
```

**Компонент с подтверждением ухода:**
```typescript
// settings.component.ts
import { Component, signal } from '@angular/core';
import { CanComponentDeactivate } from '../../core/guards/unsaved-changes.guard';
import { Observable, of } from 'rxjs';

@Component({
  template: `
    <h2>Настройки</h2>
    
    <form (submit)="saveSettings()">
      <div>
        <label>Имя:</label>
        <input [value]="settings().name" (input)="updateName($event)">
      </div>
      
      <div>
        <label>Email:</label>
        <input [value]="settings().email" (input)="updateEmail($event)">
      </div>
      
      <button type="submit">Сохранить</button>
    </form>
    
    <p>Изменения: {{ hasUnsavedChanges() ? 'Есть' : 'Нет' }}</p>
  `
})
export class SettingsComponent implements CanComponentDeactivate {
  settings = signal({
    name: 'Иван Иванов',
    email: 'ivan@example.com'
  });
  
  originalSettings = { ...this.settings() };
  hasUnsavedChanges = signal(false);

  updateName(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.settings.update(s => ({ ...s, name: value }));
    this.checkChanges();
  }

  updateEmail(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.settings.update(s => ({ ...s, email: value }));
    this.checkChanges();
  }

  saveSettings() {
    // Сохранение настроек
    this.originalSettings = { ...this.settings() };
    this.hasUnsavedChanges.set(false);
    alert('Настройки сохранены!');
  }

  private checkChanges() {
    const current = this.settings();
    const hasChanges = 
      current.name !== this.originalSettings.name ||
      current.email !== this.originalSettings.email;
    
    this.hasUnsavedChanges.set(hasChanges);
  }

  canDeactivate(): Observable<boolean> | Promise<boolean> | boolean {
    if (!this.hasUnsavedChanges()) {
      return true;
    }

    const confirmation = confirm(
      'У вас есть несохраненные изменения. Вы уверены, что хотите уйти?'
    );
    
    return confirmation;
  }
}
```

**Навигационное меню:**
```typescript
// navigation.component.ts
import { Component, inject, computed } from '@angular/core';
import { Router, RouterLink, RouterLinkActive } from '@angular/router';
import { CommonModule } from '@angular/common';
import { AuthService } from '../../core/services/auth.service';

@Component({
  selector: 'app-navigation',
  template: `
    <nav class="navbar">
      <div class="nav-brand">
        <a routerLink="/home">MyApp</a>
      </div>
      
      <ul class="nav-links">
        <li><a routerLink="/home" routerLinkActive="active">Главная</a></li>
        
        @if (authService.authenticated()) {
          <li><a routerLink="/profile" routerLinkActive="active">Профиль</a></li>
          <li><a routerLink="/products" routerLinkActive="active">Продукты</a></li>
          
          @if (isAdmin()) {
            <li><a routerLink="/admin" routerLinkActive="active">Админка</a></li>
          }
          
          <li><a routerLink="/settings" routerLinkActive="active">Настройки</a></li>
          <li><button (click)="logout()">Выйти ({{ userName() }})</button></li>
        } @else {
          <li><a routerLink="/login" routerLinkActive="active">Войти</a></li>
          <li><a routerLink="/register" routerLinkActive="active">Регистрация</a></li>
        }
      </ul>
    </nav>
  `,
  styles: [`
    .navbar {
      display: flex;
      justify-content: space-between;
      padding: 1rem;
      background: #f5f5f5;
      border-bottom: 1px solid #ddd;
    }
    
    .nav-links {
      display: flex;
      list-style: none;
      gap: 1rem;
      margin: 0;
      padding: 0;
    }
    
    .active {
      color: blue;
      font-weight: bold;
    }
  `],
  standalone: true,
  imports: [CommonModule, RouterLink, RouterLinkActive]
})
export class NavigationComponent {
  private authService = inject(AuthService);
  private router = inject(Router);

  isAdmin = computed(() => this.authService.hasRole('admin'));
  userName = computed(() => this.authService.user()?.name || '');

  logout() {
    this.authService.logout();
    this.router.navigate(['/home']);
  }
}
```

**Сервис для управления навигацией:**
```typescript
// navigation.service.ts
import { Injectable, inject } from '@angular/core';
import { Router, NavigationEnd } from '@angular/router';
import { filter } from 'rxjs/operators';

@Injectable({
  providedIn: 'root'
})
export class NavigationService {
  private router = inject(Router);
  private previousUrl: string = '';
  private currentUrl: string = '';

  constructor() {
    this.currentUrl = this.router.url;
    
    this.router.events
      .pipe(filter(event => event instanceof NavigationEnd))
      .subscribe((event: NavigationEnd) => {
        this.previousUrl = this.currentUrl;
        this.currentUrl = event.url;
      });
  }

  getPreviousUrl(): string {
    return this.previousUrl;
  }

  goBack(): void {
    this.router.navigateByUrl(this.previousUrl);
  }

  navigateToLogin(returnUrl?: string): void {
    const url = returnUrl || this.currentUrl;
    this.router.navigate(['/login'], { 
      queryParams: { returnUrl: url } 
    });
  }
}
```

---

### **Резюме**

*   **Маршрутизация** - основа SPA приложений в Angular
*   **RouterOutlet** - контейнер для компонентов маршрутов
*   **RouterLink** - декларативная навигация
*   **Lazy Loading** - оптимизация загрузки приложения
*   **Guards** - защита маршрутов и бизнес-логика:
    - `CanActivate` - доступ к маршруту
    - `CanActivateChild` - доступ к дочерним маршрутам  
    - `CanDeactivate` - подтверждение ухода
    - `CanLoad` - загрузка модулей
    - `Resolve` - предзагрузка данных

**Лучшие практики:**
- Используйте lazy loading для больших приложений
- Защищайте маршруты guards
- Разделяйте публичные и приватные маршруты
- Используйте Resolve для улучшения UX
- Обрабатывайте ошибки навигации

---

### **Контрольные вопросы:**

1.  В чем разница между `routerLink` и программной навигацией?
2.  Как реализовать lazy loading для feature module?
3.  Когда использовать `CanActivate` vs `CanLoad`?
4.  Как передать данные между маршрутами?
5.  Как реализовать многоуровневую систему прав доступа?
6.  Что такое `RouterLinkActive` и для чего он используется?
7.  Как обработать несуществующий маршрут (404)?
8.  В чем разница между `pathMatch: 'full'` и `pathMatch: 'prefix'`?
9.  Как организовать навигационную цепочку (breadcrumbs)?
10. Как тестировать guards и маршруты?