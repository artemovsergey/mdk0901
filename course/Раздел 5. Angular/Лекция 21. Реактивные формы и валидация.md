# Лекция: Реактивные формы и валидация в Angular

**Цель лекции:** Научиться создавать сложные формы с использованием Reactive Forms API, реализовывать кастомную валидацию и управлять состоянием формы программно.

---

### **План лекции:**

1.  **Введение: Реактивные формы vs Template-driven формы**
    *   Сравнение подходов.
    *   Когда что использовать.

2.  **Основы Reactive Forms**
    *   `FormGroup`, `FormControl`, `FormArray`.
    *   Создание формы программно.
    *   Привязка формы к шаблону.

3.  **Валидация форм**
    *   Встроенные валидаторы.
    *   Кастомные валидаторы.
    *   Валидация нескольких полей.
    *   Валидация FormArray.

4.  **Работа с состоянием формы**
    *   Отслеживание состояния (`valid`, `invalid`, `touched`, `dirty`).
    *   Обработка сабмита.
    *   Сброс и установка значений.

5.  **Продвинутые техники**
    *   Динамическое добавление/удаление полей.
    *   Валидация асинхронными валидаторами.
    *   Кастомные компоненты форм (ControlValueAccessor).

6.  **Практика: Создание формы регистрации**
    *   Многошаговая форма.
    *   Валидация пароля.
    *   Валидация условий использования.

---

### **Детальное рассмотрение каждого пункта плана:**

#### **1. Введение: Реактивные формы vs Template-driven формы**

**Template-driven формы** (упрощенные):
```html
<!-- Просто, но ограничено -->
<form #form="ngForm" (ngSubmit)="onSubmit(form)">
  <input name="email" ngModel required email>
  <input name="password" ngModel required minlength="6">
  <button type="submit">Отправить</button>
</form>
```

**Reactive формы** (мощные и гибкие):
```typescript
// Полный контроль над формой
export class MyComponent {
  myForm = new FormGroup({
    email: new FormControl('', [Validators.required, Validators.email]),
    password: new FormControl('', [Validators.required, Validators.minLength(6)])
  });

  onSubmit() {
    if (this.myForm.valid) {
      console.log(this.myForm.value);
    }
  }
}
```

**Когда что использовать:**
- **Template-driven** - простые формы, быстрый прототип
- **Reactive forms** - сложные формы, динамические поля, кастомная валидация

---

#### **2. Основы Reactive Forms**

**Импорт модуля:**
```typescript
// app.module.ts или в standalone компоненте
import { ReactiveFormsModule } from '@angular/forms';

@NgModule({
  imports: [
    ReactiveFormsModule
  ]
})
```

**Создание формы:**
```typescript
import { Component } from '@angular/core';
import { FormGroup, FormControl, Validators } from '@angular/forms';

@Component({
  selector: 'app-user-form',
  template: `
    <form [formGroup]="userForm" (ngSubmit)="onSubmit()">
      <div>
        <label>Имя:</label>
        <input type="text" formControlName="name">
      </div>
      
      <div>
        <label>Email:</label>
        <input type="email" formControlName="email">
      </div>
      
      <div>
        <label>Возраст:</label>
        <input type="number" formControlName="age">
      </div>
      
      <button type="submit" [disabled]="!userForm.valid">Отправить</button>
    </form>
  `
})
export class UserFormComponent {
  // Создание FormGroup с FormControl элементами
  userForm = new FormGroup({
    name: new FormControl('', [Validators.required, Validators.minLength(2)]),
    email: new FormControl('', [Validators.required, Validators.email]),
    age: new FormControl(18, [Validators.min(18), Validators.max(99)])
  });

  onSubmit() {
    if (this.userForm.valid) {
      console.log('Данные формы:', this.userForm.value);
      console.log('Валидные данные:', this.userForm.getRawValue());
    }
  }
}
```

**FormArray для динамических полей:**
```typescript
// skills-form.component.ts
import { Component } from '@angular/core';
import { FormArray, FormBuilder, Validators } from '@angular/forms';

@Component({
  selector: 'app-skills-form',
  template: `
    <form [formGroup]="skillsForm" (ngSubmit)="onSubmit()">
      <div formArrayName="skills">
        <h3>Навыки:</h3>
        
        <div *ngFor="let skill of skills.controls; let i = index" 
             class="skill-row">
          <input [formControlName]="i" placeholder="Название навыка">
          <button type="button" (click)="removeSkill(i)">×</button>
        </div>
        
        <button type="button" (click)="addSkill()">+ Добавить навык</button>
      </div>
      
      <button type="submit">Сохранить</button>
    </form>
  `
})
export class SkillsFormComponent {
  // Использование FormBuilder для упрощения синтаксиса
  skillsForm = this.fb.group({
    skills: this.fb.array([
      this.fb.control('', Validators.required)
    ])
  });

  constructor(private fb: FormBuilder) {}

  get skills() {
    return this.skillsForm.get('skills') as FormArray;
  }

  addSkill() {
    this.skills.push(this.fb.control('', Validators.required));
  }

  removeSkill(index: number) {
    this.skills.removeAt(index);
  }

  onSubmit() {
    console.log('Навыки:', this.skills.value);
  }
}
```

---

#### **3. Валидация форм**

**Встроенные валидаторы:**
```typescript
export class ValidationComponent {
  form = this.fb.group({
    // Required + минимальная длина
    username: ['', [Validators.required, Validators.minLength(3)]],
    
    // Email валидация
    email: ['', [Validators.required, Validators.email]],
    
    // Числовые валидаторы
    age: [0, [Validators.min(18), Validators.max(120)]],
    
    // Регулярные выражения
    phone: ['', [Validators.pattern(/^\+7\d{10}$/)]],
    
    // Кастомная валидация
    password: ['', [Validators.required, this.passwordValidator]]
  });

  constructor(private fb: FormBuilder) {}

  // Кастомный валидатор
  private passwordValidator(control: FormControl) {
    const value = control.value || '';
    
    if (!value) {
      return null;
    }
    
    const hasUpperCase = /[A-Z]/.test(value);
    const hasLowerCase = /[a-z]/.test(value);
    const hasNumeric = /[0-9]/.test(value);
    const hasSpecial = /[!@#$%^&*]/.test(value);
    
    const passwordValid = hasUpperCase && hasLowerCase && hasNumeric && hasSpecial;
    
    return passwordValid ? null : { passwordStrength: true };
  }
}
```

**Валидация нескольких полей (валидатор на уровне формы):**
```typescript
// custom-validators.ts
import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';

// Валидатор для проверки совпадения паролей
export function passwordMatchValidator(controlName: string, matchingControlName: string): ValidatorFn {
  return (formGroup: AbstractControl): ValidationErrors | null => {
    const password = formGroup.get(controlName);
    const confirmPassword = formGroup.get(matchingControlName);

    if (!password || !confirmPassword) {
      return null;
    }

    if (confirmPassword.errors && !confirmPassword.errors['passwordMismatch']) {
      return null;
    }

    if (password.value !== confirmPassword.value) {
      confirmPassword.setErrors({ passwordMismatch: true });
      return { passwordMismatch: true };
    } else {
      confirmPassword.setErrors(null);
      return null;
    }
  };
}

// Валидатор для даты рождения (должен быть старше 18 лет)
export function adultValidator(control: AbstractControl): ValidationErrors | null {
  const birthDate = new Date(control.value);
  const today = new Date();
  const age = today.getFullYear() - birthDate.getFullYear();
  
  if (isNaN(birthDate.getTime())) {
    return { invalidDate: true };
  }
  
  return age >= 18 ? null : { notAdult: true };
}

// Валидатор для уникальности в FormArray
export function uniqueValuesValidator(control: AbstractControl): ValidationErrors | null {
  if (!(control instanceof FormArray)) {
    return null;
  }
  
  const values = control.controls.map(c => c.value?.toLowerCase().trim());
  const duplicates = values.filter((value, index) => 
    value && values.indexOf(value) !== index
  );
  
  return duplicates.length > 0 ? { duplicateValues: true } : null;
}
```

**Использование кастомных валидаторов:**
```typescript
// registration-form.component.ts
export class RegistrationFormComponent {
  registrationForm = this.fb.group({
    username: ['', [Validators.required, Validators.minLength(3)]],
    email: ['', [Validators.required, Validators.email]],
    birthDate: ['', [Validators.required, adultValidator]],
    passwords: this.fb.group({
      password: ['', [Validators.required, Validators.minLength(8), this.passwordValidator]],
      confirmPassword: ['', Validators.required]
    }, { validators: passwordMatchValidator('password', 'confirmPassword') }),
    skills: this.fb.array([], [Validators.required, Validators.minLength(1)])
  }, { validators: this.businessLogicValidator });

  constructor(private fb: FormBuilder) {}

  private passwordValidator(control: FormControl) {
    const value = control.value || '';
    const hasUpperCase = /[A-Z]/.test(value);
    const hasLowerCase = /[a-z]/.test(value);
    const hasNumber = /[0-9]/.test(value);
    const hasSpecial = /[!@#$%^&*]/.test(value);
    
    const errors: any = {};
    if (!hasUpperCase) errors.missingUpperCase = true;
    if (!hasLowerCase) errors.missingLowerCase = true;
    if (!hasNumber) errors.missingNumber = true;
    if (!hasSpecial) errors.missingSpecial = true;
    
    return Object.keys(errors).length > 0 ? errors : null;
  }

  private businessLogicValidator(form: AbstractControl) {
    const username = form.get('username')?.value;
    const password = form.get('passwords.password')?.value;
    
    if (username && password && password.includes(username)) {
      return { passwordContainsUsername: true };
    }
    
    return null;
  }

  get skills() {
    return this.registrationForm.get('skills') as FormArray;
  }

  addSkill(skill: string = '') {
    this.skills.push(this.fb.control(skill, Validators.required));
  }

  removeSkill(index: number) {
    this.skills.removeAt(index);
  }
}
```

**Отображение ошибок в шаблоне:**
```html
<!-- registration-form.component.html -->
<form [formGroup]="registrationForm" (ngSubmit)="onSubmit()">
  
  <!-- Поле имени пользователя -->
  <div class="form-group">
    <label>Имя пользователя:</label>
    <input type="text" formControlName="username">
    
    <div class="error-messages">
      @if (registrationForm.get('username')?.hasError('required') && 
           registrationForm.get('username')?.touched) {
        <span>Имя пользователя обязательно</span>
      }
      @if (registrationForm.get('username')?.hasError('minlength')) {
        <span>Минимальная длина: 3 символа</span>
      }
    </div>
  </div>

  <!-- Группа паролей -->
  <div formGroupName="passwords">
    
    <!-- Пароль -->
    <div class="form-group">
      <label>Пароль:</label>
      <input type="password" formControlName="password">
      
      <div class="error-messages">
        @if (registrationForm.get('passwords.password')?.hasError('required')) {
          <span>Пароль обязателен</span>
        }
        @if (registrationForm.get('passwords.password')?.hasError('minlength')) {
          <span>Минимальная длина: 8 символов</span>
        }
        @if (registrationForm.get('passwords.password')?.hasError('missingUpperCase')) {
          <span>Должна быть хотя бы одна заглавная буква</span>
        }
        @if (registrationForm.get('passwords.password')?.hasError('missingLowerCase')) {
          <span>Должна быть хотя бы одна строчная буква</span>
        }
        @if (registrationForm.get('passwords.password')?.hasError('missingNumber')) {
          <span>Должна быть хотя бы одна цифра</span>
        }
        @if (registrationForm.get('passwords.password')?.hasError('missingSpecial')) {
          <span>Должен быть хотя бы один специальный символ</span>
        }
      </div>
    </div>

    <!-- Подтверждение пароля -->
    <div class="form-group">
      <label>Подтвердите пароль:</label>
      <input type="password" formControlName="confirmPassword">
      
      <div class="error-messages">
        @if (registrationForm.get('passwords.confirmPassword')?.hasError('required')) {
          <span>Подтверждение пароля обязательно</span>
        }
        @if (registrationForm.get('passwords')?.hasError('passwordMismatch') && 
             registrationForm.get('passwords.confirmPassword')?.touched) {
          <span>Пароли не совпадают</span>
        }
      </div>
    </div>
  </div>

  <!-- Ошибки уровня формы -->
  <div class="form-level-errors">
    @if (registrationForm.hasError('passwordContainsUsername')) {
      <span>Пароль не должен содержать имя пользователя</span>
    }
  </div>

  <button type="submit" [disabled]="!registrationForm.valid">
    Зарегистрироваться
  </button>
</form>
```

---

#### **4. Работа с состоянием формы**

**Отслеживание состояния:**
```typescript
export class FormStateComponent {
  userForm = this.fb.group({
    name: ['', Validators.required],
    email: ['', [Validators.required, Validators.email]]
  });

  constructor(private fb: FormBuilder) {}

  // Геттеры для удобства
  get name() { return this.userForm.get('name'); }
  get email() { return this.userForm.get('email'); }

  // Методы для работы с формой
  logFormState() {
    console.log('Valid:', this.userForm.valid);
    console.log('Invalid:', this.userForm.invalid);
    console.log('Pending:', this.userForm.pending);
    console.log('Dirty:', this.userForm.dirty);
    console.log('Pristine:', this.userForm.pristine);
    console.log('Touched:', this.userForm.touched);
    console.log('Untouched:', this.userForm.untouched);
  }

  // Установка значений
  populateForm() {
    this.userForm.setValue({
      name: 'Иван Иванов',
      email: 'ivan@example.com'
    });
  }

  // Частичное обновление
  updateForm() {
    this.userForm.patchValue({
      name: 'Петр'
    });
  }

  // Сброс формы
  resetForm() {
    this.userForm.reset();
  }

  // Валидация отдельных полей
  validateField(fieldName: string) {
    const control = this.userForm.get(fieldName);
    if (control) {
      control.markAsTouched();
      control.updateValueAndValidity();
    }
  }
}
```

**Улучшенный шаблон с отображением состояния:**
```html
<form [formGroup]="userForm" (ngSubmit)="onSubmit()">
  
  <div class="form-group" 
       [class.valid]="name?.valid"
       [class.invalid]="name?.invalid"
       [class.touched]="name?.touched"
       [class.untouched]="name?.untouched"
       [class.dirty]="name?.dirty"
       [class.pristine]="name?.pristine">
    
    <label>Имя:</label>
    <input type="text" formControlName="name">
    
    <div class="field-state">
      <span [class.valid]="name?.valid" [class.error]="name?.invalid">
        {{ name?.valid ? '✓' : '✗' }}
      </span>
      
      @if (name?.invalid && name?.touched) {
        <div class="error-message">
          Имя обязательно для заполнения
        </div>
      }
    </div>
  </div>

  <div class="form-actions">
    <button type="submit" [disabled]="!userForm.valid">
      Отправить
    </button>
    
    <button type="button" (click)="populateForm()">
      Заполнить тестовыми данными
    </button>
    
    <button type="button" (click)="resetForm()">
      Сбросить
    </button>
  </div>

  <!-- Отладочная информация -->
  <div class="debug-info">
    <h4>Состояние формы:</h4>
    <p>Valid: {{ userForm.valid }}</p>
    <p>Invalid: {{ userForm.invalid }}</p>
    <p>Dirty: {{ userForm.dirty }}</p>
    <p>Pristine: {{ userForm.pristine }}</p>
    <p>Touched: {{ userForm.touched }}</p>
    <p>Untouched: {{ userForm.untouched }}</p>
  </div>
</form>
```

---

#### **5. Продвинутые техники**

**Асинхронные валидаторы:**
```typescript
// async-validators.ts
import { AbstractControl, AsyncValidatorFn, ValidationErrors } from '@angular/forms';
import { Observable, of } from 'rxjs';
import { map, catchError, debounceTime, switchMap } from 'rxjs/operators';

// Валидатор для проверки уникальности email на сервере
export function uniqueEmailValidator(apiService: any): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value) {
      return of(null);
    }

    return of(control.value).pipe(
      debounceTime(500), // Ждем 500ms после последнего ввода
      switchMap(email => 
        apiService.checkEmailExists(email).pipe(
          map(exists => exists ? { emailExists: true } : null),
          catchError(() => of(null)) // В случае ошибки считаем валидным
        )
      )
    );
  };
}

// Валидатор для проверки имени пользователя
export function usernameValidator(apiService: any): AsyncValidatorFn {
  return (control: AbstractControl): Observable<ValidationErrors | null> => {
    if (!control.value || control.value.length < 3) {
      return of(null);
    }

    return of(control.value).pipe(
      debounceTime(500),
      switchMap(username =>
        apiService.checkUsername(username).pipe(
          map(response => {
            if (response.exists) {
              return { usernameTaken: true };
            }
            if (response.inappropriate) {
              return { inappropriateUsername: true };
            }
            return null;
          }),
          catchError(() => of(null))
        )
      )
    );
  };
}
```

**Использование асинхронных валидаторов:**
```typescript
export class AsyncValidationComponent {
  signupForm = this.fb.group({
    username: ['', 
      [Validators.required, Validators.minLength(3)], 
      [this.usernameValidator.bind(this)]
    ],
    email: ['', 
      [Validators.required, Validators.email], 
      [this.emailValidator.bind(this)]
    ]
  });

  constructor(
    private fb: FormBuilder,
    private apiService: ApiService
  ) {}

  private emailValidator(control: AbstractControl) {
    return uniqueEmailValidator(this.apiService)(control);
  }

  private usernameValidator(control: AbstractControl) {
    return usernameValidator(this.apiService)(control);
  }

  get username() { return this.signupForm.get('username'); }
  get email() { return this.signupForm.get('email'); }
}
```

```html
<!-- async-validation.component.html -->
<form [formGroup]="signupForm">
  <div class="form-group">
    <label>Имя пользователя:</label>
    <input type="text" formControlName="username">
    
    <div class="field-state">
      @if (username?.pending) {
        <span class="pending">⏳ Проверка...</span>
      }
      @if (username?.hasError('usernameTaken')) {
        <span class="error">Это имя пользователя уже занято</span>
      }
      @if (username?.hasError('inappropriateUsername')) {
        <span class="error">Недопустимое имя пользователя</span>
      }
    </div>
  </div>

  <div class="form-group">
    <label>Email:</label>
    <input type="email" formControlName="email">
    
    <div class="field-state">
      @if (email?.pending) {
        <span class="pending">⏳ Проверка...</span>
      }
      @if (email?.hasError('emailExists')) {
        <span class="error">Этот email уже зарегистрирован</span>
      }
    </div>
  </div>
</form>
```

---

#### **6. Практика: Создание формы регистрации**

**Полная многошаговая форма регистрации:**
```typescript
// multi-step-form.component.ts
import { Component, signal, computed } from '@angular/core';
import { FormBuilder, Validators, AbstractControl } from '@angular/forms';

@Component({
  selector: 'app-multi-step-form',
  templateUrl: './multi-step-form.component.html'
})
export class MultiStepFormComponent {
  // Текущий шаг
  currentStep = signal(1);
  totalSteps = 3;
  
  // Вычисляемые свойства
  isFirstStep = computed(() => this.currentStep() === 1);
  isLastStep = computed(() => this.currentStep() === this.totalSteps);
  progress = computed(() => (this.currentStep() / this.totalSteps) * 100);

  // Основная форма
  registrationForm = this.fb.group({
    // Шаг 1: Основная информация
    personalInfo: this.fb.group({
      firstName: ['', [Validators.required, Validators.minLength(2)]],
      lastName: ['', [Validators.required, Validators.minLength(2)]],
      email: ['', [Validators.required, Validators.email]],
      phone: ['', [Validators.pattern(/^\+7\d{10}$/)]]
    }),
    
    // Шаг 2: Учетные данные
    accountInfo: this.fb.group({
      username: ['', [Validators.required, Validators.minLength(3)]],
      passwords: this.fb.group({
        password: ['', [Validators.required, Validators.minLength(8), this.passwordValidator]],
        confirmPassword: ['', Validators.required]
      }, { validators: this.passwordMatchValidator })
    }),
    
    // Шаг 3: Дополнительная информация
    additionalInfo: this.fb.group({
      birthDate: ['', [Validators.required, this.adultValidator]],
      occupation: [''],
      interests: this.fb.array([]),
      acceptTerms: [false, Validators.requiredTrue]
    })
  });

  constructor(private fb: FormBuilder) {}

  // Геттеры для удобства
  get personalInfo() { return this.registrationForm.get('personalInfo'); }
  get accountInfo() { return this.registrationForm.get('accountInfo'); }
  get additionalInfo() { return this.registrationForm.get('additionalInfo'); }
  get interests() { return this.additionalInfo?.get('interests') as FormArray; }

  // Валидаторы
  private passwordValidator(control: AbstractControl) {
    const value = control.value || '';
    const errors: any = {};
    
    if (!/(?=.*[a-z])/.test(value)) errors.missingLowerCase = true;
    if (!/(?=.*[A-Z])/.test(value)) errors.missingUpperCase = true;
    if (!/(?=.*[0-9])/.test(value)) errors.missingNumber = true;
    if (!/(?=.*[!@#$%^&*])/.test(value)) errors.missingSpecial = true;
    
    return Object.keys(errors).length > 0 ? errors : null;
  }

  private passwordMatchValidator(group: AbstractControl) {
    const password = group.get('password')?.value;
    const confirmPassword = group.get('confirmPassword')?.value;
    return password === confirmPassword ? null : { passwordMismatch: true };
  }

  private adultValidator(control: AbstractControl) {
    const birthDate = new Date(control.value);
    if (isNaN(birthDate.getTime())) return { invalidDate: true };
    
    const age = new Date().getFullYear() - birthDate.getFullYear();
    return age >= 18 ? null : { notAdult: true };
  }

  // Методы для интересов
  addInterest(interest: string = '') {
    this.interests.push(this.fb.control(interest, Validators.required));
  }

  removeInterest(index: number) {
    this.interests.removeAt(index);
  }

  // Навигация по шагам
  nextStep() {
    if (this.validateCurrentStep()) {
      this.currentStep.update(step => Math.min(step + 1, this.totalSteps));
    }
  }

  prevStep() {
    this.currentStep.update(step => Math.max(step - 1, 1));
  }

  private validateCurrentStep(): boolean {
    switch (this.currentStep()) {
      case 1:
        this.personalInfo?.markAllAsTouched();
        return this.personalInfo?.valid || false;
      case 2:
        this.accountInfo?.markAllAsTouched();
        return this.accountInfo?.valid || false;
      case 3:
        this.additionalInfo?.markAllAsTouched();
        return this.additionalInfo?.valid || false;
      default:
        return false;
    }
  }

  // Отправка формы
  onSubmit() {
    this.registrationForm.markAllAsTouched();
    
    if (this.registrationForm.valid) {
      console.log('Форма отправлена:', this.registrationForm.value);
      // Отправка данных на сервер
    } else {
      console.log('Форма содержит ошибки');
    }
  }

  // Сброс формы
  resetForm() {
    this.registrationForm.reset();
    this.currentStep.set(1);
  }
}
```

**Шаблон многошаговой формы:**
```html
<!-- multi-step-form.component.html -->
<div class="multi-step-form">
  <!-- Прогресс-бар -->
  <div class="progress-bar">
    <div class="progress" [style.width.%]="progress()"></div>
  </div>

  <!-- Шаги формы -->
  <form [formGroup]="registrationForm" (ngSubmit)="onSubmit()">
    
    <!-- Шаг 1: Основная информация -->
    @if (currentStep() === 1) {
      <div class="form-step">
        <h2>Основная информация</h2>
        
        <div formGroupName="personalInfo">
          <div class="form-group">
            <label>Имя *</label>
            <input type="text" formControlName="firstName">
            @if (personalInfo?.get('firstName')?.hasError('required') && 
                 personalInfo?.get('firstName')?.touched) {
              <span class="error">Имя обязательно</span>
            }
          </div>

          <div class="form-group">
            <label>Фамилия *</label>
            <input type="text" formControlName="lastName">
            @if (personalInfo?.get('lastName')?.hasError('required') && 
                 personalInfo?.get('lastName')?.touched) {
              <span class="error">Фамилия обязательна</span>
            }
          </div>

          <div class="form-group">
            <label>Email *</label>
            <input type="email" formControlName="email">
            @if (personalInfo?.get('email')?.hasError('email') && 
                 personalInfo?.get('email')?.touched) {
              <span class="error">Неверный формат email</span>
            }
          </div>

          <div class="form-group">
            <label>Телефон</label>
            <input type="tel" formControlName="phone" placeholder="+71234567890">
            @if (personalInfo?.get('phone')?.hasError('pattern')) {
              <span class="error">Формат: +71234567890</span>
            }
          </div>
        </div>
      </div>
    }

    <!-- Шаг 2: Учетные данные -->
    @if (currentStep() === 2) {
      <div class="form-step">
        <h2>Учетные данные</h2>
        
        <div formGroupName="accountInfo">
          <div class="form-group">
            <label>Имя пользователя *</label>
            <input type="text" formControlName="username">
          </div>

          <div formGroupName="passwords">
            <div class="form-group">
              <label>Пароль *</label>
              <input type="password" formControlName="password">
              
              <div class="password-requirements">
                <span [class.met]="!accountInfo?.get('passwords.password')?.hasError('missingUpperCase')">
                  Заглавная буква
                </span>
                <span [class.met]="!accountInfo?.get('passwords.password')?.hasError('missingLowerCase')">
                  Строчная буква
                </span>
                <span [class.met]="!accountInfo?.get('passwords.password')?.hasError('missingNumber')">
                  Цифра
                </span>
                <span [class.met]="!accountInfo?.get('passwords.password')?.hasError('missingSpecial')">
                  Спецсимвол
                </span>
              </div>
            </div>

            <div class="form-group">
              <label>Подтвердите пароль *</label>
              <input type="password" formControlName="confirmPassword">
              @if (accountInfo?.get('passwords')?.hasError('passwordMismatch')) {
                <span class="error">Пароли не совпадают</span>
              }
            </div>
          </div>
        </div>
      </div>
    }

    <!-- Шаг 3: Дополнительная информация -->
    @if (currentStep() === 3) {
      <div class="form-step">
        <h2>Дополнительная информация</h2>
        
        <div formGroupName="additionalInfo">
          <div class="form-group">
            <label>Дата рождения *</label>
            <input type="date" formControlName="birthDate">
            @if (additionalInfo?.get('birthDate')?.hasError('notAdult')) {
              <span class="error">Вам должно быть больше 18 лет</span>
            }
          </div>

          <div class="form-group">
            <label>Профессия</label>
            <input type="text" formControlName="occupation">
          </div>

          <div class="form-group">
            <label>Интересы</label>
            <div formArrayName="interests">
              @for (interest of interests.controls; track i; let i = $index) {
                <div class="interest-row">
                  <input [formControlName]="i" placeholder="Ваш интерес">
                  <button type="button" (click)="removeInterest(i)">×</button>
                </div>
              }
              <button type="button" (click)="addInterest()">+ Добавить интерес</button>
            </div>
          </div>

          <div class="form-group checkbox-group">
            <label>
              <input type="checkbox" formControlName="acceptTerms">
              Я принимаю условия использования *
            </label>
            @if (additionalInfo?.get('acceptTerms')?.hasError('required') && 
                 additionalInfo?.get('acceptTerms')?.touched) {
              <span class="error">Необходимо принять условия</span>
            }
          </div>
        </div>
      </div>
    }

    <!-- Навигация -->
    <div class="form-navigation">
      @if (!isFirstStep()) {
        <button type="button" (click)="prevStep()">Назад</button>
      }
      
      @if (!isLastStep()) {
        <button type="button" (click)="nextStep()">Далее</button>
      } @else {
        <button type="submit" [disabled]="!registrationForm.valid">
          Зарегистрироваться
        </button>
      }
    </div>
  </form>
</div>
```

---

### **Резюме**

*   **Reactive Forms** - мощный API для сложных форм
*   **FormGroup, FormControl, FormArray** - основные строительные блоки
*   **Валидаторы** - встроенные и кастомные для проверки данных
*   **Состояние формы** - отслеживание valid/invalid, touched/untouched, dirty/pristine
*   **Асинхронные валидаторы** - для проверок на сервере
*   **FormBuilder** - упрощает создание форм
*   **Многошаговые формы** - для лучшего пользовательского опыта

**Лучшие практики:**
- Используйте Reactive Forms для сложных форм
- Создайте кастомные валидаторы для бизнес-правил
- Используйте FormArray для динамических полей
- Обрабатывайте асинхронные валидации с debounce
- Предоставляйте понятные сообщения об ошибках

---

### **Контрольные вопросы:**

1.  В чем основные различия между Template-driven и Reactive forms?
2.  Как создать кастомный валидатор для проверки пароля?
3.  Как валидировать несколько взаимосвязанных полей (например, пароль и подтверждение)?
4.  Что такое FormArray и когда его следует использовать?
5.  Как реализовать асинхронную валидацию email на сервере?
6.  Какие методы используются для установки значений в форму (setValue vs patchValue)?
7.  Как отслеживать состояние отдельных полей формы?
8.  Что такое ControlValueAccessor и для чего он используется?
9.  Как реализовать многошаговую форму с раздельной валидацией шагов?
10. Как тестировать формы с кастомными валидаторами?