# Лекция 16. Компоненты и шаблоны. Привязка данных в Angular

**Цель лекции:** глубоко понять основную единицу Angular - компонент. Научиться создавать шаблоны и освоить все способы взаимодействия между TypeScript-логикой компонента и его HTML-представлением через привязку данных.
---

### **План лекции:**

1.  **Компоненты: Глубже взгляд**
    *   Декоратор `@Component` и его свойства.
    *   Жизненный цикл компонента (основные хуки).
    *   Инкапсуляция стилей.

2.  **Шаблоны: Не просто HTML**
    *   Интерполяция `{{ }}`.
    *   Шаблонные выражения и операторы.
    *   Безопасность в шаблонах.

3.  **Привязка данных: Связь между классом и шаблоном**
    *   **Односторонняя привязка:**
        *   Интерполяция: `{{expression}}`.
        *   Привязка свойства: `[property]="expression"`.
        *   Привязка атрибута: `[attr.attribute-name]="expression"`.
        *   Привязка класса: `[class.class-name]="condition"`.
        *   Привязка стиля: `[style.style-property]="expression"`.
    *   **Привязка событий: `(event)="handler()"`.**
    *   **Двусторонняя привязка: `[(ngModel)]="property"`.**
    *   Сравнительная таблица всех видов привязки.

4.  **Практика: Создание компонента "Счетчик" и "Форма пользователя"**
    *   Применяем все изученные виды привязки на практике.

---

### **Детальное рассмотрение каждого пункта плана:**

#### **1. Компоненты: Глубже взгляд**

**Декоратор `@Component` и его свойства:**
Декоратор - это функция, которая добавляет метаданные к классу. Для компонента это конфигурация.

```typescript
import { Component } from '@angular/core';

@Component({
  selector: 'app-user-profile', // HTML-тег для этого компонента
  templateUrl: './user-profile.component.html', // Путь к HTML-шаблону
  // template: `<h1>Инлайн-шаблон</h1>`, // Альтернатива: шаблон прямо в TS
  styleUrls: ['./user-profile.component.css'], // Массив путей к CSS-файлам
  // styles: [`h1 { color: blue; }`] // Альтернатива: стили прямо в TS
  // encapsulation: ViewEncapsulation.Emulated // (По умолчанию) Стили инкапсулированы
  // encapsulation: ViewEncapsulation.None // Стили становятся глобальными
})
export class UserProfileComponent {
  userName = 'Анна';
}
```

**Жизненный цикл компонента (основные хуки):**
Жизненный цикл - это последовательность методов, которые Angular вызывает у компонента в определенные моменты его жизни.

*   `ngOnInit()`: Вызывается **один раз** после установки свойств компонента, которые были привязаны через `@Input()`. Идеальное место для начальной логики (загрузка данных из сервиса).
*   `ngOnChanges(changes: SimpleChanges)`: Вызывается до `ngOnInit()` и каждый раз, когда изменяются входные свойства (`@Input()`). Получает объект `changes` с текущими и предыдущими значениями.
*   `ngAfterViewInit()`: Вызывается один раз после инициализации представления компонента и дочерних представлений. Здесь безопасно работать с DOM-элементами через `ViewChild`/`ViewChildren`.
*   `ngOnDestroy()`: Вызывается непосредственно перед уничтожением компонента. Идеальное место для отписки от Observables, отмены таймеров, чтобы избежать утечек памяти.

**Пример с `ngOnInit` и `ngOnDestroy`:**
```typescript
export class ProductListComponent implements OnInit, OnDestroy {
  products: Product[] = [];
  private intervalId: any;

  ngOnInit() {
    console.log('Компонент инициализирован! Загружаем данные...');
    // Имитация загрузки данных
    this.loadProducts();
    
    // Пример таймера (который нужно будет очистить)
    this.intervalId = setInterval(() => {
      console.log('Таймер работает...');
    }, 1000);
  }

  ngOnDestroy() {
    console.log('Компонент уничтожается!');
    // ОЧЕНЬ ВАЖНО: очищаем таймер
    clearInterval(this.intervalId);
  }

  loadProducts() {
    // Здесь бы был HTTP-запрос
    this.products = [
      { id: 1, name: 'Телефон', inStock: true },
      { id: 2, name: 'Ноутбук', inStock: false }
    ];
  }
}
```

**Инкапсуляция стилей:**
По умолчанию Angular **эмулирует** инкапсуляцию. Он добавляет уникальные атрибуты к селекторам в CSS, чтобы стили компонента не влияли на другие компоненты.
*   `ViewEncapsulation.Emulated` (по умолчанию): Стили компонента применяются только к его шаблону.
*   `ViewEncapsulation.None`: Стили компонента становятся глобальными.
*   `ViewEncapsulation.ShadowDom`: Использует нативную технологию Shadow DOM (поддерживается не всеми браузерами).

---

#### **2. Шаблоны: Не просто HTML**

**Интерполяция `{{ }}`:**
Самый простой способ отобразить данные из класса компонента в шаблоне.

```typescript
// user-profile.component.ts
export class UserProfileComponent {
  title = 'Профиль пользователя';
  user = {
    name: 'Иван',
    age: 30
  };
  getWelcomeMessage(): string {
    return `Добро пожаловать, ${this.user.name}!`;
  }
}
```

```html
<!-- user-profile.component.html -->
<h1>{{ title }}</h1> <!-- Результат: <h1>Профиль пользователя</h1> -->
<p>Имя: {{ user.name }}</p> <!-- Результат: <p>Имя: Иван</p> -->
<p>Возраст: {{ user.age + 1 }}</p> <!-- Результат: <p>Возраст: 31</p> -->
<p>{{ getWelcomeMessage() }}</p> <!-- Результат: <p>Добро пожаловать, Иван!</p> -->
```

**Шаблонные выражения и операторы:**
Выражения внутри `{{ }}` могут содержать математические операции, вызовы методов, тернарный оператор.

```html
<p>Следующий год: {{ 2024 + 1 }}</p>
<p>Статус: {{ user.age >= 18 ? 'Взрослый' : 'Несовершеннолетний' }}</p>
```

**Безопасность в шаблонах:**
Angular автоматически **экранирует** все данные в интерполяции, чтобы предотвратить XSS-атаки.

```typescript
// В компоненте
maliciousCode = '<script>alert("XSS")</script><h1>Взлом</h1>';
```
```html
<!-- В шаблоне -->
<p>{{ maliciousCode }}</p>
<!-- На странице будет отображено как простой текст: -->
<!-- <p>&lt;script&gt;alert("XSS")&lt;/script&gt;&lt;h1&gt;Взлом&lt;/h1&gt;</p> -->
```

---

#### **3. Привязка данных: Связь между классом и шаблоном**

**Односторонняя привязка (Данные КЛАССА -> в ШАБЛОН)**

1.  **Привязка свойства `[property]="expression"`:**
    Используется для привязки данных к свойствам DOM-элементов, директивам или компонентам.

    ```typescript
    export class MyComponent {
      isDisabled = true;
      imageUrl = '/assets/logo.png';
      buttonColor = 'primary';
    }
    ```
    ```html
    <!-- Привязка к свойству DOM-элемента -->
    <button [disabled]="isDisabled">Неактивная кнопка</button>
    <img [src]="imageUrl" alt="Логотип">

    <!-- Привязка к свойству ДИРЕКТИВЫ -->
    <p [ngClass]="{'highlight': isDisabled}">Этот текст может быть выделен</p>

    <!-- Привязка к свойству ДОЧЕРНЕГО КОМПОНЕНТА (важно!) -->
    <app-child [inputData]="user"></app-child>
    ```
    *В дочернем компоненте `app-child` свойство `inputData` должно быть объявлено с декоратором `@Input()`.*

2.  **Привязка атрибута `[attr.attribute-name]="expression"`:**
    Используется, когда у элемента нет соответствующего свойства DOM (например, `aria-*`, `data-*`, `colspan`).

    ```typescript
    export class MyComponent {
      colSpan = 2;
    }
    ```
    ```html
    <!-- Без привязки атрибут установится в "colSpan", а не в 2 -->
    <td [attr.colspan]="colSpan">Объединенная ячейка</td>
    <!-- Результат в DOM: <td colspan="2">Объединенная ячейка</td> -->
    ```

3.  **Привязка класса `[class.class-name]="condition"`:**
    Динамическое добавление/удаление CSS-класса.

    ```typescript
    export class MyComponent {
      isActive = true;
      hasError = false;
    }
    ```
    ```html
    <div [class.active]="isActive" [class.text-danger]="hasError">
      Элемент с условными классами
    </div>
    <!-- Если isActive=true, а hasError=false, то в DOM будет: -->
    <!-- <div class="active">Элемент с условными классами</div> -->
    ```

4.  **Привязка стиля `[style.style-property]="expression"`:**
    Динамическое управление инлайн-стилями.

    ```typescript
    export class MyComponent {
      fontSizePx = 16;
      isWarning = true;
    }
    ```
    ```html
    <p [style.font-size.px]="fontSizePx">Текст с изменяемым размером</p>
    <button [style.background-color]="isWarning ? 'red' : 'green'">Кнопка</button>
    ```

**Привязка событий `(event)="handler()"` (ШАБЛОН -> КЛАСС)**
Используется для реагирования на действия пользователя (клик, ввод, фокус и т.д.).

```typescript
export class MyComponent {
  message = '';

  onButtonClick() {
    this.message = 'Кнопка была нажата!';
    console.log('Click!');
  }

  onInputChange(event: any) {
    // event.target.value содержит значение из поля ввода
    this.message = event.target.value;
    console.log('Введен текст:', event.target.value);
  }
}
```
```html
<button (click)="onButtonClick()">Нажми меня</button>
<input (input)="onInputChange($event)" placeholder="Введите текст">
<p>{{ message }}</p>
```
*`$event` - специальная переменная, содержащая данные о событии.*

**Двусторонняя привязка `[(ngModel)]="property"` (КЛАСС <-> ШАБЛОН)**
Комбинация привязки свойства и привязки события. Автоматически синхронизирует значение в классе компонента и значение в элементе формы.

**ВАЖНО:** Для использования `ngModel` необходимо импортировать `FormsModule` в `AppModule`.

```typescript
// app.module.ts
import { FormsModule } from '@angular/forms';

@NgModule({
  imports: [
    BrowserModule,
    FormsModule // <-- Добавляем FormsModule
  ],
  // ...
})
```
```typescript
// user-form.component.ts
export class UserFormComponent {
  userName = ''; // Начальное значение
  isSubscribed = false;
}
```
```html
<!-- user-form.component.html -->
<input type="text" [(ngModel)]="userName" placeholder="Введите имя">
<p>Привет, {{ userName }}!</p> <!-- Значение обновляется в реальном времени -->

<input type="checkbox" [(ngModel)]="isSubscribed">
<label>Подписаться на рассылку</label>
<p>Статус подписки: {{ isSubscribed ? 'Да' : 'Нет' }}</p>
```

**Как это работает "под капотом"?**
`[(ngModel)]="userName"` это **синтаксический сахар** для:
```html
<input [ngModel]="userName" (ngModelChange)="userName = $event">
```
1.  `[ngModel]="userName"` (привязка свойства) - передает значение из класса в input.
2.  `(ngModelChange)="userName = $event"` (привязка события) - обновляет значение в классе при изменении в input.

---

#### **Сравнительная таблица всех видов привязки**

| Синтаксис | Тип | Направление | Пример |
| :--- | :--- | :--- | :--- |
| `{{expression}}` | Интерполяция | Класс -> Шаблон | `<p>{{title}}</p>` |
| `[target]="expr"` | Свойство | Класс -> Шаблон | `<img [src]="imageUrl">` |
| `(target)="stmt"` | Событие | Шаблон -> Класс | `<button (click)="save()">` |
| `[(target)]="expr"` | Двусторонняя | Класс <-> Шаблон | `<input [(ngModel)]="name">` |

---

#### **4. Практика: Создание компонента "Счетчик" и "Форма пользователя"**

**Компонент "Счетчик" (app-counter):**
```typescript
// counter.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-counter',
  templateUrl: './counter.component.html',
  styleUrls: ['./counter.component.css']
})
export class CounterComponent {
  count = 0;

  increment() {
    this.count++;
  }

  decrement() {
    this.count--;
  }

  reset() {
    this.count = 0;
  }
}
```

```html
<!-- counter.component.html -->
<h2>Счетчик: {{ count }}</h2>
<button (click)="increment()">+1</button>
<button (click)="decrement()">-1</button>
<button (click)="reset()">Сбросить</button>

<!-- Динамическое изменение стиля в зависимости от значения -->
<p [style.color]="count > 0 ? 'green' : (count < 0 ? 'red' : 'black')">
  Текущее значение: {{ count }}
</p>
```

**Компонент "Форма пользователя" (app-user-form):**
```typescript
// user-form.component.ts
import { Component } from '@angular/core';

@Component({
  selector: 'app-user-form',
  templateUrl: './user-form.component.html',
  styleUrls: ['./user-form.component.css']
})
export class UserFormComponent {
  user = {
    name: '',
    email: '',
    subscription: 'basic'
  };

  onSubmit() {
    // В реальном приложении здесь бы был HTTP-запрос
    console.log('Данные формы:', this.user);
    alert(`Пользователь ${this.user.name} успешно зарегистрирован!`);
  }
}
```

```html
<!-- user-form.component.html -->
<h2>Регистрация пользователя</h2>
<form (ngSubmit)="onSubmit()">
  <div>
    <label>Имя:</label>
    <input type="text" [(ngModel)]="user.name" name="name" required>
    <span>Вы ввели: {{ user.name }}</span>
  </div>

  <div>
    <label>Email:</label>
    <input type="email" [(ngModel)]="user.email" name="email" required>
  </div>

  <div>
    <label>Тип подписки:</label>
    <select [(ngModel)]="user.subscription" name="subscription">
      <option value="basic">Базовый</option>
      <option value="pro">Профессиональный</option>
      <option value="premium">Премиум</option>
    </select>
  </div>

  <button type="submit" [disabled]="!user.name || !user.email">Зарегистрировать</button>
</form>

<!-- Отладочная информация -->
<div>
  <h3>Отладочная информация (JSON):</h3>
  <pre>{{ user | json }}</pre>
</div>
```

---

### **Резюме**

*   **Компонент** - это основная строительная единица Angular, состоящая из класса, шаблона и стилей.
*   **Шаблоны** используют расширенный HTML с директивами и привязками данных.
*   **Привязка данных** - это механизм взаимодействия между классом компонента и его шаблоном.
    *   `{{ }}` и `[]` - данные ИЗ класса в шаблон.
    *   `()` - действия ИЗ шаблона в класс (события).
    *   `[()]` - двусторонняя синхронизация (чаще всего с формами).
*   **`ngModel`** упрощает работу с формами, но требует импорта `FormsModule`.
*   Понимание жизненного цикла компонента (`ngOnInit`, `ngOnDestroy`) критически важно для правильной работы с данными и ресурсами.

---

### **Контрольные вопросы:**

1.  Опишите, из каких трех частей состоит компонент Angular.
2.  В чем разница между привязкой свойства `[src]` и привязкой атрибута `[attr.src]`? Когда какую использовать?
3.  Какой метод жизненного цикла лучше всего подходит для загрузки начальных данных с сервера? Почему?
4.  Что произойдет, если в шаблоне использовать интерполяцию `{{ maliciousScript }}`, где `maliciousScript` содержит строку `<script>alert('XSS')</script>`? Почему?
5.  Объясните, как директива `[(ngModel)]` работает "под капотом". Какие две привязки она объединяет?
6.  Как сделать кнопку неактивной, если поле ввода пустое? Покажите пример кода.
7.  Что такое инкапсуляция стилей в Angular и зачем она нужна?
8.  В чем ключевое отличие привязки события `(click)` от вызова функции в интерполяции `{{ doSomething() }}`?
9.  Как динамически добавить CSS-класс `active` к элементу `div` в зависимости от значения переменной `isActive` в классе компонента?
10. Почему важно отписываться от подписок (например, в `ngOnDestroy`) и какие проблемы могут возникнуть, если этого не делать?