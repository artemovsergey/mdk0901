# Лекция. Entity Framework Core

**Цель:** Дать глубокое понимание архитектуры, возможностей и лучших практик использования Entity Framework Core (EF Core) в реальных проектах.

---

### **План лекции:**

1.  **Введение в ORM и Entity Framework Core**
    *   Что такое проблема объектно-реляционного импеданса?
    *   Что такое ORM? Зачем он нужен?
    *   Краткая история EF: от Entity Framework к EF Core.
    *   Основные компоненты EF Core: `DbContext`, `DbSet`, Модели.

2.  **Подходы к разработке: Code First, Database First, Model First**
    *   **Database First:** Генерация моделей из существующей БД.
    *   **Code First:** Создание БД на основе ваших классов (C# POCO).
    *   Почему Code First является современным стандартом?

3.  **Маппинг объектов на таблицы: Fluent API и Data Annotations**
    *   Создание простых моделей.
    *   Использование атрибутов (`[Key]`, `[Required]`, `[MaxLength]`).
    *   Мощь Fluent API: `OnModelCreating`, настройка ключей, индексов, связей.
    *   **Сравнение подходов:** Когда что использовать?

4.  **Отношения между сущностями (Relationships)**
    *   Один-к-одному (One-to-One)
    *   Один-ко-многим (One-to-Many) - самый частый случай.
    *   Многие-ко-многим (Many-to-Many) - классическая и новая (в EF Core 5+) реализация.

5.  **Работа с данными: CRUD операции**
    *   **Трекер изменений (Change Tracker):** Как EF понимает, что нужно сохранить?
    *   Добавление (`Add`, `AddRange`).
    *   Чтение (LINQ запросы, `Find`, `FirstOrDefault`, `SingleOrDefault`).
    *   Обновление (Подход "attach and modify" vs. "query and update").
    *   Удаление (`Remove`).

6.  **Запросы к данным: LINQ и не только**
    *   **LINQ to Entities:** Отложенное (`IQueryable`) и немедленное выполнение (`ToList`, `ToArray`).
    *   **Eager Loading:** `Include` и `ThenInclude` для загрузки связанных данных.
    *   **Explicit Loading:** `Load` для явной загрузки связей после факта.
    *   **Select Loading (Projection):** Загрузка только нужных полей.

7.  **Миграции (Migrations) - контроль версий для вашей БД**
    *   Что такое миграция?
    *   Жизненный цикл: Создание (`Add-Migration`), Обновление БД (`Update-Database`).
    *   Откат миграций.

8.  **Производительность и лучшие практики**
    *   Проблема N+1 и как ее избежать.
    *   **AsNoTracking()** для операций "только для чтения".
    *   Использование проекций вместо загрузки целых сущностей.
    *   Краткий обзор патерна Repository и Unit of Work (и их спорной необходимости с EF Core).

---

### **Детальное рассмотрение пунктов плана:**

#### **1. Введение в ORM и Entity Framework Core**

**Проблема импеданса:** Объектная модель (классы, наследование, поля) и реляционная модель (таблицы, столбцы, связи) устроены по-разному. Нам постоянно приходится писать код для преобразования `DataReader` в объекты и обратно. Это рутина, подверженная ошибкам.

**Решение - ORM (Object-Relational Mapper):** Это библиотека, которая автоматически связывает объекты в коде с записями в базе данных. Вы работаете с привычными классами и коллекциями, а ORM за кулисами генерирует SQL-запросы.

**Entity Framework Core:** Это современный, кроссплатформенный, легковесный и расширяемый ORM от Microsoft. Это перезапуск "старого" EF6.

**Основные компоненты:**
*   **Модель (Entity):** Обычный класс C# (POCO).
    ```csharp
    public class Blog
    {
        public int BlogId { get; set; }
        public string Url { get; set; }
        public List<Post> Posts { get; set; } = new(); // Навигационное свойство
    }
    ```
*   **DbSet:** Представляет коллекцию сущностей определенного типа в контексте. Аналог таблицы в БД.
*   **DbContext:** Ядро EF. Представляет сессию с базой данных. Позволяет выполнять запросы и сохранять изменения.
    ```csharp
    public class BloggingContext : DbContext
    {
        public DbSet<Blog> Blogs { get; set; }
        public DbSet<Post> Posts { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            // Строка подключения (в реальном приложении выносится в конфигурацию!)
            optionsBuilder.UseSqlServer(@"Server=(localdb)\mssqllocaldb;Database=MyBloggingDb;Trusted_Connection=True;");
        }
    }
    ```

---

#### **2. Подходы к разработке**

*   **Database First:** У вас есть готовая база данных. EF генерирует для вас классы-модели и `DbContext`. Полезно при работе с легаси-системами.
    *   Команда: `Scaffold-DbContext ...`
*   **Code First (Современный стандарт):** Вы пишете классы на C#, а EF создает и обновляет базу данных на их основе через **Миграции**. Это дает полный контроль над моделью данных в коде.

---

#### **3. Маппинг объектов на таблицы**

**Data Annotations:** Атрибуты прямо над свойствами класса.
```csharp
public class Blog
{
    [Key] // Указывает на первичный ключ
    public int BlogId { get; set; }

    [Required] // NOT NULL в БД
    [MaxLength(500)] // Ограничение длины
    public string Url { get; set; }

    [NotMapped] // Это свойство не будет храниться в БД
    public string LoadedFromDb { get; set; }
}
```

**Fluent API:** Более мощный и гибкий способ конфигурации. Делается в методе `OnModelCreating`.
```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .HasKey(b => b.BlogId); // Конфигурация первичного ключа

    modelBuilder.Entity<Blog>()
        .Property(b => b.Url)
        .IsRequired()
        .HasMaxLength(500);

    // Создание уникального индекса
    modelBuilder.Entity<Blog>()
        .HasIndex(b => b.Url)
        .IsUnique();
}
```
**Рекомендация:** Для простых вещей можно использовать Data Annotations. Для сложных сценариев (связи, индексы, наследование) всегда используйте Fluent API, чтобы не "засорять" модели.

---

#### **4. Отношения между сущностями**

Рассмотрим на примере **Блога (Blog)** и **Постов (Post)**.

**Один-ко-многим (One-to-Many):** Один блог имеет много постов.
```csharp
public class Blog
{
    public int BlogId { get; set; }
    public string Url { get; set; }
    // Навигационное свойство к коллекции постов
    public List<Post> Posts { get; set; } = new();
}

public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    public string Content { get; set; }

    // Внешний ключ
    public int BlogId { get; set; }
    // Навигационное свойство к одному блогу
    public Blog Blog { get; set; }
}

// Конфигурация во Fluent API (часто опциональна, т.к. EF поймет по соглашениям)
modelBuilder.Entity<Post>()
    .HasOne(p => p.Blog)        // Пост имеет одного Blog
    .WithMany(b => b.Posts)     // У Blog много постов
    .HasForeignKey(p => p.BlogId); // Указываем внешний ключ
```

**Многие-ко-многим (Many-to-Many) в EF Core 5+:** Пост может иметь много тегов, и тег может быть у многих постов. Раньше нужна была связующая таблица (Join Table), теперь EF создает ее автоматически.
```csharp
public class Post
{
    public int PostId { get; set; }
    public string Title { get; set; }
    // Навигационное свойство к коллекции тегов
    public List<Tag> Tags { get; set; } = new();
}

public class Tag
{
    public int TagId { get; set; }
    public string Text { get; set; }
    // Навигационное свойство к коллекции постов
    public List<Post> Posts { get; set; } = new();
}

// Конфигурация (опциональна, но для явности лучше указать)
modelBuilder.Entity<Post>()
    .HasMany(p => p.Tags)
    .WithMany(t => t.Posts);
```

---

#### **5. Работа с данными: CRUD операции**

```csharp
using var context = new BloggingContext();

// CREATE
var blog = new Blog { Url = "http://example.com" };
context.Blogs.Add(blog); // Сущность в состоянии "Added"
await context.SaveChangesAsync(); // Выполняется INSERT

// READ
var blogFromDb = await context.Blogs
    .FirstOrDefaultAsync(b => b.Url == "http://example.com");

// UPDATE
blogFromDb.Url = "http://updated.com"; // Трекер изменений отметил сущность как "Modified"
await context.SaveChangesAsync(); // Выполняется UPDATE

// DELETE
context.Blogs.Remove(blogFromDb); // Сущность в состоянии "Deleted"
await context.SaveChangesAsync(); // Выполняется DELETE
```
**Ключевой момент:** `SaveChanges()` - атомарная операция. Все изменения в рамках одного `DbContext` будут применены в одной транзакции.

---

#### **6. Запросы к данным**

**Отложенное выполнение (Deferred Execution):**
```csharp
// Запрос еще не выполнен! Создан только IQueryable.
var query = context.Blogs.Where(b => b.Url.Contains("dotnet"));

// Запрос выполняется ТОЛЬКО здесь, при итерации или вызове ToList, ToArray и т.д.
var blogs = query.ToList();
```

**Жадная загрузка (Eager Loading):** Загружаем блог и ВСЕ его посты сразу.
```csharp
var blogsWithPosts = await context.Blogs
    .Include(b => b.Posts) // Генерирует JOIN с таблицей Posts
    .ThenInclude(p => p.Tags) // Если нужно загрузить дальше, теги постов
    .ToListAsync();
```

**Проблема N+1 (Явный пример плохого кода):**
```csharp
var blogs = await context.Blogs.ToListAsync(); // 1 запрос: получить все блоги

foreach (var blog in blogs)
{
    // Для КАЖДОГО блога выполняется новый запрос к БД!
    var posts = await context.Posts
                        .Where(p => p.BlogId == blog.BlogId)
                        .ToListAsync();
    // Итого: 1 (за блоги) + N (за посты для каждого блога) запросов. Ужасно для производительности!
}
```
**Решение:** Всегда используйте `Include` для загрузки связанных данных, которые вам понадобятся в цикле.

**Проекция (Select Loading):** Забираем только те данные, которые нужны.
```csharp
var blogTitles = await context.Blogs
    .Where(b => b.Url.Contains("dotnet"))
    .Select(b => new { b.BlogId, b.Url }) // Не загружаем всю сущность, только 2 поля
    .ToListAsync();
```

---

#### **7. Миграции**

Миграция - это файл кода, который описывает изменения модели данных.

1.  **Вносим изменение в модель:** Добавляем свойство `int Rating` в класс `Blog`.
2.  **Создаем миграцию:**
    ```bash
    Add-Migration AddRatingToBlog
    ```
    EF сравнивает текущую модель с предыдущей и генерирует класс `AddRatingToBlog` с методами `Up()` (добавить столбец) и `Down()` (удалить столбец).
3.  **Обновляем базу данных:**
    ```bash
    Update-Database
    ```
    EF применяет миграцию к БД.

---

#### **8. Производительность и лучшие практики**

*   **`AsNoTracking()`:** Говорит EF не отслеживать изменения у загруженных сущностей. Значительно ускоряет запросы "только для чтения".
    ```csharp
    var blogs = await context.Blogs.AsNoTracking().ToListAsync();
    ```
*   **Всегда используйте асинхронные методы:** `ToListAsync()`, `SaveChangesAsync()` и т.д., чтобы не блокировать потоки.
*   **Решайте проблему N+1:** С помощью `Include` и проекций.
*   **Патерн Repository/Unit of Work:** В современных версиях EF Core `DbContext` уже реализует Unit of Work, а `DbSet` - Repository. Создание дополнительных абстракций поверх них часто является избыточным усложнением (Over-engineering).

---

### **Резюме**

*   **EF Core** - это мощный, гибкий и кроссплатформенный ORM.
*   **Code First** с миграциями - рекомендованный подход для новых проектов.
*   **Fluent API** дает максимальный контроль над маппингом.
*   Понимание **связей** и способов загрузки данных (`Include`, проекции) критически важно.
*   **Трекер изменений** - это "магия", которая позволяет работать с данными как с объектами.
*   Всегда думайте о **производительности:** используйте асинхронность, `AsNoTracking()` и избегайте N+1.

---

### **Контрольные вопросы:**

1.  Объясните, что такое "Проблема объектно-реляционного импеданса" и как ORM ее решает.
2.  В чем ключевое различие между подходами Database First и Code First? Какой вы бы выбрали для нового проекта и почему?
3.  Что такое `DbContext` и `DbSet`? Какую роль они играют?
4.  Опишите жизненный цикл сущности (состояния: Added, Modified, Unchanged, Deleted) от добавления до сохранения.
5.  В чем разница между `FirstOrDefault()` и `SingleOrDefault()`? Когда какой метод использовать?
6.  Что такое "Проблема N+1" в EF Core? Продемонстрируйте пример и объясните, как ее исправить.
7.  Для чего нужен метод `Include`? Какие есть альтернативные способы загрузки связанных данных?
8.  Что делают команды `Add-Migration` и `Update-Database`?
9.  Объясните, зачем использовать `AsNoTracking()` и в каких сценариях это уместно.
10. Как организовать отношение "Многие-ко-многим" между сущностями `Post` и `Tag` в EF Core 5+?