# Лекция: Реальное время с SignalR в .NET

**Тема:** Основы и практическое применение библиотеки SignalR для создания приложений реального времени на платформе .NET.

**Цель:** Дать студентам полное представление о SignalR, начиная с основных концепций и заканчивая созданием полнофункционального приложения "Чат". Студенты научатся устанавливать соединение, отправлять сообщения и управлять клиентами.

---

### **План лекции:**

1.  **Введение в реальное время и что такое SignalR?**
2.  **Архитектура и транспортные протоколы SignalR.**
3.  **Создание первого Hub'а — центрального компонента.**
4.  **Подключение клиентов: JavaScript, .NET и другие.**
5.  **Группы и управление состояниями.**
6.  **Обработка ошибок и устойчивость соединения.**
7.  **Масштабирование: что делать, когда один сервер не справляется?**

---

### **Резюме (для студентов):**

SignalR — это библиотека от Microsoft, которая dramatically упрощает добавление функциональности реального времени в веб-приложения. Она абстрагируется от низкоуровневых протоколов (как WebSockets) и позволяет вам просто вызывать методы на клиенте с сервера и наоборот. Вы изучите ключевой компонент — **Hub**, научитесь создавать его, подключать к нему различные клиенты, объединять пользователей в группы и обеспечивать стабильность работы приложения.

---

### **Подробное рассмотрение каждого пункта плана:**

#### **1. Введение в реальное время и что такое SignalR?**

**Что такое "реальное время" в веб-контексте?**
Это не мгновенная скорость, а модель, при которой сервер может самостоятельно инициировать отправку данных клиенту, как только они становятся доступны, без необходимости ожидания запроса от клиента.

**Примеры:**
*   **Чат-приложения** (WhatsApp, Telegram Web)
*   **Дашборды с обновляемыми данными** (биржевые котировки, статистика сайта)
*   **Онлайн-игры** и коллаборативные инструменты (например, Google Docs)
*   **Уведомления** (новое письмо, уведомление в соцсети)

**Что такое SignalR?**
SignalR — это библиотека с открытым исходным кодом для ASP.NET, которая упрощает создание таких приложений. Она автоматически выбирает лучший из доступных транспортных протоколов и предоставляет простую модель программирования RPC (Remote Procedure Call — вызов удаленной процедуры).

**Без SignalR:** Вам пришлось бы вручную работать с WebSockets, Server-Sent Events (SSE) или использовать долгий опрос (Long Polling), что сложно и требует глубоких знаний.

**С SignalR:** Вы просто пишете `Clients.All.SendAsync("ReceiveMessage", user, message)`, а библиотека сама заботится о транспорте и доставке.

---

#### **2. Архитектура и транспортные протоколы SignalR.**

**Архитектура "Хаба" (Hub):**
*   **Hub** — это главный компонент, который работает на сервере.
*   Он действует как высокоуровневая конвейерная труба (pipe) между сервером и клиентами.
*   Клиенты подключаются к Хабу и могут вызывать методы на сервере.
*   Сервер может вызывать методы на одном, нескольких или всех подключенных клиентах.

**Транспортные протоколы (в порядке предпочтения SignalR):**

1.  **WebSockets:** Наиболее эффективный и современный протокол, обеспечивающий полноценное двустороннее соединение. Требует поддержки сервером и клиентом.
2.  **Server-Sent Events (SSE):** Позволяет серверу отправлять данные клиенту. Клиент не может отправлять данные по этому же соединению (односторонний).
3.  **Long Polling:** "Классический" метод эмуляции реального времени. Клиент отправляет запрос и держит его открытым, пока сервер не ответит данными или пока не истечет время ожидания. После этого клиент сразу отправляет новый запрос.

**Как работает согласование?**
При установке соединения клиент и сервер "договариваются" о том, какой транспорт использовать, начиная с самого лучшего (WebSockets) и понижаясь при необходимости.

---

#### **3. Создание первого Hub'а — центрального компонента.**

Хаб — это обычный класс C#, который наследуется от `Hub`.

**Пример: Простейший Hub для чата**

```csharp
using Microsoft.AspNetCore.SignalR;

namespace ChatApp.Hubs
{
    public class ChatHub : Hub
    {
        // Метод, который может быть вызван клиентом
        public async Task SendMessage(string user, string message)
        {
            // Вызов метода на ВСЕХ подключенных клиентах
            await Clients.All.SendAsync("ReceiveMessage", user, message);
        }

        // Переопределение методов жизненного цикла подключения
        public override async Task OnConnectedAsync()
        {
            // При подключении нового пользователя
            await Clients.All.SendAsync("UserConnected", Context.ConnectionId);
            await base.OnConnectedAsync();
        }

        public override async Task OnDisconnectedAsync(Exception? exception)
        {
            // При отключении пользователя
            await Clients.All.SendAsync("UserDisconnected", Context.ConnectionId);
            await base.OnDisconnectedAsync(exception);
        }
    }
}
```

**Регистрация SignalR в приложении:**

В `Program.cs` (для .NET 6+) необходимо добавить сервисы и маршрутизацию.

```csharp
var builder = WebApplication.CreateBuilder(args);

// Добавление сервисов SignalR
builder.Services.AddSignalR();

var app = builder.Build();

// Настройка маршрута к Хабу
app.MapHub<ChatHub>("/chatHub");

app.Run();
```

---

#### **4. Подключение клиентов: JavaScript, .NET и другие.**

**Клиент на JavaScript (в браузере):**

1.  Подключите библиотеку SignalR (через CDN или npm).
2.  Создайте и запустите соединение.

```html
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/6.0.0/signalr.min.js"></script>

<script>
    // Создание подключения
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/chatHub") // URL должен совпадать с маршрутом на сервере
        .build();

    // Регистрация метода, который будет вызываться с сервера
    connection.on("ReceiveMessage", (user, message) => {
        // Этот код выполнится, когда сервер вызовет `ReceiveMessage`
        const li = document.createElement("li");
        li.textContent = `${user}: ${message}`;
        document.getElementById("messagesList").appendChild(li);
    });

    // Запуск подключения
    connection.start().then(() => {
        console.log("Connected to SignalR Hub!");
    }).catch(err => console.error(err.toString()));

    // Вызов метода на сервере
    function sendMessage() {
        const user = document.getElementById("userInput").value;
        const message = document.getElementById("messageInput").value;
        connection.invoke("SendMessage", user, message).catch(err => console.error(err));
    }
</script>
```

**Клиент на .NET (например, в WPF, Console или Xamarin):**

1.  Установите NuGet пакет `Microsoft.AspNetCore.SignalR.Client`.
2.  Код очень похож на JavaScript.

```csharp
using Microsoft.AspNetCore.SignalR.Client;

var connection = new HubConnectionBuilder()
    .WithUrl("https://yourapp.com/chatHub")
    .Build();

// Подписываемся на сообщения от сервера
connection.On<string, string>("ReceiveMessage", (user, message) =>
{
    Console.WriteLine($"{user}: {message}");
});

await connection.StartAsync();

// Вызываем метод на сервере
await connection.InvokeAsync("SendMessage", "ConsoleUser", "Hello from .NET Client!");
```

---

#### **5. Группы и управление состояниями.**

**Группы:** Позволяют отправлять сообщения не всем клиентам, а только определенной их подгруппе (например, участникам одной комнаты чата).

```csharp
public class ChatHub : Hub
{
    // Добавление подключения в группу
    public async Task JoinRoom(string roomName)
    {
        await Groups.AddToGroupAsync(Context.ConnectionId, roomName);
        await Clients.Group(roomName).SendAsync("UserJoined", Context.ConnectionId, roomName);
    }

    // Удаление подключения из группы
    public async Task LeaveRoom(string roomName)
    {
        await Groups.RemoveFromGroupAsync(Context.ConnectionId, roomName);
        await Clients.Group(roomName).SendAsync("UserLeft", Context.ConnectionId, roomName);
    }

    // Отправка сообщения только в определенную комнату
    public async Task SendMessageToRoom(string roomName, string user, string message)
    {
        await Clients.Group(roomName).SendAsync("ReceiveMessage", user, message);
    }
}
```

**Управление состояниями:**
*   **`Context.ConnectionId`:** Уникальный идентификатор каждого подключения.
*   **`Context.Items`:** Коллекция "на лету" (per-connection) для хранения данных в рамках одного подключения.
*   **`Groups`:** Как показано выше, для управления группами.

---

#### **6. Обработка ошибок и устойчивость соединения.**

**Обработка на клиенте (JavaScript):**

```javascript
connection.start().catch(err => {
    console.error("Connection failed: ", err);
    // Показать сообщение пользователю
});

// Обработка ошибок при вызове метода
connection.invoke("SendMessage", user, message).catch(err => {
    console.error("Invocation failed: ", err);
    // Показать пользователю, что сообщение не отправлено
});
```

**Автоматическое переподключение:**
SignalR клиенты могут быть настроены на автоматическое переподключение при обрыве связи.

```javascript
const connection = new signalR.HubConnectionBuilder()
    .withUrl("/chatHub")
    .withAutomaticReconnect([0, 2000, 10000, 30000]) // Паузы между попытками
    .build();

// События жизненного цикла переподключения
connection.onreconnecting(error => {
    console.log("Connection lost. Reconnecting...");
});

connection.onreconnected(connectionId => {
    console.log("Connection restored!");
});
```

---

#### **7. Масштабирование: что делать, когда один сервер не справляется?**

**Проблема:** По умолчанию SignalR хранит информацию о подключениях в памяти сервера. Если у вас несколько серверов, сообщение с сервера A не дойдет до клиента, подключенного к серверу B.

**Решение: Backplane (Серверная шина)**
Backplane — это внешнее хранилище (например, Redis или Azure SignalR Service), которое перенаправляет сообщения между всеми серверами.

**Пример с Redis:**
1.  Установите NuGet пакет `Microsoft.AspNetCore.SignalR.StackExchangeRedis`.
2.  Настройте в `Program.cs`:

```csharp
builder.Services.AddSignalR().AddStackExchangeRedis("localhost:6379");
```

**Пример с Azure SignalR Service (Рекомендуется для продакшена):**
Это полностью управляемый сервис, который избавляет вас от необходимости настраивать свой Backplane.

```csharp
builder.Services.AddSignalR().AddAzureSignalR("YourAzureSignalRConnectionString");
```

---

### **Контрольные вопросы:**

1.  Объясните, какую проблему решает SignalR и в каких типах приложений она наиболее полезна.
2.  Опишите жизненный цикл подключения клиента к SignalR Hub. Какие методы на сервере вызываются при подключении и отключении?
3.  В чем разница между `Clients.All`, `Clients.Caller` и `Clients.Others`? Напишите пример использования каждого.
4.  Как бы вы реализовали функционал "комнат" или "групп" в чат-приложении с использованием SignalR?
5.  Ваше приложение стало популярным, и вы решили добавить второй сервер. Сообщения перестали доходить до всех пользователей. В чем причина и как это исправить?
6.  Напишите простой фрагмент кода на C# для Hub'а, который получает от клиента строку, делает ее заглавными буквами и отправляет обратно только вызвавшему клиенту.
7.  Какие транспорты использует SignalR "под капотом" и в каком порядке происходит их согласование?