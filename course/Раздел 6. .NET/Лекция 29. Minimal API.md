
# Лекция. Minimal API в .NET — Современный подход к созданию легковесных веб-API

**Цель:** Понять философию, синтаксис и практическое применение Minimal API, научиться создавать эффективные HTTP-сервисы с минимальным количеством кода.

---

### **План лекции:**

1.  **Введение: Что такое Minimal API и зачем они нужны?**
    *   Эволюция от Controller-based API к Minimal API.
    *   Ключевые преимущества: меньше кода, больше производительности.
    *   Идеальные сценарии использования (микросервисы, прототипы, простые endpoints).

2.  **Основы синтаксиса: От "Hello World" к CRUD**
    *   Структура `WebApplication` и `WebApplicationBuilder`.
    *   Методы расширения для HTTP-глаголов: `MapGet`, `MapPost`, `MapPut`, `MapDelete`.
    *   Параметры в маршруте и в строке запроса.

3.  **Работа с данными: Валидация, привязка модели (Model Binding) и сериализация**
    *   Неявная привязка модели (Implicit Model Binding).
    *   Явное указание источников данных с атрибутами (`[FromBody]`, `[FromQuery]`).
    *   Встроенная валидация с `DataAnnotations`.

4.  **Группировка и организация кода**
    *   Проблема "раздутого" файла `Program.cs`.
    *   Использование `MapGroup` для группировки endpoints.
    *   Использование методов расширения для создания модульных групп API.

5.  **Внедрение зависимостей (Dependency Injection) и работа с БД**
    *   Регистрация сервисов в контейнере DI (`AddSingleton`, `AddScoped`, `AddTransient`).
    *   Внедрение сервисов в обработчики endpoints.
    *   Практический пример: подключение Entity Framework Core и создание простого CRUD.

6.  **Фильтры端点 (Endpoint Filters)**
    *   Что такое фильтры и для чего они нужны (логирование, валидация, обработка ошибок).
    *   Создание кастомного фильтра для валидации модели.
    *   Использование встроенного фильтра `ValidateAntiforgeryToken`.

7.  **Резюме и заключение**
8.  **Контрольные вопросы**

---

### **Подробное рассмотрение каждого пункта плана:**

#### **1. Введение: Что такое Minimal API и зачем они нужны?**

**До Minimal API** мы использовали контроллеры. Это мощный, полнофункциональный шаблон, но для простых задач он может быть избыточным.

*Пример Controller-based API:*
```csharp
[ApiController]
[Route("[controller]")]
public class UsersController : ControllerBase
{
    [HttpGet]
    public IEnumerable<User> GetUsers() => ...;

    [HttpGet("{id}")]
    public User GetUser(int id) => ...;

    // ... много кода, даже для простых действий
}
```

**Minimal API** — это упрощенный подход, который позволяет описывать endpoints напрямую в классе `Program.cs` (в основном) с помощью лаконичного синтаксиса.

*Тот же функционал на Minimal API:*
```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

app.MapGet("/users", () => {...});
app.MapGet("/users/{id}", (int id) => {...});

app.Run();
```

**Преимущества:**
*   **Меньше шаблонного кода:** Нет need создавать отдельные классы контроллеров.
*   **Улучшенная производительность:** Меньше накладных расходов на маршрутизацию и активацию контроллеров.
*   **Идеально для микросервисов:** Когда у вас много небольших сервисов, каждый с несколькими endpoints.

**Сценарии использования:** Прототипирование, простые HTTP-API, микросервисы, функции Azure.

---

#### **2. Основы синтаксиса: От "Hello World" к CRUD**

Основа — классы `WebApplicationBuilder` и `WebApplication`.

```csharp
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();

// MapGet - обработка GET запроса
app.MapGet("/", () => "Hello World!");

// MapPost - обработка POST запроса
app.MapPost("/items", () => Results.Ok(new { Message = "Item created" }));

app.Run();
```

**Работа с параметрами:**
```csharp
// Параметр в маршруте (Route Parameter)
app.MapGet("/users/{id}", (int id) => $"User ID: {id}");

// Параметр в строке запроса (Query String Parameter)
app.MapGet("/users", (string name, int age) => $"User: {name}, Age: {age}");

// Комбинация параметров
app.MapGet("/products/{category}/items", (string category, int page) => $"Category: {category}, Page: {page}");
```

**Возвращаемые результаты:**
Класс `Results` предоставляет удобные методы для формирования ответов.
```csharp
app.MapGet("/api/user", () => {
    var user = new { Name = "John", Age = 30 };
    return Results.Ok(user); // 200 OK
});

app.MapGet("/api/notfound", (int id) => {
    if (id > 10)
        return Results.NotFound(); // 404 Not Found
    else
        return Results.Ok(id);
});
```

---

#### **3. Работа с данными: Валидация, привязка модели и сериализация**

Minimal API автоматически привязывает данные из тела запроса (JSON) к параметрам метода.

```csharp
// Модель данных
public record CreateUserRequest(string Name, string Email, int Age);

// POST с автоматической привязкой модели (Implicit Binding)
app.MapPost("/users", (CreateUserRequest newUser) => {
    // newUser автоматически десериализован из JSON тела запроса
    return Results.Created($"/users/1", newUser);
});
```

**Валидация с DataAnnotations:**
```csharp
public record CreateUserRequest(
    [Required, MinLength(3)] string Name,
    [Required, EmailAddress] string Email,
    [Range(1, 120)] int Age
);

app.MapPost("/users", (CreateUserRequest newUser) => {
    // Валидация происходит автоматически!
    // Если модель невалидна, возвращается 400 Bad Request с деталями ошибок.
    return Results.Created($"/users/1", newUser);
});
```

**Явное указание источника:**
```csharp
// [FromQuery] - явно указывает, что параметр берется из строки запроса
app.MapGet("/search", ([FromQuery] string term) => {...});

// [FromBody] - явно указывает на тело запроса (используется редко, так как это поведение по умолчанию для сложных типов)
app.MapPost("/users", ([FromBody] CreateUserRequest newUser) => {...});
```

---

#### **4. Группировка и организация кода**

Когда endpoints становится много, их нужно организовать.

**Проблема:**
```csharp
// Program.cs превращается в свалку
app.MapGet("/users", ...);
app.MapPost("/users", ...);
app.MapGet("/products", ...);
app.MapPost("/products", ...);
app.MapPut("/products/{id}", ...);
```

**Решение: `MapGroup`**
```csharp
// Создаем группу для всех операций с пользователями
var userGroup = app.MapGroup("/api/users");

userGroup.MapGet("/", () => "Get all users");
userGroup.MapPost("/", () => "Create a user");
userGroup.MapGet("/{id}", (int id) => $"Get user {id}");

// Группа также позволяет задавать общие конфигурации
var adminGroup = app.MapGroup("/api/admin")
                    .RequireAuthorization() // Все endpoints в группе требуют авторизации
                    .WithTags("Admin"); // Группировка в Swagger/OpenAPI
```

**Модульная организация через методы расширения:**
```csharp
// Создаем статический класс
public static class UserEndpoints
{
    public static void MapUserEndpoints(this WebApplication app)
    {
        var group = app.MapGroup("/api/users");
        
        group.MapGet("/", GetUsers);
        group.MapPost("/", CreateUser);
    }

    private static IResult GetUsers() => Results.Ok("All users");
    private static IResult CreateUser(CreateUserRequest request) => Results.Ok("User created");
}

// В Program.cs
app.MapUserEndpoints(); // Чисто и понятно!
```

---

#### **5. Внедрение зависимостей (Dependency Injection) и работа с БД**

**Регистрация сервисов:**
```csharp
var builder = WebApplication.CreateBuilder(args);

// Регистрируем наши сервисы
builder.Services.AddScoped<IUserService, UserService>(); // Один экземпляр на запрос
builder.Services.AddSingleton<ILoggerService, LoggerService>(); // Один экземпляр на все приложение
```

**Внедрение сервисов в endpoints:**
Сервисы автоматически резолвятся из контейнера, когда они указаны как параметры делегата.

```csharp
app.MapGet("/users", (IUserService userService) => {
    var users = userService.GetAllUsers();
    return Results.Ok(users);
});
```

**Практический пример с Entity Framework Core:**
```csharp
// Регистрация контекста БД
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlite(builder.Configuration.GetConnectionString("DefaultConnection")));

// Модель
public record class User(int Id, string Name);
public class AppDbContext : DbContext
{
    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}
    public DbSet<User> Users => Set<User>();
}

// CRUD Endpoints
app.MapGet("/users", async (AppDbContext db) => await db.Users.ToListAsync());
app.MapGet("/users/{id}", async (int id, AppDbContext db) =>
    await db.Users.FindAsync(id) is User user ? Results.Ok(user) : Results.NotFound());

app.MapPost("/users", async (User user, AppDbContext db) =>
{
    db.Users.Add(user);
    await db.SaveChangesAsync();
    return Results.Created($"/users/{user.Id}", user);
});
```

---

#### **6. Фильтры端点 (Endpoint Filters)**

Фильтры позволяют перехватывать запрос до и после выполнения обработчика endpoint.

**Создание кастомного фильтра для валидации:**
```csharp
// Фильтр, который проверяет ModelState (альтернатива автоматической валидации)
public class ValidationFilter<T> : IEndpointFilter
{
    public async ValueTask<object?> InvokeAsync(EndpointFilterInvocationContext context, EndpointFilterDelegate next)
    {
        var arg = context.Arguments.OfType<T>().FirstOrDefault();
        if (arg == null)
        {
            return Results.Problem("Model is invalid or missing.");
        }

        // Здесь можно добавить кастомную логику валидации
        // if(!MyCustomValidator.IsValid(arg)) ...

        // Передаем управление следующему фильтру или конечному обработчику
        return await next(context);
    }
}

// Применение фильтра
app.MapPost("/users-with-filter", (CreateUserRequest newUser) => {
    // Этот код выполнится, только если фильтр пропустит запрос
    return Results.Ok(newUser);
}).AddEndpointFilter<ValidationFilter<CreateUserRequest>>();
```

---

### **7. Резюме**

*   **Minimal API** — это современный, лаконичный подход к созданию HTTP-API в .NET, идеально подходящий для сценариев, где важны простота и производительность.
*   **Синтаксис** основан на методах `MapGet`, `MapPost` и т.д., которые регистрируют делегаты как обработчики запросов.
*   **Работа с данными** упрощена благодаря неявной привязке моделей и встроенной валидации.
*   **Организация кода** достигается через `MapGroup` и методы расширения, что предотвращает "захламление" `Program.cs`.
*   **Внедрение зависимостей** работает "из коробки" — сервисы автоматически внедряются в параметры делегатов.
*   **Фильтры** предоставляют мощный механизм для сквозной логики, такой как валидация, авторизация и логирование.

Minimal API не заменяет полностью традиционные контроллеры, а предлагает альтернативу, расширяя инструментарий .NET разработчика.

---

### **Контрольные вопросы:**

1.  **В чем заключаются основные преимущества Minimal API по сравнению с традиционными Controller-based API?**
2.  **Как с помощью Minimal API обработать POST-запрос, который принимает JSON-тело и возвращает созданный ресурс с кодом 201? Напишите пример кода.**
3.  **Что такое неявная привязка модели (Implicit Model Binding) и как она работает в Minimal API?**
4.  **Ваш файл `Program.cs` разросся до 50 endpoints. Какие два основных способа организации кода в Minimal API вы можете предложить?**
5.  **Как зарегистрировать сервис с временем жизни `Scoped` и затем использовать его в обработчике endpoint?**
6.  **Для чего нужны фильтры端点 (Endpoint Filters)? Приведите пример практического использования кастомного фильтра.**
7.  **Как с помощью `MapGroup` задать общий префикс "/api" и требование авторизации для группы endpoints?**
8.  **Каков будет результат выполнения следующего endpoint, если запрос будет `GET /products/5?details=true`?**
    ```csharp
    app.MapGet("/products/{id}", (int id, bool details) => $"Product {id}, Details: {details}");
    ```