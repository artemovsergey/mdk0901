# Лекция для студентов: Аутентификация и авторизация в .NET

**Цель:** Сформировать четкое понимание разницы между аутентификацией и авторизацией, изучить основные механизмы их реализации в экосистеме .NET.

---

### **Тема лекции**

**"Аутентификация и авторизация в ASP.NET Core: от базовых концепций к современным практикам с использованием JWT и Identity"**

---

### **План лекции**

1.  **Введение: Фундаментальные понятия**
    *   Кто ты? (Аутентификация) vs Что ты можешь? (Авторизация)
    *   Аналогия с офисом (пропуск и доступ в кабинет).
2.  **Эволюция аутентификации в вебе**
    *   Cookies-based аутентификация.
    *   Сессии на сервере.
    *   Недостатки stateful-подходов.
3.  **Современный подход: Token-based аутентификация и JWT**
    *   Что такое JWT? Структура (Header, Payload, Signature).
    *   Как это работает: поток от логина до доступа к защищенному ресурсу.
    *   Преимущества и недостатки (Stateless, масштабируемость, необходимость безопасного хранения).
4.  **Авторизация в ASP.NET Core: Концепции и политики**
    *   Роли (Roles) vs Политики (Policies).
    *   Создание гибких политик на основе требований (Requirements) и обработчиков (Handlers).
    *   Использование атрибутов `[Authorize]`, `[AllowAnonymous]`.
5.  **Инструмент профессионала: ASP.NET Core Identity**
    *   Что такое Identity? Готовая система для управления пользователями.
    *   Основные сущности: `User`, `Role`, `UserManager<T>`, `SignInManager<T>`.
    *   Кастомизация Identity (добавление полей в пользователя).
6.  **Практический пример: Защита Web API с помощью JWT**
    *   Настройка генерации JWT-токена.
    *   Создание защищенного контроллера.
    *   Тестирование в Postman.

---

### **Подробное рассмотрение каждого пункта плана**

#### **1. Введение: Фундаментальные понятия**

**Аутентификация (Authentication)** — это процесс проверки подлинности пользователя. Проще говоря, система задает вопрос: "**Ты тот, за кого себя выдаешь?**". Ответом обычно является предоставление учетных данных (credentials): логин/пароль, отпечаток пальца, Face ID и т.д.

*   **Пример:** Вход в электронную почту. Вы вводите логин и пароль, и почтовый сервис проверяет, существует ли такой пользователь и верный ли пароль.

**Авторизация (Authorization)** — это процесс проверки прав доступа аутентифицированного пользователя к определенным ресурсам или действиям. Вопрос системы: "**Что тебе разрешено делать?**".

*   **Пример:** После входа в почту вы можете читать свои письма, но не можете читать письма другого пользователя. В админ-панели веб-сайта один пользователь может только просматривать данные, а другой — их удалять.

**Классическая аналогия:**
Представьте, что вы приходите в офис.
*   **Аутентификация:** Охранник проверяет ваш пропуск (удостоверение личности). Это подтверждает, что вы сотрудник компании.
*   **Авторизация:** Теперь, имея пропуск, вы можете зайти в общий зал, но не можете войти в кабинет к директору. Ваш пропуск просто не имеет такого уровня доступа.

#### **2. Эволюция аутентификации в вебе**

**Cookie-based аутентификация:**
1.  Пользователь вводит логин/пароль в форму.
2.  Сервер проверяет их. Если все верно, он создает **сессию** (запись в памяти или базе данных, связанную с этим пользователем).
3.  Сервер отправляет в ответ браузеру специальный файл — **Cookie**, в котором содержится идентификатор сессии (Session ID).
4.  При каждом последующем запросе браузер автоматически отправляет этот Cookie на сервер.
5.  Сервер по Session ID находит сессию и понимает, какой пользователь делает запрос.

*   **Недостатки:**
    *   **Stateful (с состоянием):** Сервер должен хранить состояние сессии для каждого пользователя. Это создает проблемы при масштабировании (несколько серверов должны иметь общее хранилище сессий).
    *   **Уязвимость к CSRF (Cross-Site Request Forgery):** Злоумышленник может заставить браузер жертвы отправить запрос с куками на ваш сайт.

**Пример кода для работы с сессией (устаревший подход, но для понимания):**
```csharp
// Где-то в контроллере при успешном логине
HttpContext.Session.SetString("UserId", user.Id.ToString());
HttpContext.Session.SetString("Username", user.Username);

// При получении запроса
var userId = HttpContext.Session.GetString("UserId");
if (string.IsNullOrEmpty(userId))
{
    // Пользователь не аутентифицирован
}
```

#### **3. Современный подход: Token-based аутентификация и JWT**

Чтобы решить проблемы масштабируемости, пришел подход **Token-based authentication**. Самый популярный стандарт — **JWT (JSON Web Token)**.

**Что такое JWT?**
Это компактный, URL-безопасный способ представления утверждений (claims), которые будут передаваться между двумя сторонами. Токен подписан, поэтому его можно проверить на подлинность. Он состоит из 3-х частей, разделенных точками:
*   **Header:** Алгоритм шифрования и тип токена (`{"alg": "HS256", "typ": "JWT"}`).
*   **Payload:** Полезные данные (утверждения — Claims). Например, `{"sub": "12345", "name": "John Doe", "role": "Admin", "exp": 1516239022}`.
    *   `sub` (Subject) - о ком токен.
    *   `role` - роль пользователя.
    *   `exp` (Expiration) - срок действия.
*   **Signature:** Подпись, созданная на основе Header, Payload и секретного ключа. Гарантирует, что токен не был изменен.

**Поток работы:**
1.  **Логин:** Клиент отправляет учетные данные на сервер (`/api/auth/login`).
2.  **Верификация:** Сервер проверяет логин/пароль.
3.  **Генерация токена:** Сервер генерирует JWT с нужными claims (ID пользователя, роли) и секретным ключом.
4.  **Ответ:** Сервер отправляет JWT клиенту (обычно в теле ответа).
5.  **Доступ:** Клиент прикладывает этот токен в заголовке `Authorization: Bearer <your-jwt-token>` ко всем последующим запросам.
6.  **Проверка:** Сервер проверяет подпись токена и его срок действия. Если все верно, извлекает данные пользователя из Payload. **Сессия не нужна!**

**Пример генерации JWT в .NET:**
```csharp
public string GenerateJwtToken(User user)
{
    var secretKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_configuration["Jwt:Secret"]));
    var signinCredentials = new SigningCredentials(secretKey, SecurityAlgorithms.HmacSha256);

    var claims = new List<Claim>
    {
        new Claim(ClaimTypes.Name, user.Username),
        new Claim(ClaimTypes.NameIdentifier, user.Id.ToString()),
        new Claim(ClaimTypes.Role, user.Role)
    };

    var tokenOptions = new JwtSecurityToken(
        issuer: _configuration["Jwt:Issuer"],
        audience: _configuration["Jwt:Audience"],
        claims: claims,
        expires: DateTime.Now.AddHours(1),
        signingCredentials: signinCredentials
    );

    var tokenString = new JwtSecurityTokenHandler().WriteToken(tokenOptions);
    return tokenString;
}
```

#### **4. Авторизация в ASP.NET Core: Концепции и политики**

После того как пользователь аутентифицирован (мы знаем, кто он), наступает этап авторизации.

**Роли (Roles):** Простой, но ограниченный подход.
```csharp
// Установка роли для пользователя (в Claims)
claims.Add(new Claim(ClaimTypes.Role, "Admin"));

// Проверка в контроллере
[Authorize(Roles = "Admin")]
public IActionResult DeleteProduct(int id)
{
    // Этот метод доступен только пользователям с ролью Admin.
}
```
*   **Проблема:** Что если для доступа к методу нужно быть одновременно и "Editor", и "Senior"? Или если правило сложнее, чем просто наличие роли (например, "доступ разрешен, если пользователь создатель статьи ИЛИ является модератором")?

**Политики (Policies):** Гибкий и мощный механизм.
Вы определяете политику при старте приложения (`Program.cs`), а затем используете ее.

```csharp
// Регистрация политик
builder.Services.AddAuthorization(options =>
{
    // Требование наличия роли
    options.AddPolicy("RequireAdmin", policy => policy.RequireRole("Admin"));

    // Требование наличия claim'а с определенным значением
    options.AddPolicy("EmployeeOnly", policy => policy.RequireClaim("EmploymentType", "Internal"));

    // Сложная кастомная политика
    options.AddPolicy("Over18YearsOld", policy => policy.Requirements.Add(new MinimumAgeRequirement(18)));
});

// Использование политик
[Authorize(Policy = "Over18YearsOld")]
public IActionResult AccessToAdultContent() { ... }

// Можно комбинировать
[Authorize(Roles = "Admin", Policy = "EmployeeOnly")]
```

**Создание кастомной политики с обработчиком:**
```csharp
// 1. Требование
public class MinimumAgeRequirement : IAuthorizationRequirement
{
    public int MinimumAge { get; }
    public MinimumAgeRequirement(int minimumAge) => MinimumAge = minimumAge;
}

// 2. Обработчик требования
public class MinimumAgeHandler : AuthorizationHandler<MinimumAgeRequirement>
{
    protected override Task HandleRequirementAsync(AuthorizationHandlerContext context,
                                                   MinimumAgeRequirement requirement)
    {
        // Ищем claim с датой рождения
        var dateOfBirthClaim = context.User.FindFirst(c => c.Type == ClaimTypes.DateOfBirth);
        if (dateOfBirthClaim != null)
        {
            var dateOfBirth = Convert.ToDateTime(dateOfBirthClaim.Value);
            var age = DateTime.Today.Year - dateOfBirth.Year;
            if (age >= requirement.MinimumAge)
            {
                context.Succeed(requirement); // Доступ разрешен!
            }
        }
        return Task.CompletedTask;
    }
}
// 3. Регистрируем обработчик в DI-контейнере
builder.Services.AddSingleton<IAuthorizationHandler, MinimumAgeHandler>();
```

#### **5. Инструмент профессионала: ASP.NET Core Identity**

**Что это?** Готовый каркас для системы аутентификации и авторизации. Он берет на себя:
*   Хранение пользователей, ролей, хэширование паролей.
*   Подтверждение email, двухфакторную аутентификацию, блокировку учетной записи.
*   Взаимодействие с базой данных через Entity Framework Core.

**Основные компоненты:**
*   `UserManager<TUser>`: Для управления пользователями (создание, удаление, поиск, смена пароля).
*   `SignInManager<TUser>`: Для операций входа и выхода.
*   `IdentityUser`: Базовый класс пользователя. Его можно кастомизировать.
*   `IdentityRole`: Базовый класс роли.

**Пример: Кастомизация пользователя и регистрация.**
```csharp
// 1. Добавляем поля к пользователю
public class ApplicationUser : IdentityUser
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
    public DateTime DateOfBirth { get; set; }
}

// 2. Регистрируем в Program.cs
builder.Services.AddDefaultIdentity<ApplicationUser>(options => 
{
    // Настройка политики паролей и т.д.
})
.AddEntityFrameworkStores<ApplicationDbContext>();

// 3. Использование в контроллере
public class AccountController : Controller
{
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly SignInManager<ApplicationUser> _signInManager;

    public AccountController(UserManager<ApplicationUser> userManager, SignInManager<ApplicationUser> signInManager)
    {
        _userManager = userManager;
        _signInManager = signInManager;
    }

    public async Task<IActionResult> Register(RegisterViewModel model)
    {
        if (ModelState.IsValid)
        {
            var user = new ApplicationUser 
            { 
                UserName = model.Email, 
                Email = model.Email,
                FirstName = model.FirstName,
                DateOfBirth = model.DateOfBirth
            };
            var result = await _userManager.CreateAsync(user, model.Password); // Пароль хэшируется автоматически!

            if (result.Succeeded)
            {
                await _signInManager.SignInAsync(user, isPersistent: false);
                return RedirectToAction("Index", "Home");
            }
            foreach (var error in result.Errors)
            {
                ModelState.AddModelError(string.Empty, error.Description);
            }
        }
        return View(model);
    }
}
```

#### **6. Практический пример: Защита Web API с помощью JWT**

Давайте соберем все вместе в контексте Web API.

**1. Настройка сервисов (`Program.cs`):**
```csharp
// ... другие сервисы

// Настройка Identity (если используется)
builder.Services.AddIdentity<ApplicationUser, IdentityRole>()
    .AddEntityFrameworkStores<ApplicationDbContext>()
    .AddDefaultTokenProviders();

// Настройка JWT Authentication
builder.Services.AddAuthentication(options =>
{
    options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
    options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
})
.AddJwtBearer(options =>
{
    options.TokenValidationParameters = new TokenValidationParameters
    {
        ValidateIssuer = true,
        ValidateAudience = true,
        ValidateLifetime = true,
        ValidateIssuerSigningKey = true,
        ValidIssuer = builder.Configuration["Jwt:Issuer"],
        ValidAudience = builder.Configuration["Jwt:Audience"],
        IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Secret"]))
    };
});

builder.Services.AddAuthorization();

// ...
app.UseAuthentication(); // Важно: ДО UseAuthorization!
app.UseAuthorization();
```

**2. Контроллер для аутентификации (`AuthController`):**
```csharp
[ApiController]
[Route("api/[controller]")]
[AllowAnonymous] // Разрешаем доступ без аутентификации
public class AuthController : ControllerBase
{
    private readonly UserManager<ApplicationUser> _userManager;
    private readonly IConfiguration _configuration;

    public AuthController(UserManager<ApplicationUser> userManager, IConfiguration configuration)
    {
        _userManager = userManager;
        _configuration = configuration;
    }

    [HttpPost("login")]
    public async Task<IActionResult> Login([FromBody] LoginModel model)
    {
        var user = await _userManager.FindByNameAsync(model.Username);
        if (user != null && await _userManager.CheckPasswordAsync(user, model.Password))
        {
            var authClaims = new List<Claim>
            {
                new Claim(ClaimTypes.Name, user.UserName),
                new Claim(JwtRegisteredClaimNames.Jti, Guid.NewGuid().ToString()),
            };

            // Добавляем роли пользователя в claims
            var userRoles = await _userManager.GetRolesAsync(user);
            foreach (var role in userRoles)
            {
                authClaims.Add(new Claim(ClaimTypes.Role, role));
            }

            var token = GenerateJwtToken(authClaims); // Используем метод из примера выше

            return Ok(new
            {
                token = new JwtSecurityTokenHandler().WriteToken(token),
                expiration = token.ValidTo
            });
        }
        return Unauthorized();
    }
}
```

**3. Защищенный контроллер (`WeatherForecastController`):**
```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize] // Теперь весь контроллер защищен
public class WeatherForecastController : ControllerBase
{
    [HttpGet]
    public IActionResult Get()
    {
        // Мы можем получить информацию о пользователе из HttpContext.User
        var userName = User.Identity.Name;
        var userId = User.FindFirst(ClaimTypes.NameIdentifier)?.Value;

        return Ok($"Секретные данные для {userName} (ID: {userId})");
    }

    [HttpGet("admin")]
    [Authorize(Roles = "Admin")] // Дополнительное требование к роли
    public IActionResult GetAdminData()
    {
        return Ok("Это видно только Админам!");
    }
}
```

**Тестирование в Postman:**
1.  Отправьте `POST` запрос на `/api/auth/login` с телом `{"username": "admin", "password": "password"}`.
2.  Скопируйте JWT-токен из ответа.
3.  Для вызова `GET /api/weatherforecast` установите заголовок `Authorization` со значением `Bearer <ваш-jwt-токен>`.
4.  Вы получите данные. Если убрать заголовок или подставить неверный токен, получите статус 401.

---

### **Резюме**

*   **Аутентификация и авторизация — это разные процессы.** "Кто ты?" vs "Что тебе можно?".
*   **Cookie-based аутентификация** проста, но создает состояние на сервере и плохо масштабируется.
*   **Token-based аутентификация (JWT)** — современный stateless-подход, идеально подходящий для SPA и мобильных приложений.
*   **Авторизация в .NET** гибко настраивается через **Политики (Policies)**, которые мощнее и выразительнее простых **Ролей (Roles)**.
*   **ASP.NET Core Identity** — это мощный готовый каркас, который значительно ускоряет разработку систем аутентификации.
*   Для защиты **Web API** стандартом де-факто является **JWT-токен**, передаваемый в заголовке `Authorization: Bearer ...`.

---

### **Контрольные вопросы**

1.  Объясните разницу между аутентификацией и авторизацией на примере банкомата.
2.  Каковы основные преимущества JWT перед cookie-based аутентификацией для построения REST API?
3.  Опишите шаги, которые происходят от момента отправки клиентом логина/пароля до получения им JWT-токена.
4.  В чем ключевое отличие авторизации на основе Ролей от авторизации на основе Политик? В каком случае вы бы использовали Политики?
5.  Что такое `UserManager<T>` и `SignInManager<T>` в ASP.NET Core Identity? Для каких задач они используются?
6.  Как в middleware pipeline ASP.NET Core должны быть расположены вызовы `UseAuthentication()` и `UseAuthorization()` и почему?
7.  Что произойдет, если JWT-токен с истекшим сроком действия (`exp`) будет отправлен на сервер?
8.  Как можно безопасно хранить JWT-токен на клиентской стороне (в веб-браузере)?