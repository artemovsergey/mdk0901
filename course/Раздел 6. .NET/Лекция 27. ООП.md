# Лекция. Объектно-Ориентированное Программирование (ООП) в C#

**Цель лекции:** Понять фундаментальные принципы ООП и научиться применять их для создания хорошо структурированных, масштабируемых и поддерживаемых приложений на C#.

**Целевая аудитория:** Студенты, знакомые с базовым синтаксисом C# (переменные, методы, циклы).

---

### **План лекции:**

1.  **Введение в ООП:** Что такое ООП и зачем он нужен?
2.  **Классы и Объекты:** Абстракция и материализация.
3.  **Четыре столпа ООП:**
    *   **Инкапсуляция:** Сокрытие внутренней реализации.
    *   **Наследование:** Создание иерархий "является".
    *   **Полиморфизм:** Один интерфейс — множество реализаций.
    *   **Абстракция:** Работа на уровне концепций, а не деталей.
4.  **Резюме**
5.  **Контрольные вопросы**

---

### **1. Введение в ООП**

**Что такое ООП?**
ООП — это парадигма (стиль) программирования, в которой программа организуется вокруг **объектов**, а не действий и данных, а не логики.

**Проблема процедурного подхода:**
Представьте, что вы пишете программу для управления банком. У вас есть отдельные массивы для хранения имен клиентов, их счетов и балансов. Это неудобно! Если нужно передать информацию о клиенте в метод, приходится передавать кучу отдельных параметров. При добавлении нового свойства (например, email) нужно менять сигнатуры многих методов.

**Решение через ООП:**
Мы создаем сущность **`BankAccount`**, которая объединяет в себе все данные (баланс, владелец) и методы (пополнить, снять), которые с этими данными работают. Это и есть объект.

**Ключевые преимущества:**
*   **Повторное использование кода:** Классы можно использовать многократно.
*   **Структурированность:** Код легче понимать и поддерживать.
*   **Масштабируемость:** Легко добавлять новую функциональность.
*   **Сокрытие сложности:** Пользователь класса не должен знать, *как* он работает внутри, ему важно знать, *что* он делает.

---

### **2. Классы и Объекты**

**Класс** — это чертеж, шаблон или описание будущего объекта. Он определяет:
*   **Данные (Поля, Свойства):** *Что* объект знает.
*   **Поведение (Методы):** *Что* объект умеет делать.

**Объект (Экземпляр класса)** — это конкретная реализация класса, созданная по его "чертежу". У каждого объекта есть свое собственное состояние (значения полей).

**Аналогия:**
*   **Класс `CookieCutter` (Форма для печенья):** Имеет атрибуты (форма звезды, размер 5см).
*   **Объекты `cookie1`, `cookie2` (Печенья):** Конкретные печенья, созданные по этой форме. У каждого свое состояние (цвет глазури, посыпка).

**Пример в C#:**

```csharp
// Класс (чертеж)
public class BankAccount
{
    // Данные (Поля и Свойства)
    public string AccountNumber { get; set; } // Свойство
    public string Owner { get; set; }         // Свойство
    private decimal _balance;                 // Поле (закрытое)

    // Конструктор - специальный метод для создания объекта
    public BankAccount(string accountNumber, string owner, decimal initialBalance)
    {
        AccountNumber = accountNumber;
        Owner = owner;
        _balance = initialBalance;
    }

    // Поведение (Методы)
    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            _balance += amount;
            Console.WriteLine($"Счет {AccountNumber}: пополнение на {amount}. Новый баланс: {_balance}");
        }
    }

    public void Withdraw(decimal amount)
    {
        if (amount > 0 && amount <= _balance)
        {
            _balance -= amount;
            Console.WriteLine($"Счет {AccountNumber}: снятие {amount}. Новый баланс: {_balance}");
        }
        else
        {
            Console.WriteLine("Недостаточно средств или неверная сумма.");
        }
    }

    // Метод для получения текущего баланса (инкапсуляция в действии!)
    public decimal GetBalance()
    {
        return _balance;
    }
}

// Создание объектов (экземпляров класса) в методе Main
class Program
{
    static void Main(string[] args)
    {
        // Создаем два объекта по чертежу BankAccount
        BankAccount aliceAccount = new BankAccount("12345", "Alice", 1000m);
        BankAccount bobAccount = new BankAccount("67890", "Bob", 500m);

        // Вызываем методы объектов
        aliceAccount.Deposit(200);
        aliceAccount.Withdraw(100);
        bobAccount.Withdraw(1000); // Попытка снять больше, чем есть

        Console.WriteLine($"Баланс Алисы: {aliceAccount.GetBalance()}"); // 1100
        Console.WriteLine($"Баланс Боба: {bobAccount.GetBalance()}");    // 500
    }
}
```

---

### **3. Четыре столпа ООП**

#### **3.1. Инкапсуляция**

**Концепция:** Механизм сокрытия внутренних данных и реализации объекта от внешнего мира. Доступ к данным осуществляется только через публичные методы и свойства.

**Зачем?**
*   **Контроль:** Мы можем добавлять проверки в методы (как в `Withdraw`).
*   **Гибкость:** Мы можем менять внутреннюю реализацию класса (например, хранить баланс не в `decimal`, а в `int` копейках), не ломая код, который этот класс использует.
*   **Надежность:** Внутреннее состояние объекта не может быть испорчено извне.

**Модификаторы доступа:**
*   `private`: Доступ только внутри этого класса. (Поле `_balance`).
*   `public`: Доступ откуда угодно. (Методы `Deposit`, `Withdraw`).
*   `protected`: Доступ внутри класса и в производных классах (см. Наследование).

**Пример с полным свойством (канонический способ в C#):**
```csharp
public class BankAccount
{
    private decimal _balance;

    // Публичное свойство с логикой в get и set
    public decimal Balance
    {
        get { return _balance; }
        private set { // setter является приватным!
            if (value >= 0) // Проверка при "установке"
                _balance = value;
        }
    }

    // Теперь метод Deposit может использовать свойство
    public void Deposit(decimal amount)
    {
        if (amount > 0)
        {
            Balance += amount; // Используется сеттер свойства Balance
        }
    }
    // GetBalance() больше не нужен, т.к. есть public get у Balance.
}
// В Main: Console.WriteLine(aliceAccount.Balance); // Работает (get)
// aliceAccount.Balance = 1000000; // Ошибка компиляции! set - private.
```

#### **3.2. Наследование**

**Концепция:** Позволяет создавать новый класс (производный, дочерний) на основе существующего (базового, родительского). Дочерний класс наследует все поля, свойства и методы родительского и может добавлять свои.

**Отношение "является" (is-a):** `SavingsAccount` (сберегательный счет) *является* `BankAccount` (банковским счетом).

**Пример:**
```csharp
// Базовый класс
public class BankAccount
{
    public string AccountNumber { get; set; }
    public string Owner { get; set; }
    public decimal Balance { get; protected set; } // protected set для доступа из наследников

    public BankAccount(string accountNumber, string owner, decimal initialBalance)
    {
        AccountNumber = accountNumber;
        Owner = owner;
        Balance = initialBalance;
    }

    public virtual void Deposit(decimal amount) // virtual - метод можно переопределить
    {
        if (amount > 0) Balance += amount;
    }

    public virtual void Withdraw(decimal amount)
    {
        if (amount > 0 && amount <= Balance) Balance -= amount;
    }
}

// Производный класс
public class SavingsAccount : BankAccount // Синтаксис наследования
{
    // Новое поле, специфичное для сберегательного счета
    public decimal InterestRate { get; set; }

    // Конструктор вызывает конструктор базового класса с помощью base(...)
    public SavingsAccount(string accountNumber, string owner, decimal initialBalance, decimal interestRate)
        : base(accountNumber, owner, initialBalance)
    {
        InterestRate = interestRate;
    }

    // Новый метод, которого нет в базовом классе
    public void ApplyInterest()
    {
        decimal interest = Balance * InterestRate / 100;
        Deposit(interest); // Используем унаследованный метод
        Console.WriteLine($"Начислены проценты: {interest}. Новый баланс: {Balance}");
    }

    // Переопределение метода базового класса (Полиморфизм!)
    public override void Withdraw(decimal amount)
    {
        // На сберегательном счете нельзя уходить в отрицательный баланс
        if (amount > 0 && amount <= Balance)
        {
            Balance -= amount;
            Console.WriteLine($"Со сберегательного счета {AccountNumber} снято {amount}.");
        }
        else
        {
            Console.WriteLine("Недостаточно средств на сберегательном счете.");
        }
    }
}

// Использование
class Program
{
    static void Main(string[] args)
    {
        SavingsAccount mySavings = new SavingsAccount("SAV-001", "Alice", 1000, 5.0m); // 5% годовых
        mySavings.Deposit(100); // Унаследованный метод
        mySavings.ApplyInterest(); // Собственный метод
        mySavings.Withdraw(500); // Вызовется ПЕРЕОПРЕДЕЛЕННЫЙ метод

        // Полиморфизм: SavingsAccount можно treated как BankAccount
        BankAccount account = mySavings;
        account.Withdraw(100); // Все равно вызовется переопределенный метод SavingsAccount!
    }
}
```

#### **3.3. Полиморфизм**

**Концепция:** Возможность объектов с одинаковой спецификацией (один базовый класс) иметь различную реализацию.

**"Один интерфейс — множество реализаций".** Мы можем работать с разными объектами (например, `BankAccount` и `SavingsAccount`) единым образом, но каждый из них будет вести себя по-своему.

**Как достигается?**
1.  **Переопределение виртуальных методов (как в примере выше с `Withdraw`).** Ключевые слова: `virtual` в базовом классе, `override` в производном.
2.  **Абстрактные классы и методы.**

**Пример с абстрактным классом:**
```csharp
// Абстрактный класс - его экземпляр создать нельзя. Это чистая абстракция.
public abstract class Shape
{
    public string Name { get; set; }

    // Абстрактный метод - не имеет реализации и ДОЛЖЕН быть переопределен в производном классе.
    public abstract double CalculateArea();

    // Виртуальный метод с реализацией по умолчанию
    public virtual void Display()
    {
        Console.WriteLine($"Это фигура: {Name}");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }

    public Circle(double radius)
    {
        Name = "Круг";
        Radius = radius;
    }

    // Реализация абстрактного метода ОБЯЗАТЕЛЬНА.
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }

    public Rectangle(double width, double height)
    {
        Name = "Прямоугольник";
        Width = width;
        Height = height;
    }

    public override double CalculateArea()
    {
        return Width * Height;
    }
}

// Демонстрация полиморфизма
class Program
{
    static void Main(string[] args)
    {
        // Создаем список фигур (можно хранить любых наследников Shape)
        List<Shape> shapes = new List<Shape>();
        shapes.Add(new Circle(5));
        shapes.Add(new Rectangle(4, 6));

        // Единый интерфейс для работы с разными фигурами
        foreach (Shape shape in shapes)
        {
            shape.Display();
            // Вызовется своя реализация CalculateArea для каждой фигуры!
            double area = shape.CalculateArea();
            Console.WriteLine($"Площадь: {area:F2}");
            Console.WriteLine("---");
        }
    }
}
```

#### **3.4. Абстракция**

**Концепция:** Процесс выделения существенных характеристик системы и игнорирования нерелевантных деталей.

**Мы уже использовали абстракцию:**
*   **Класс `BankAccount`** — это абстракция реального банковского счета. Нам не важны номера отделений или цвет карты в коде, который просто кладет деньги.
*   **Абстрактный класс `Shape`** — это чистая абстракция. Нам важно, что у фигуры есть площадь, но *как именно* она вычисляется — это деталь реализации конкретной фигуры.

**Интерфейсы — главный инструмент абстракции в C#.**
**Интерфейс** — это контракт, который класс обязуется выполнить. Он содержит только объявления методов, свойств, событий без их реализации.

**Пример интерфейса:**
```csharp
// Интерфейс для чего-то, что можно "включить"
public interface ITurnable
{
    void TurnOn();
    void TurnOff();
    bool IsOn { get; } // Свойство, которое должно быть реализовано
}

// Классы, не связанные наследованием, могут реализовать один интерфейс
public class Lamp : ITurnable
{
    public bool IsOn { get; private set; }

    public void TurnOn()
    {
        IsOn = true;
        Console.WriteLine("Лампа зажглась.");
    }

    public void TurnOff()
    {
        IsOn = false;
        Console.WriteLine("Лампа погасла.");
    }
}

public class Computer : ITurnable
{
    public bool IsOn { get; private set; }

    public void TurnOn()
    {
        IsOn = true;
        Console.WriteLine("Компьютер загружается...");
    }

    public void TurnOff()
    {
        IsOn = false;
        Console.WriteLine("Компьютер выключается.");
    }
}

// Абстракция в действии: мы работаем с объектами через интерфейс ITurnable
class Program
{
    static void Main(string[] args)
    {
        List<ITurnable> devices = new List<ITurnable>();
        devices.Add(new Lamp());
        devices.Add(new Computer());

        // Включаем все устройства, не зная их конкретного типа!
        foreach (ITurnable device in devices)
        {
            device.TurnOn();
        }
    }
}
```

---

### **4. Резюме**

*   **ООП** — это парадигма, основанная на объектах, объединяющих данные и поведение.
*   **Класс** — это чертеж, **Объект** — его конкретное воплощение.
*   **Инкапсуляция** скрывает внутреннее состояние и контролирует доступ к данным.
*   **Наследование** позволяет создавать иерархии классов, расширяя функциональность.
*   **Полиморфизм** позволяет объектам разных классов обрабатываться единым образом, но вести себя по-разному.
*   **Абстракция** позволяет сосредоточиться на том, *что* делает объект, а не на том, *как* он это делает, используя абстрактные классы и интерфейсы.

Вместе эти принципы позволяют создавать гибкий, понятный и легко поддерживаемый код.

---

### **5. Контрольные вопросы**

1.  **Базовые понятия:**
    *   В чем разница между классом и объектом? Приведите пример из реальной жизни.
    *   Что такое конструктор и для чего он нужен?
2.  **Инкапсуляция:**
    *   Почему объявление полей класса как `public` считается плохой практикой?
    *   Какие модификаторы доступа вы знаете и в чем их разница?
    *   Что такое "свойство" (Property) в C# и как оно связано с инкапсуляцией?
3.  **Наследование:**
    *   Какой синтаксис используется для наследования в C#?
    *   Что такое ключевое слово `base` и для чего оно применяется?
    *   Может ли класс наследоваться от нескольких классов в C#?
4.  **Полиморфизм:**
    *   В чем разница между виртуальным (`virtual`) и абстрактным (`abstract`) методом?
    *   Объясните, как полиморфизм проявляется в цикле `foreach` из примера с фигурами (`List<Shape> shapes`).
    *   Можно ли создать экземпляр абстрактного класса? Почему?
5.  **Абстракция и Интерфейсы:**
    *   В чем основное различие между абстрактным классом и интерфейсом?
    *   Когда вы бы предпочли использовать интерфейс, а когда абстрактный класс?
    *   Может ли класс реализовывать несколько интерфейсов?
6.  **Практический вопрос:**
    *   Спроектируйте простую иерархию классов для системы сотрудников компании. Есть базовый класс `Employee` (Сотрудник) с полями `Name` и `Salary`. Создайте два производных класса: `Manager` (Менеджер), у которого есть дополнительное поле `Bonus`, и `Developer` (Разработчик), у которого есть поле `ProgrammingLanguage`. Подумайте, какие методы можно сделать виртуальными/переопределить (например, метод `CalculateAnnualSalary`).