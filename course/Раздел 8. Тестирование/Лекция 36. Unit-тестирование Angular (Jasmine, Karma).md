# Лекция. Unit тестирование в Angular (Jasmine, Karma)

## Тема: Основы Unit тестирования в Angular с использованием Jasmine и Karma

## План лекции:

1. **Введение в Unit тестирование**
   - Что такое Unit тестирование?
   - Преимущества Unit тестирования
   - Пирамида тестирования

2. **Обзор инструментов: Jasmine и Karma**
   - Jasmine: фреймворк для тестирования
   - Karma: test runner
   - Структура теста в Jasmine

3. **Тестирование компонентов**
   - Создание тестового окружения
   - TestBed и ComponentFixture
   - Mocking зависимостей
   - Тестирование шаблонов и событий

4. **Тестирование сервисов**
   - Тестирование простых сервисов
   - Mocking HTTP запросов
   - Тестирование с HttpClientTestingModule

5. **Тестирование пайпов и директив**
   - Тестирование чистых пайпов
   - Тестирование директив

6. **Практические примеры и лучшие практики**
   - Организация тестов
   - Паттерны именования
   - Покрытие кода

## Детальное рассмотрение каждого пункта плана:

### 1. Введение в Unit тестирование

**Что такое Unit тестирование?**
Unit тестирование - это метод тестирования программного обеспечения, при котором проверяются отдельные модули (юниты) кода на корректность работы. В Angular юнитом считается компонент, сервис, пайп или директива.

**Преимущества Unit тестирования:**
- Раннее обнаружение ошибок
- Упрощение рефакторинга
- Документирование кода
- Повышение качества кода

**Пирамида тестирования:**
```
    /\
   /  \    E2E тесты (мало)
  /____\   Интеграционные тесты (средне)
 /______\  Unit тесты (много)
```

**Пример бизнес-логики для тестирования:**
```typescript
// math.service.ts
export class MathService {
  add(a: number, b: number): number {
    return a + b;
  }
  
  multiply(a: number, b: number): number {
    return a * b;
  }
  
  isEven(num: number): boolean {
    return num % 2 === 0;
  }
}
```

### 2. Обзор инструментов: Jasmine и Karma

**Jasmine - фреймворк для тестирования:**
- Describe блоки для группировки тестов
- It блоки для отдельных тестов
- Expect для утверждений (assertions)

**Структура теста в Jasmine:**
```typescript
describe('MathService', () => {
  let service: MathService;
  
  // Setup
  beforeEach(() => {
    service = new MathService();
  });
  
  describe('add method', () => {
    it('should add two positive numbers correctly', () => {
      // Arrange
      const a = 5;
      const b = 3;
      
      // Act
      const result = service.add(a, b);
      
      // Assert
      expect(result).toBe(8);
    });
    
    it('should handle negative numbers', () => {
      expect(service.add(-2, -3)).toBe(-5);
    });
  });
  
  describe('isEven method', () => {
    it('should return true for even numbers', () => {
      expect(service.isEven(4)).toBeTrue();
      expect(service.isEven(0)).toBeTrue();
    });
    
    it('should return false for odd numbers', () => {
      expect(service.isEven(3)).toBeFalse();
      expect(service.isEven(7)).toBeFalse();
    });
  });
});
```

**Karma - test runner:**
- Запускает тесты в реальных браузерах
- Генерирует отчеты о покрытии
- Работает в режиме watch

### 3. Тестирование компонентов

**Создание тестового окружения:**
```typescript
// user-profile.component.ts
@Component({
  selector: 'app-user-profile',
  template: `
    <div *ngIf="user">
      <h2>{{ user.name }}</h2>
      <p>Email: {{ user.email }}</p>
      <button (click)="onEdit()">Edit</button>
    </div>
  `
})
export class UserProfileComponent {
  @Input() user: User | null = null;
  @Output() edit = new EventEmitter<void>();
  
  onEdit(): void {
    this.edit.emit();
  }
}
```

**Тестирование компонента:**
```typescript
// user-profile.component.spec.ts
describe('UserProfileComponent', () => {
  let component: UserProfileComponent;
  let fixture: ComponentFixture<UserProfileComponent>;
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [UserProfileComponent]
    }).compileComponents();
  });
  
  beforeEach(() => {
    fixture = TestBed.createComponent(UserProfileComponent);
    component = fixture.componentInstance;
  });
  
  it('should create', () => {
    expect(component).toBeTruthy();
  });
  
  it('should display user information when user is provided', () => {
    // Arrange
    const mockUser: User = { 
      id: 1, 
      name: 'John Doe', 
      email: 'john@example.com' 
    };
    component.user = mockUser;
    
    // Act
    fixture.detectChanges();
    
    // Assert
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('h2').textContent).toContain('John Doe');
    expect(compiled.querySelector('p').textContent).toContain('john@example.com');
  });
  
  it('should emit edit event when edit button is clicked', () => {
    // Arrange
    const mockUser: User = { 
      id: 1, 
      name: 'John Doe', 
      email: 'john@example.com' 
    };
    component.user = mockUser;
    fixture.detectChanges();
    
    spyOn(component.edit, 'emit');
    const button = fixture.nativeElement.querySelector('button');
    
    // Act
    button.click();
    
    // Assert
    expect(component.edit.emit).toHaveBeenCalled();
  });
  
  it('should not display user info when user is null', () => {
    // Arrange
    component.user = null;
    
    // Act
    fixture.detectChanges();
    
    // Assert
    const compiled = fixture.nativeElement;
    expect(compiled.querySelector('h2')).toBeNull();
  });
});
```

**Mocking зависимостей:**
```typescript
// product-list.component.ts
@Component({
  selector: 'app-product-list',
  template: `
    <div *ngFor="let product of products$ | async">
      {{ product.name }} - {{ product.price }}
    </div>
  `
})
export class ProductListComponent implements OnInit {
  products$: Observable<Product[]>;
  
  constructor(private productService: ProductService) {}
  
  ngOnInit(): void {
    this.products$ = this.productService.getProducts();
  }
}
```

**Тестирование с моками:**
```typescript
// product-list.component.spec.ts
describe('ProductListComponent', () => {
  let component: ProductListComponent;
  let fixture: ComponentFixture<ProductListComponent>;
  let mockProductService: jasmine.SpyObj<ProductService>;
  
  beforeEach(async () => {
    // Create mock service
    mockProductService = jasmine.createSpyObj('ProductService', ['getProducts']);
    
    await TestBed.configureTestingModule({
      declarations: [ProductListComponent],
      providers: [
        { provide: ProductService, useValue: mockProductService }
      ]
    }).compileComponents();
  });
  
  beforeEach(() => {
    fixture = TestBed.createComponent(ProductListComponent);
    component = fixture.componentInstance;
  });
  
  it('should display products from service', () => {
    // Arrange
    const mockProducts: Product[] = [
      { id: 1, name: 'Laptop', price: 1000 },
      { id: 2, name: 'Mouse', price: 25 }
    ];
    
    mockProductService.getProducts.and.returnValue(of(mockProducts));
    
    // Act
    fixture.detectChanges();
    
    // Assert
    const compiled = fixture.nativeElement;
    expect(compiled.textContent).toContain('Laptop');
    expect(compiled.textContent).toContain('Mouse');
    expect(mockProductService.getProducts).toHaveBeenCalled();
  });
});
```

### 4. Тестирование сервисов

**Тестирование простых сервисов:**
```typescript
// calculator.service.ts
@Injectable({
  providedIn: 'root'
})
export class CalculatorService {
  private history: string[] = [];
  
  add(a: number, b: number): number {
    const result = a + b;
    this.history.push(`${a} + ${b} = ${result}`);
    return result;
  }
  
  getHistory(): string[] {
    return [...this.history];
  }
  
  clearHistory(): void {
    this.history = [];
  }
}
```

**Тестирование сервиса:**
```typescript
// calculator.service.spec.ts
describe('CalculatorService', () => {
  let service: CalculatorService;
  
  beforeEach(() => {
    TestBed.configureTestingModule({});
    service = TestBed.inject(CalculatorService);
  });
  
  it('should be created', () => {
    expect(service).toBeTruthy();
  });
  
  describe('add method', () => {
    it('should add two numbers and store in history', () => {
      // Act
      const result = service.add(2, 3);
      
      // Assert
      expect(result).toBe(5);
      expect(service.getHistory()).toContain('2 + 3 = 5');
    });
    
    it('should handle multiple operations', () => {
      service.add(1, 1);
      service.add(5, 10);
      
      const history = service.getHistory();
      expect(history.length).toBe(2);
      expect(history).toContain('1 + 1 = 2');
      expect(history).toContain('5 + 10 = 15');
    });
  });
  
  describe('clearHistory', () => {
    it('should clear the history', () => {
      // Arrange
      service.add(1, 1);
      expect(service.getHistory().length).toBe(1);
      
      // Act
      service.clearHistory();
      
      // Assert
      expect(service.getHistory().length).toBe(0);
    });
  });
});
```

**Mocking HTTP запросов:**
```typescript
// user.service.ts
@Injectable({
  providedIn: 'root'
})
export class UserService {
  private apiUrl = 'https://api.example.com/users';
  
  constructor(private http: HttpClient) {}
  
  getUsers(): Observable<User[]> {
    return this.http.get<User[]>(this.apiUrl);
  }
  
  getUserById(id: number): Observable<User> {
    return this.http.get<User>(`${this.apiUrl}/${id}`);
  }
  
  createUser(user: User): Observable<User> {
    return this.http.post<User>(this.apiUrl, user);
  }
}
```

**Тестирование с HttpClientTestingModule:**
```typescript
// user.service.spec.ts
describe('UserService', () => {
  let service: UserService;
  let httpTestingController: HttpTestingController;
  
  beforeEach(() => {
    TestBed.configureTestingModule({
      imports: [HttpClientTestingModule],
      providers: [UserService]
    });
    
    service = TestBed.inject(UserService);
    httpTestingController = TestBed.inject(HttpTestingController);
  });
  
  afterEach(() => {
    httpTestingController.verify();
  });
  
  it('should be created', () => {
    expect(service).toBeTruthy();
  });
  
  describe('getUsers', () => {
    it('should return users from API', () => {
      // Arrange
      const mockUsers: User[] = [
        { id: 1, name: 'John', email: 'john@test.com' },
        { id: 2, name: 'Jane', email: 'jane@test.com' }
      ];
      
      // Act & Assert
      service.getUsers().subscribe(users => {
        expect(users).toEqual(mockUsers);
        expect(users.length).toBe(2);
      });
      
      // Assert HTTP call
      const req = httpTestingController.expectOne('https://api.example.com/users');
      expect(req.request.method).toBe('GET');
      
      // Respond with mock data
      req.flush(mockUsers);
    });
  });
  
  describe('getUserById', () => {
    it('should return user by id', () => {
      const mockUser: User = { id: 1, name: 'John', email: 'john@test.com' };
      
      service.getUserById(1).subscribe(user => {
        expect(user).toEqual(mockUser);
      });
      
      const req = httpTestingController.expectOne('https://api.example.com/users/1');
      expect(req.request.method).toBe('GET');
      req.flush(mockUser);
    });
  });
  
  describe('createUser', () => {
    it('should create new user', () => {
      const newUser: User = { id: 0, name: 'Bob', email: 'bob@test.com' };
      const createdUser: User = { id: 3, name: 'Bob', email: 'bob@test.com' };
      
      service.createUser(newUser).subscribe(user => {
        expect(user).toEqual(createdUser);
      });
      
      const req = httpTestingController.expectOne('https://api.example.com/users');
      expect(req.request.method).toBe('POST');
      expect(req.request.body).toEqual(newUser);
      req.flush(createdUser);
    });
  });
});
```

### 5. Тестирование пайпов и директив

**Тестирование чистых пайпов:**
```typescript
// truncate.pipe.ts
@Pipe({
  name: 'truncate'
})
export class TruncatePipe implements PipeTransform {
  transform(value: string, limit: number = 50, completeWords: boolean = false, ellipsis: string = '...'): string {
    if (!value) return '';
    
    if (value.length <= limit) {
      return value;
    }
    
    if (completeWords) {
      limit = value.substr(0, limit).lastIndexOf(' ');
    }
    
    return value.substr(0, limit) + ellipsis;
  }
}
```

**Тестирование пайпа:**
```typescript
// truncate.pipe.spec.ts
describe('TruncatePipe', () => {
  let pipe: TruncatePipe;
  
  beforeEach(() => {
    pipe = new TruncatePipe();
  });
  
  it('should create an instance', () => {
    expect(pipe).toBeTruthy();
  });
  
  it('should return empty string for null input', () => {
    expect(pipe.transform(null as any)).toBe('');
  });
  
  it('should return original string when shorter than limit', () => {
    const input = 'Short text';
    expect(pipe.transform(input, 20)).toBe(input);
  });
  
  it('should truncate string when longer than limit', () => {
    const input = 'This is a very long text that needs to be truncated';
    const result = pipe.transform(input, 20);
    expect(result).toBe('This is a very long...');
  });
  
  it('should respect completeWords parameter', () => {
    const input = 'This is a very long text that needs to be truncated';
    const result = pipe.transform(input, 20, true);
    expect(result).toBe('This is a very...');
  });
  
  it('should use custom ellipsis', () => {
    const input = 'This is a very long text';
    const result = pipe.transform(input, 10, false, '***');
    expect(result).toBe('This is a ***');
  });
});
```

**Тестирование директив:**
```typescript
// highlight.directive.ts
@Directive({
  selector: '[appHighlight]'
})
export class HighlightDirective {
  @Input() appHighlight = 'yellow';
  
  constructor(private el: ElementRef) {}
  
  @HostListener('mouseenter') onMouseEnter() {
    this.highlight(this.appHighlight);
  }
  
  @HostListener('mouseleave') onMouseLeave() {
    this.highlight('');
  }
  
  private highlight(color: string): void {
    this.el.nativeElement.style.backgroundColor = color;
  }
}
```

**Тестирование директивы:**
```typescript
// highlight.directive.spec.ts
describe('HighlightDirective', () => {
  let fixture: ComponentFixture<TestComponent>;
  let divElement: HTMLDivElement;
  
  @Component({
    template: `<div [appHighlight]="color">Test Content</div>`
  })
  class TestComponent {
    color = 'red';
  }
  
  beforeEach(async () => {
    await TestBed.configureTestingModule({
      declarations: [HighlightDirective, TestComponent]
    }).compileComponents();
    
    fixture = TestBed.createComponent(TestComponent);
    divElement = fixture.nativeElement.querySelector('div');
    fixture.detectChanges();
  });
  
  it('should create directive', () => {
    expect(divElement).toBeTruthy();
  });
  
  it('should change background color on mouseenter', () => {
    // Act
    divElement.dispatchEvent(new Event('mouseenter'));
    
    // Assert
    expect(divElement.style.backgroundColor).toBe('red');
  });
  
  it('should remove background color on mouseleave', () => {
    // Arrange
    divElement.dispatchEvent(new Event('mouseenter'));
    expect(divElement.style.backgroundColor).toBe('red');
    
    // Act
    divElement.dispatchEvent(new Event('mouseleave'));
    
    // Assert
    expect(divElement.style.backgroundColor).toBe('');
  });
});
```

### 6. Практические примеры и лучшие практики

**Организация тестов:**
```
src/
  app/
    components/
      user-profile/
        user-profile.component.ts
        user-profile.component.html
        user-profile.component.spec.ts
    services/
      user.service.ts
      user.service.spec.ts
    pipes/
      truncate.pipe.ts
      truncate.pipe.spec.ts
```

**Паттерны именования:**
```typescript
// Хорошие примеры именования
describe('UserService', () => {
  describe('when getUser is called', () => {
    describe('and user exists', () => {
      it('should return user data', () => { ... });
    });
    
    describe('and user does not exist', () => {
      it('should throw NotFound error', () => { ... });
    });
  });
});

// Плохие примеры
describe('Test service', () => {
  it('should work', () => { ... }); // Слишком общее
});
```

**Лучшие практики:**
- Один тест - одна ответственность
- Используйте понятные названия тестов
- Тестируйте как позитивные, так и негативные сценарии
- Минимизируйте логику в тестах
- Используйте моки для внешних зависимостей

**Пример комплексного теста:**
```typescript
describe('LoginComponent', () => {
  let component: LoginComponent;
  let fixture: ComponentFixture<LoginComponent>;
  let authService: jasmine.SpyObj<AuthService>;
  let router: jasmine.SpyObj<Router>;
  
  beforeEach(async () => {
    const authServiceSpy = jasmine.createSpyObj('AuthService', ['login']);
    const routerSpy = jasmine.createSpyObj('Router', ['navigate']);
    
    await TestBed.configureTestingModule({
      declarations: [LoginComponent],
      imports: [ReactiveFormsModule],
      providers: [
        { provide: AuthService, useValue: authServiceSpy },
        { provide: Router, useValue: routerSpy }
      ]
    }).compileComponents();
    
    fixture = TestBed.createComponent(LoginComponent);
    component = fixture.componentInstance;
    authService = TestBed.inject(AuthService) as jasmine.SpyObj<AuthService>;
    router = TestBed.inject(Router) as jasmine.SpyObj<Router>;
  });
  
  it('should create login form with empty fields', () => {
    expect(component.loginForm).toBeDefined();
    expect(component.loginForm.get('email')?.value).toBe('');
    expect(component.loginForm.get('password')?.value).toBe('');
  });
  
  it('should validate email field', () => {
    const email = component.loginForm.get('email');
    
    email?.setValue('invalid-email');
    expect(email?.valid).toBeFalse();
    
    email?.setValue('valid@email.com');
    expect(email?.valid).toBeTrue();
  });
  
  it('should call authService.login and navigate on successful login', () => {
    // Arrange
    const mockResponse = { success: true, token: 'abc123' };
    authService.login.and.returnValue(of(mockResponse));
    
    component.loginForm.setValue({
      email: 'test@example.com',
      password: 'password123'
    });
    
    // Act
    component.onSubmit();
    
    // Assert
    expect(authService.login).toHaveBeenCalledWith('test@example.com', 'password123');
    expect(router.navigate).toHaveBeenCalledWith(['/dashboard']);
  });
  
  it('should show error message on login failure', () => {
    // Arrange
    const mockError = { error: 'Invalid credentials' };
    authService.login.and.returnValue(throwError(() => mockError));
    
    component.loginForm.setValue({
      email: 'test@example.com',
      password: 'wrongpassword'
    });
    
    // Act
    component.onSubmit();
    
    // Assert
    expect(component.errorMessage).toBe('Invalid credentials');
    expect(router.navigate).not.toHaveBeenCalled();
  });
});
```

## Резюме:

Unit тестирование в Angular - это критически важная практика для обеспечения качества кода. Основные инструменты - Jasmine для написания тестов и Karma для их запуска. Ключевые аспекты:

- **Компоненты** тестируются с помощью TestBed и ComponentFixture
- **Сервисы** тестируются с моками зависимостей и HttpClientTestingModule
- **Пайпы и директивы** тестируются изолированно
- **Лучшие практики** включают правильную организацию тестов, именование и покрытие различных сценариев

## Контрольные вопросы:

1. **Что такое Unit тестирование и каковы его основные преимущества?**
   - Проверка отдельных модулей кода
   - Раннее обнаружение ошибок, упрощение рефакторинга, документация

2. **Каковы основные блоки структуры теста в Jasmine?**
   - describe, beforeEach, it, expect

3. **Как создать мок сервиса для тестирования компонента?**
   - Использование jasmine.createSpyObj()

4. **Как тестировать HTTP запросы в Angular сервисах?**
   - С помощью HttpClientTestingModule и HttpTestingController

5. **Какие методы используются для взаимодействия с DOM в тестах компонентов?**
   - fixture.nativeElement, fixture.debugElement

6. **Как тестировать пользовательские события (клики, ввод данных)?**
   - dispatchEvent для нативных элементов или DebugElement.triggerEventHandler

7. **Что такое TestBed и для чего он используется?**
   - Утилита для создания тестового модуля Angular

8. **Как организовать тесты для пайпов?**
   - Создание экземпляра пайпа и вызов transform метода

9. **Какие лучшие практики именования тестов вы знаете?**
   - Описательные названия, структура "should ... when ..."

10. **Как проверить, что метод был вызван с определенными параметрами?**
    - expect(service.method).toHaveBeenCalledWith(expectedArgs)