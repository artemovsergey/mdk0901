# Лекция. Unit тестирование в .NET с использованием xUnit

## Тема
"Основы модульного тестирования в .NET: Практическое руководство по xUnit"

## План
1. Введение в Unit тестирование
2. Обзор фреймворков для тестирования в .NET
3. Настройка xUnit в проекте
4. Структура тестового класса и методы
5. Атрибуты и утверждения (Assertions)
6. Тестовые данные: Theory и InlineData
7. Mocking и изоляция зависимостей
8. Best Practices и паттерны
9. Интеграция с CI/CD

## Резюме
Unit тестирование - критически важная практика в современной разработке, обеспечивающая надежность кода. xUnit представляет собой мощный и гибкий фреймворк для создания модульных тестов в .NET. Лекция охватывает все аспекты работы с xUnit - от базовых концепций до продвинутых техник мокинга и интеграции в процессы разработки.

---

## Подробное рассмотрение каждого пункта плана

### 1. Введение в Unit тестирование

**Что такое Unit тестирование?**
Unit тестирование - это метод тестирования программного обеспечения, при котором отдельные модули (юниты) кода проверяются на корректность работы. Юнитом обычно считается наименьшая тестируемая часть приложения - метод или функция.

**Преимущества Unit тестирования:**
- Раннее обнаружение ошибок
- Упрощение рефакторинга
- Документирование кода
- Ускорение разработки

**Принципы хороших тестов (FIRST):**
- **F**ast - быстрые
- **I**ndependent - независимые
- **R**epeatable - повторяемые
- **S**elf-validating - самопроверяемые
- **T**imely - своевременные

**Пример проблемы без тестирования:**
```csharp
public class Calculator
{
    public decimal Divide(decimal a, decimal b)
    {
        return a / b;
    }
}

// Без тестов можно пропустить критическую ошибку - деление на ноль!
```

### 2. Обзор фреймворков для тестирования в .NET

**xUnit.net**
- Современный фреймворк, созданный автором NUnit
- Чистая архитектура, простота использования
- Активно развивается и поддерживается

**Сравнение с другими фреймворками:**

| Фреймворк | Преимущества | Недостатки |
|-----------|--------------|------------|
| **xUnit** | Чистая архитектура, гибкость, хорошая документация | Меньше встроенных функций |
| **NUnit** | Богатый функционал, много атрибутов | Более сложная архитектура |
| **MSTest** | Интеграция с Visual Studio | Менее гибкий |

**Когда выбирать xUnit:**
- Новые проекты
- Требуется чистая архитектура
- Кроссплатформенная разработка

### 3. Настройка xUnit в проекте

**Шаг 1: Создание тестового проекта**
```bash
dotnet new xunit -n MyProject.Tests
cd MyProject.Tests
```

**Шаг 2: Добавление зависимостей**
```xml
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <IsPackable>false</IsPackable>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
    <PackageReference Include="xunit" Version="2.6.6" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.6">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
    <PackageReference Include="coverlet.collector" Version="6.0.0">
      <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
      <PrivateAssets>all</PrivateAssets>
    </PackageReference>
  </ItemGroup>

  <ItemGroup>
    <ProjectReference Include="..\MyProject\MyProject.csproj" />
  </ItemGroup>

</Project>
```

**Шаг 3: Базовая структура проекта**
```
MySolution/
├── MyProject/
│   ├── Services/
│   ├── Models/
│   └── MyProject.csproj
└── MyProject.Tests/
    ├── UnitTests/
    ├── IntegrationTests/
    └── MyProject.Tests.csproj
```

### 4. Структура тестового класса и методы

**Соглашения по именованию:**
- Классы тестов: `[ClassName]Tests`
- Методы тестов: `[MethodName]_[Scenario]_[ExpectedResult]`

**Пример тестового класса:**
```csharp
public class CalculatorTests
{
    private readonly Calculator _calculator;

    // Конструктор для инициализации общих зависимостей
    public CalculatorTests()
    {
        _calculator = new Calculator();
    }

    [Fact]
    public void Add_TwoPositiveNumbers_ReturnsCorrectSum()
    {
        // Arrange - подготовка данных
        decimal a = 5;
        decimal b = 3;
        decimal expected = 8;

        // Act - выполнение действия
        decimal actual = _calculator.Add(a, b);

        // Assert - проверка результата
        Assert.Equal(expected, actual);
    }

    // Тест с очисткой ресурсов
    public void Dispose()
    {
        _calculator?.Dispose();
    }
}
```

**Жизненный цикл теста в xUnit:**
1. Создание экземпляра тестового класса
2. Вызов конструктора
3. Вызов тестового метода
4. Вызов Dispose (если есть)

### 5. Атрибуты и утверждения (Assertions)

**Основные атрибуты xUnit:**

```csharp
public class AttributeExamples
{
    [Fact] // Базовый тест без параметров
    public void BasicTest() { }

    [Theory] // Параметризованный тест
    [InlineData(1, 2, 3)]
    public void ParameterizedTest(int a, int b, int expected) { }

    [Fact(Skip = "В разработке")] // Пропущенный тест
    public void SkippedTest() { }

    [Fact(DisplayName = "Мой кастомный тест")] // Кастомное имя
    public void TestWithCustomName() { }
}
```

**Методы Assert - подробно с примерами:**

```csharp
public class AssertExamples
{
    [Fact]
    public void EqualityAsserts()
    {
        string expected = "Hello";
        string actual = "Hello";

        Assert.Equal(expected, actual);
        Assert.NotEqual("World", actual);
        
        // Для чисел с плавающей точкой
        double result = 1.0 / 3.0;
        Assert.Equal(0.333, result, 3); // precision: 3 знака после запятой
    }

    [Fact]
    public void BooleanAsserts()
    {
        bool isActive = true;
        bool isDeleted = false;

        Assert.True(isActive);
        Assert.False(isDeleted);
    }

    [Fact]
    public void NullAsserts()
    {
        string nullString = null;
        string notNullString = "text";

        Assert.Null(nullString);
        Assert.NotNull(notNullString);
    }

    [Fact]
    public void CollectionAsserts()
    {
        var numbers = new List<int> { 1, 2, 3 };
        var emptyList = new List<int>();

        Assert.Contains(2, numbers);
        Assert.DoesNotContain(4, numbers);
        Assert.Empty(emptyList);
        Assert.NotEmpty(numbers);
        
        // Проверка конкретных элементов
        Assert.All(numbers, x => Assert.True(x > 0));
    }

    [Fact]
    public void ExceptionAsserts()
    {
        var calculator = new Calculator();

        // Проверка что метод выбрасывает исключение
        Assert.Throws<DivideByZeroException>(() => calculator.Divide(10, 0));
        
        // Проверка с возвратом исключения для дополнительных проверок
        var exception = Assert.Throws<ArgumentException>(() => 
            calculator.SquareRoot(-1));
        Assert.Contains("negative", exception.Message);
    }

    [Fact]
    public void TypeAsserts()
    {
        object stringObj = "Hello";
        object intObj = 42;

        Assert.IsType<string>(stringObj);
        Assert.IsNotType<int>(stringObj);
        Assert.IsAssignableFrom<IEnumerable<char>>(stringObj);
    }

    [Fact]
    public void RangeAsserts()
    {
        int number = 15;

        Assert.InRange(number, 10, 20);
        Assert.NotInRange(number, 20, 30);
    }

    [Fact]
    public void AdvancedAsserts()
    {
        // Проверка с кастомным компаратором
        var list1 = new List<int> { 1, 2, 3 };
        var list2 = new List<int> { 1, 2, 3 };

        Assert.Equal(list1, list2);
        
        // Проверка ссылочной равенства
        var obj1 = new object();
        var obj2 = obj1;
        Assert.Same(obj1, obj2);
        Assert.NotSame(new object(), new object());
    }
}
```

### 6. Тестовые данные: Theory и InlineData

**Параметризованные тесты с различными источниками данных:**

```csharp
public class TheoryExamples
{
    [Theory]
    [InlineData(1, 1, 2)]
    [InlineData(2, 3, 5)]
    [InlineData(0, 0, 0)]
    [InlineData(-1, 1, 0)]
    public void Add_VariousNumbers_ReturnsCorrectSum(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Add(a, b);
        Assert.Equal(expected, result);
    }

    // Использование MemberData для сложных данных
    public static IEnumerable<object[]> ComplexTestData =>
        new List<object[]>
        {
            new object[] { new DateTime(2023, 1, 1), "January" },
            new object[] { new DateTime(2023, 6, 1), "June" },
            new object[] { new DateTime(2023, 12, 1), "December" }
        };

    [Theory]
    [MemberData(nameof(ComplexTestData))]
    public void GetMonthName_VariousDates_ReturnsCorrectName(DateTime date, string expectedMonth)
    {
        var result = date.ToString("MMMM");
        Assert.Equal(expectedMonth, result);
    }

    // Использование ClassData
    [Theory]
    [ClassData(typeof(CalculatorTestData))]
    public void Multiply_VariousNumbers_ReturnsCorrectProduct(int a, int b, int expected)
    {
        var calculator = new Calculator();
        var result = calculator.Multiply(a, b);
        Assert.Equal(expected, result);
    }
}

public class CalculatorTestData : IEnumerable<object[]>
{
    public IEnumerator<object[]> GetEnumerator()
    {
        yield return new object[] { 2, 3, 6 };
        yield return new object[] { 5, 0, 0 };
        yield return new object[] { -2, 4, -8 };
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
```

### 7. Mocking и изоляция зависимостей

**Установка Moq (популярная библиотека для мокинга):**
```xml
<PackageReference Include="Moq" Version="4.20.69" />
```

**Примеры мокинга с Moq:**

```csharp
public interface IUserRepository
{
    User GetUserById(int id);
    void SaveUser(User user);
    bool UserExists(string email);
}

public interface IEmailService
{
    void SendWelcomeEmail(string email);
}

public class UserService
{
    private readonly IUserRepository _userRepository;
    private readonly IEmailService _emailService;

    public UserService(IUserRepository userRepository, IEmailService emailService)
    {
        _userRepository = userRepository;
        _emailService = emailService;
    }

    public User CreateUser(string name, string email)
    {
        if (_userRepository.UserExists(email))
            throw new InvalidOperationException("User already exists");

        var user = new User { Name = name, Email = email };
        _userRepository.SaveUser(user);
        _emailService.SendWelcomeEmail(email);
        return user;
    }
}

public class UserServiceTests
{
    [Fact]
    public void CreateUser_ValidData_CreatesUserAndSendsEmail()
    {
        // Arrange
        var mockRepository = new Mock<IUserRepository>();
        var mockEmailService = new Mock<IEmailService>();
        
        var userService = new UserService(mockRepository.Object, mockEmailService.Object);
        var userName = "John Doe";
        var userEmail = "john@example.com";

        // Настройка моков
        mockRepository.Setup(r => r.UserExists(userEmail)).Returns(false);
        mockRepository.Setup(r => r.SaveUser(It.IsAny<User>()))
                     .Callback<User>(user => 
                     {
                         Assert.Equal(userName, user.Name);
                         Assert.Equal(userEmail, user.Email);
                     });

        // Act
        var result = userService.CreateUser(userName, userEmail);

        // Assert
        Assert.NotNull(result);
        Assert.Equal(userName, result.Name);
        Assert.Equal(userEmail, result.Email);
        
        // Проверка что методы были вызваны
        mockRepository.Verify(r => r.UserExists(userEmail), Times.Once);
        mockRepository.Verify(r => r.SaveUser(It.IsAny<User>()), Times.Once);
        mockEmailService.Verify(e => e.SendWelcomeEmail(userEmail), Times.Once);
    }

    [Fact]
    public void CreateUser_ExistingEmail_ThrowsException()
    {
        // Arrange
        var mockRepository = new Mock<IUserRepository>();
        var mockEmailService = new Mock<IEmailService>();
        
        var userService = new UserService(mockRepository.Object, mockEmailService.Object);
        var existingEmail = "existing@example.com";

        mockRepository.Setup(r => r.UserExists(existingEmail)).Returns(true);

        // Act & Assert
        var exception = Assert.Throws<InvalidOperationException>(() => 
            userService.CreateUser("John", existingEmail));
            
        Assert.Contains("already exists", exception.Message);
        
        // Проверка что SaveUser и SendWelcomeEmail не вызывались
        mockRepository.Verify(r => r.SaveUser(It.IsAny<User>()), Times.Never);
        mockEmailService.Verify(e => e.SendWelcomeEmail(It.IsAny<string>()), Times.Never);
    }
}
```

**Продвинутые техники мокинга:**

```csharp
public class AdvancedMockingExamples
{
    [Fact]
    public void MockWithSequence()
    {
        var mock = new Mock<ICalculator>();
        
        // Настройка последовательных вызовов
        mock.SetupSequence(x => x.GetNextNumber())
            .Returns(1)
            .Returns(2)
            .Returns(3)
            .Throws(new InvalidOperationException());

        var calculator = mock.Object;
        
        Assert.Equal(1, calculator.GetNextNumber());
        Assert.Equal(2, calculator.GetNextNumber());
        Assert.Equal(3, calculator.GetNextNumber());
        Assert.Throws<InvalidOperationException>(() => calculator.GetNextNumber());
    }

    [Fact]
    public void MockWithProperties()
    {
        var mock = new Mock<IConfigService>();
        
        // Настройка свойства
        mock.SetupProperty(x => x.ConnectionString, "default_connection");
        mock.Setup(x => x.IsConnected).Returns(true);

        var config = mock.Object;
        
        Assert.Equal("default_connection", config.ConnectionString);
        Assert.True(config.IsConnected);
        
        // Изменение свойства
        config.ConnectionString = "new_connection";
        Assert.Equal("new_connection", config.ConnectionString);
    }
}
```

### 8. Best Practices и паттерны

**Принципы хороших тестов:**

**1. Паттерн AAA (Arrange-Act-Assert)**
```csharp
[Fact]
public void CalculateDiscount_PremiumCustomer_ReturnsHigherDiscount()
{
    // Arrange
    var customer = new Customer { IsPremium = true, TotalPurchases = 1000 };
    var discountService = new DiscountService();
    decimal expectedDiscount = 0.15m;

    // Act
    decimal actualDiscount = discountService.CalculateDiscount(customer);

    // Assert
    Assert.Equal(expectedDiscount, actualDiscount);
}
```

**2. One Assert Per Test (в большинстве случаев)**
```csharp
// ПЛОХО - несколько утверждений в одном тесте
[Fact]
public void CreateProduct_BadExample()
{
    var product = new Product("Laptop", 999.99m);
    
    Assert.Equal("Laptop", product.Name);
    Assert.Equal(999.99m, product.Price);
    Assert.NotNull(product.Id);
    Assert.True(product.IsActive);
}

// ХОРОШО - разделение на несколько тестов
[Fact]
public void CreateProduct_SetsCorrectName()
{
    var product = new Product("Laptop", 999.99m);
    Assert.Equal("Laptop", product.Name);
}

[Fact]
public void CreateProduct_SetsCorrectPrice()
{
    var product = new Product("Laptop", 999.99m);
    Assert.Equal(999.99m, product.Price);
}
```

**3. Meaningful Test Names**
```csharp
// ПЛОХО
[Fact]
public void Test1() { }

// ХОРОШО
[Fact]
public void CalculateTax_IncomeBelowThreshold_ReturnsZeroTax() { }

[Fact]
public void ProcessOrder_InvalidShippingAddress_ThrowsValidationException() { }
```

**4. Test Isolation**
```csharp
public class IsolatedTests
{
    private static int _sharedCounter = 0; // АНТИПАТТЕРН!

    [Fact]
    public void Test1()
    {
        _sharedCounter++;
        Assert.Equal(1, _sharedCounter); // Может упасть если тесты запускаются параллельно
    }
}

// Правильный подход - каждый тест независим
public class ProperIsolatedTests
{
    [Fact]
    public void Test1()
    {
        var counter = 1; // Локальная переменная
        Assert.Equal(1, counter);
    }
}
```

**5. Практический пример полного тестового класса:**

```csharp
public class OrderProcessorTests
{
    private readonly Mock<IInventoryService> _mockInventoryService;
    private readonly Mock<IPaymentService> _mockPaymentService;
    private readonly Mock<IShippingService> _mockShippingService;
    private readonly OrderProcessor _orderProcessor;

    public OrderProcessorTests()
    {
        _mockInventoryService = new Mock<IInventoryService>();
        _mockPaymentService = new Mock<IPaymentService>();
        _mockShippingService = new Mock<IShippingService>();
        
        _orderProcessor = new OrderProcessor(
            _mockInventoryService.Object,
            _mockPaymentService.Object,
            _mockShippingService.Object);
    }

    [Fact]
    public void ProcessOrder_ValidOrder_ProcessesSuccessfully()
    {
        // Arrange
        var order = new Order
        {
            Id = 1,
            Items = new List<OrderItem>
            {
                new OrderItem { ProductId = "P1", Quantity = 2 }
            },
            TotalAmount = 100.00m
        };

        _mockInventoryService.Setup(x => x.CheckStock("P1", 2)).Returns(true);
        _mockPaymentService.Setup(x => x.ProcessPayment(100.00m)).Returns(true);
        _mockShippingService.Setup(x => x.ScheduleDelivery(1));

        // Act
        var result = _orderProcessor.ProcessOrder(order);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.Equal(OrderStatus.Processed, order.Status);
        
        VerifyAllMocks();
    }

    [Theory]
    [InlineData(0)]
    [InlineData(-1)]
    public void ProcessOrder_InvalidQuantity_ThrowsException(int invalidQuantity)
    {
        // Arrange
        var order = new Order
        {
            Items = new List<OrderItem>
            {
                new OrderItem { ProductId = "P1", Quantity = invalidQuantity }
            }
        };

        // Act & Assert
        Assert.Throws<ArgumentException>(() => _orderProcessor.ProcessOrder(order));
        
        VerifyNoInteractions();
    }

    private void VerifyAllMocks()
    {
        _mockInventoryService.VerifyAll();
        _mockPaymentService.VerifyAll();
        _mockShippingService.VerifyAll();
    }

    private void VerifyNoInteractions()
    {
        _mockInventoryService.VerifyNoOtherCalls();
        _mockPaymentService.VerifyNoOtherCalls();
        _mockShippingService.VerifyNoOtherCalls();
    }
}
```

### 9. Интеграция с CI/CD

**Настройка GitHub Actions для запуска тестов:**

```yaml
name: .NET Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore --configuration Release
      
    - name: Test
      run: dotnet test --no-build --configuration Release --verbosity normal --logger "trx;LogFileName=test-results.trx"
      
    - name: Upload test results
      uses: actions/upload-artifact@v3
      with:
        name: test-results
        path: **/*test-results.trx
```

**Конфигурация для разных окружений:**

```xml
<!-- Directory.Build.props -->
<Project>
  <PropertyGroup>
    <TreatWarningsAsErrors>true</TreatWarningsAsErrors>
    <CodeAnalysisRuleSet>..\..\codeanalysis.ruleset</CodeAnalysisRuleSet>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Microsoft.NET.Test.Sdk" Version="17.8.0" />
    <PackageReference Include="xunit" Version="2.6.6" />
    <PackageReference Include="xunit.runner.visualstudio" Version="2.5.6" />
    <PackageReference Include="Moq" Version="4.20.69" />
  </ItemGroup>
</Project>
```

**Покрытие кода (Code Coverage):**

```xml
<PackageReference Include="coverlet.msbuild" Version="6.0.0">
  <IncludeAssets>runtime; build; native; contentfiles; analyzers; buildtransitive</IncludeAssets>
  <PrivateAssets>all</PrivateAssets>
</PackageReference>
```

```bash
dotnet test /p:CollectCoverage=true /p:CoverletOutput=./coverage/ /p:CoverletOutputFormat=cobertura
```

---

## Контрольные вопросы

### Базовые вопросы:
1. Что такое Unit тестирование и какие преимущества оно дает?
2. В чем основные различия между xUnit, NUnit и MSTest?
3. Каков жизненный цикл теста в xUnit?
4. Что такое паттерн AAA в тестировании?
5. Какие основные методы Assert вы знаете и для чего они используются?

### Продвинутые вопросы:
6. Как работают параметризованные тесты (Theory) в xUnit?
7. В чем разница между Mock и Stub?
8. Как обеспечить изоляцию тестов друг от друга?
9. Какие best practices вы бы рекомендовали для написания поддерживаемых тестов?
10. Как интегрировать тестирование в процесс CI/CD?

### Практические задания:
11. Напишите тест для метода, который должен выбрасывать исключение при определенных условиях
12. Создайте параметризованный тест для проверки математических операций с разными входными данными
13. Напишите тест с использованием Moq для класса, имеющего внешние зависимости
14. Продемонстрируйте проблему тестовой изоляции и покажите как ее решить

---

## Заключение

Unit тестирование с xUnit - это мощный инструмент для создания надежного и поддерживаемого кода. Понимание принципов написания хороших тестов, владение техниками мокинга и интеграция тестирования в процесс разработки являются критически важными навыками для современного .NET разработчика.

Помните: хорошие тесты не только находят ошибки, но и служат документацией и обеспечивают уверенность при рефакторинге кода.