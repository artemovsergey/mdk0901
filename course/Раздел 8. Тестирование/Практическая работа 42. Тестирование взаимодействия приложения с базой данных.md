# Практическая работа: Тестирование взаимодействия с базой данных с использованием Testcontainers

## Тема
Тестирование взаимодействия с базой данных с использованием Testcontainers в .NET приложениях

## Цель
Освоить практические навыки написания интеграционных тестов для работы с базой данных PostgreSQL с использованием библиотеки Testcontainers для .NET. Научиться создавать изолированное тестовое окружение с реальной СУБД.

## Теоретическая часть

### Testcontainers
Testcontainers - это библиотека, которая позволяет запускать Docker-контейнеры в тестовых целях. Она предоставляет легковесные, одноразовые экземпляры баз данных, брокеров сообщений, веб-браузеров и других зависимостей.

### Преимущества Testcontainers:
- **Изоляция тестов**: каждый тест работает с чистой БД
- **Реалистичность**: использование реальной СУБД вместо моков
- **Простота настройки**: автоматическое создание и удаление контейнеров
- **Совместимость**: идентичное поведение в development и CI/CD среде

### Основные компоненты:
- `TestcontainersBuilder<T>` - построитель контейнеров
- `PostgreSqlContainer` - специализированный контейнер для PostgreSQL
- `IContainer` - интерфейс для управления контейнером

## Практический пример

### Структура проекта
```
TestcontainersDemo/
├── src/
│   └── UserService/
│       ├── Models/
│       ├── Services/
│       └── UserService.csproj
├── tests/
│   └── UserService.Tests/
│       ├── UserServiceTests.cs
│       └── UserService.Tests.csproj
├── images/
└── README.md
```

### Пример кода приложения

**Models/User.cs**
```csharp
namespace UserService.Models
{
    public class User
    {
        public int Id { get; set; }
        public string FirstName { get; set; } = string.Empty;
        public string LastName { get; set; } = string.Empty;
        public string Email { get; set; } = string.Empty;
        public DateTime CreatedAt { get; set; }
    }
}
```

**Services/IUserRepository.cs**
```csharp
using UserService.Models;

namespace UserService.Services
{
    public interface IUserRepository
    {
        Task<User> CreateUserAsync(User user);
        Task<User?> GetUserByIdAsync(int id);
        Task<List<User>> GetAllUsersAsync();
        Task<bool> UpdateUserAsync(User user);
        Task<bool> DeleteUserAsync(int id);
        Task<User?> GetUserByEmailAsync(string email);
    }
}
```

**Services/UserRepository.cs**
```csharp
using Npgsql;
using UserService.Models;
using Dapper;

namespace UserService.Services
{
    public class UserRepository : IUserRepository
    {
        private readonly string _connectionString;

        public UserRepository(string connectionString)
        {
            _connectionString = connectionString;
        }

        public async Task<User> CreateUserAsync(User user)
        {
            using var connection = new NpgsqlConnection(_connectionString);
            var sql = @"INSERT INTO users (first_name, last_name, email, created_at) 
                       VALUES (@FirstName, @LastName, @Email, @CreatedAt) 
                       RETURNING id";
            var userId = await connection.ExecuteScalarAsync<int>(sql, user);
            user.Id = userId;
            return user;
        }

        public async Task<User?> GetUserByIdAsync(int id)
        {
            using var connection = new NpgsqlConnection(_connectionString);
            var sql = "SELECT * FROM users WHERE id = @Id";
            return await connection.QueryFirstOrDefaultAsync<User>(sql, new { Id = id });
        }

        public async Task<List<User>> GetAllUsersAsync()
        {
            using var connection = new NpgsqlConnection(_connectionString);
            var sql = "SELECT * FROM users ORDER BY id";
            var result = await connection.QueryAsync<User>(sql);
            return result.ToList();
        }

        public async Task<bool> UpdateUserAsync(User user)
        {
            using var connection = new NpgsqlConnection(_connectionString);
            var sql = @"UPDATE users 
                       SET first_name = @FirstName, last_name = @LastName, email = @Email 
                       WHERE id = @Id";
            var affectedRows = await connection.ExecuteAsync(sql, user);
            return affectedRows > 0;
        }

        public async Task<bool> DeleteUserAsync(int id)
        {
            using var connection = new NpgsqlConnection(_connectionString);
            var sql = "DELETE FROM users WHERE id = @Id";
            var affectedRows = await connection.ExecuteAsync(sql, new { Id = id });
            return affectedRows > 0;
        }

        public async Task<User?> GetUserByEmailAsync(string email)
        {
            using var connection = new NpgsqlConnection(_connectionString);
            var sql = "SELECT * FROM users WHERE email = @Email";
            return await connection.QueryFirstOrDefaultAsync<User>(sql, new { Email = email });
        }
    }
}
```

### Пример тестов

**UserServiceTests.cs**
```csharp
using Testcontainers.PostgreSql;
using UserService.Models;
using UserService.Services;
using Xunit;

namespace UserService.Tests
{
    public class UserServiceTests : IAsyncLifetime
    {
        private readonly PostgreSqlContainer _postgresContainer;
        private UserRepository _userRepository = null!;
        private string _connectionString = null!;

        public UserServiceTests()
        {
            _postgresContainer = new PostgreSqlBuilder()
                .WithImage("postgres:15-alpine")
                .WithDatabase("testdb")
                .WithUsername("postgres")
                .WithPassword("postgres")
                .WithCleanUp(true)
                .Build();
        }

        public async Task InitializeAsync()
        {
            await _postgresContainer.StartAsync();
            _connectionString = _postgresContainer.GetConnectionString();
            _userRepository = new UserRepository(_connectionString);
            
            // Создание таблицы
            await InitializeDatabase();
        }

        private async Task InitializeDatabase()
        {
            using var connection = new Npgsql.NpgsqlConnection(_connectionString);
            var sql = @"
                CREATE TABLE IF NOT EXISTS users (
                    id SERIAL PRIMARY KEY,
                    first_name VARCHAR(100) NOT NULL,
                    last_name VARCHAR(100) NOT NULL,
                    email VARCHAR(255) UNIQUE NOT NULL,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )";
            await connection.ExecuteAsync(sql);
        }

        public async Task DisposeAsync()
        {
            await _postgresContainer.DisposeAsync();
        }

        [Fact]
        public async Task CreateUser_ShouldAddUserToDatabase()
        {
            // Arrange
            var user = new User 
            { 
                FirstName = "John", 
                LastName = "Doe", 
                Email = "john.doe@example.com",
                CreatedAt = DateTime.UtcNow
            };

            // Act
            var createdUser = await _userRepository.CreateUserAsync(user);

            // Assert
            Assert.True(createdUser.Id > 0);
            Assert.Equal(user.FirstName, createdUser.FirstName);
            Assert.Equal(user.LastName, createdUser.LastName);
            Assert.Equal(user.Email, createdUser.Email);
        }

        [Fact]
        public async Task GetUserById_ShouldReturnCorrectUser()
        {
            // Arrange
            var user = new User 
            { 
                FirstName = "Jane", 
                LastName = "Smith", 
                Email = "jane.smith@example.com",
                CreatedAt = DateTime.UtcNow
            };
            var createdUser = await _userRepository.CreateUserAsync(user);

            // Act
            var retrievedUser = await _userRepository.GetUserByIdAsync(createdUser.Id);

            // Assert
            Assert.NotNull(retrievedUser);
            Assert.Equal(createdUser.Id, retrievedUser.Id);
            Assert.Equal(user.FirstName, retrievedUser.FirstName);
        }

        [Fact]
        public async Task GetAllUsers_ShouldReturnAllUsers()
        {
            // Arrange
            var user1 = new User { FirstName = "User1", LastName = "Test", Email = "user1@test.com", CreatedAt = DateTime.UtcNow };
            var user2 = new User { FirstName = "User2", LastName = "Test", Email = "user2@test.com", CreatedAt = DateTime.UtcNow };
            
            await _userRepository.CreateUserAsync(user1);
            await _userRepository.CreateUserAsync(user2);

            // Act
            var users = await _userRepository.GetAllUsersAsync();

            // Assert
            Assert.NotNull(users);
            Assert.Equal(2, users.Count);
        }

        [Fact]
        public async Task UpdateUser_ShouldModifyExistingUser()
        {
            // Arrange
            var user = new User 
            { 
                FirstName = "Original", 
                LastName = "Name", 
                Email = "original@example.com",
                CreatedAt = DateTime.UtcNow
            };
            var createdUser = await _userRepository.CreateUserAsync(user);
            
            // Act
            createdUser.FirstName = "Updated";
            createdUser.LastName = "Name";
            var updateResult = await _userRepository.UpdateUserAsync(createdUser);
            
            // Assert
            Assert.True(updateResult);
            
            var updatedUser = await _userRepository.GetUserByIdAsync(createdUser.Id);
            Assert.Equal("Updated", updatedUser.FirstName);
        }

        [Fact]
        public async Task DeleteUser_ShouldRemoveUserFromDatabase()
        {
            // Arrange
            var user = new User 
            { 
                FirstName = "ToDelete", 
                LastName = "User", 
                Email = "delete@example.com",
                CreatedAt = DateTime.UtcNow
            };
            var createdUser = await _userRepository.CreateUserAsync(user);

            // Act
            var deleteResult = await _userRepository.DeleteUserAsync(createdUser.Id);
            
            // Assert
            Assert.True(deleteResult);
            
            var deletedUser = await _userRepository.GetUserByIdAsync(createdUser.Id);
            Assert.Null(deletedUser);
        }

        [Fact]
        public async Task GetUserByEmail_ShouldReturnCorrectUser()
        {
            // Arrange
            var email = "unique.email@example.com";
            var user = new User 
            { 
                FirstName = "Email", 
                LastName = "Search", 
                Email = email,
                CreatedAt = DateTime.UtcNow
            };
            await _userRepository.CreateUserAsync(user);

            // Act
            var foundUser = await _userRepository.GetUserByEmailAsync(email);

            // Assert
            Assert.NotNull(foundUser);
            Assert.Equal(email, foundUser.Email);
        }
    }
}
```

## Ход работы

1. Установить Docker Desktop на рабочую машину
2. Создать новый solution с проектом приложения и тестовым проектом
3. Установить необходимые NuGet пакеты
4. Реализовать репозиторий для работы с БД
5. Написать интеграционные тесты с использованием Testcontainers
6. Запустить тесты и убедиться в их работоспособности
7. Сделать скриншоты результатов выполнения
8. Оформить README.md файл
9. Загрузить работу в Gogs

## Варианты заданий

### Вариант 1: Система управления продуктами
Создайте систему для управления продуктами с тестами для операций CRUD.

### Вариант 2: Блог платформа
Реализуйте репозиторий для статей блога с тестированием поиска по заголовку и дате.

### Вариант 3: Система заказов
Создайте систему обработки заказов с тестами для расчета общей стоимости.

### Вариант 4: Управление сотрудниками
Реализуйте HR систему с тестированием поиска сотрудников по отделу.

### Вариант 5: Библиотека книг
Создайте систему учета книг с тестами для поиска по автору и жанру.

### Вариант 6: Система бронирования
Реализуйте систему бронирования с тестированием проверки доступности.

### Вариант 7: Учет финансов
Создайте систему финансового учета с тестами для расчета баланса.

### Вариант 8: Инвентаризация склада
Реализуйте систему управления складом с тестированием обновления количества.

### Вариант 9: Образовательная платформа
Создайте систему курсов с тестами для поиска по категории и рейтингу.

### Вариант 10: Социальная сеть
Реализуйте систему постов с тестированием ленты новостей.

### Вариант 11: Система тикетов
Создайте систему поддержки с тестами для фильтрации по статусу.

### Вариант 12: Управление проектами
Реализуйте систему задач с тестированием назначения исполнителей.

### Вариант 13: Каталог фильмов
Создайте базу данных фильмов с тестами для поиска по режиссеру и году.

### Вариант 14: Система рецептов
Реализуйте каталог рецептов с тестированием фильтрации по ингредиентам.

### Вариант 15: Фитнес трекер
Создайте систему тренировок с тестами для расчета прогресса.

## Критерии оценки

### 5 (Отлично)
- Все тесты проходят успешно
- Код хорошо структурирован и соответствует принципам SOLID
- Реализованы все требуемые функции согласно варианту
- Написаны дополнительные тесты для граничных случаев
- README.md полностью заполнен с качественными скриншотами

### 4 (Хорошо)
- Основные тесты проходят успешно
- Код структурирован адекватно
- Реализованы основные функции согласно варианту
- README.md заполнен с основными скриншотами

### 3 (Удовлетворительно)
- Большинство тестов проходят, но есть незначительные ошибки
- Код требует улучшения структуры
- Реализованы не все функции
- README.md заполнен частично

### 2 (Неудовлетворительно)
- Тесты не проходят или отсутствуют
- Код не структурирован
- Функции не реализованы
- README.md отсутствует или заполнен незначительно

## Контрольные вопросы

1. В чем преимущества использования Testcontainers по сравнению с моками?
2. Как Testcontainers обеспечивает изоляцию тестов?
3. Какие методы жизненного цикла тестов используются в xUnit?
4. Как настроить PostgreSQL контейнер с помощью Testcontainers?
5. Какие проблемы могут возникнуть при использовании Testcontainers в CI/CD?
6. Как организовать подготовку тестовых данных?
7. В чем разница между unit-тестами и интеграционными тестами?
8. Как обрабатывать миграции базы данных в тестах?
9. Какие альтернативы Testcontainers существуют для .NET?
10. Как оптимизировать время выполнения тестов с Testcontainers?

## Требования к репозиторию

Репозиторий должен содержать:
- `src/` - исходный код приложения
- `tests/` - тестовый проект
- `images/` - скриншоты работы программы
- `README.md` - документация по практической работе

## Пример README.md для варианта 1

```markdown
# Практическая работа №X: Тестирование взаимодействия с базой данных

**Вариант:** 1  
**Тема:** Система управления продуктами

## Задание
Создайте систему для управления продуктами с тестами для операций CRUD. Реализуйте следующие функции:
- Добавление нового продукта
- Получение продукта по ID
- Обновление информации о продукте
- Удаление продукта
- Получение всех продуктов
- Поиск продуктов по категории

## Код приложения

### Модель Product
```csharp
public class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string Description { get; set; } = string.Empty;
    public decimal Price { get; set; }
    public string Category { get; set; } = string.Empty;
    public int StockQuantity { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

### Пример теста
```csharp
[Fact]
public async Task CreateProduct_ShouldAddProductToDatabase()
{
    // Arrange
    var product = new Product 
    { 
        Name = "Test Product",
        Description = "Test Description",
        Price = 99.99m,
        Category = "Electronics",
        StockQuantity = 10,
        CreatedAt = DateTime.UtcNow
    };

    // Act
    var createdProduct = await _productRepository.CreateProductAsync(product);

    // Assert
    Assert.True(createdProduct.Id > 0);
    Assert.Equal(product.Name, createdProduct.Name);
}
```

## Скриншоты результатов

![Результаты тестов](images/test-results.png)

![Работа приложения](images/application-work.png)
```

Для выполнения работы убедитесь, что у вас установлены:
- .NET 8 SDK
- Docker Desktop
- Git
- Gogs (локальный Git сервер)