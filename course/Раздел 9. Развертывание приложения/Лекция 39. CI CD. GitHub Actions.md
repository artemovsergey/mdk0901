# Лекция. Непрерывная интеграция и доставка (CI/CD) с GitHub Actions для .NET-разработчиков

**Цель:** Понять принципы CI/CD, научиться создавать автоматизированные пайплайны сборки, тестирования и развертывания .NET-приложений с помощью GitHub Actions

---

## **План лекции:**

1. **Введение в CI/CD:** Что такое непрерывная интеграция и доставка?
2. **GitHub Actions основы:** Ключевые концепции и структура workflow
3. **Создание CI-пайплайна для .NET:**
   - Автоматическая сборка и тестирование
   - Кэширование зависимостей
   - Мультиплатформенная сборка
4. **Расширенный CI-пайплайн:**
   - Контейнеризация приложения
   - Интеграционные тесты с PostgreSQL
   - Code quality проверки
5. **CD-пайплайн:**
   - Автоматическое развертывание
   - Среда и секреты
   - Деплой в различные окружения
6. **Best Practices и оптимизация**
7. **Резюме**
8. **Контрольные вопросы**

---

## **Подробное рассмотрение каждого пункта плана:**

### **1. Введение в CI/CD**

**Проблема:** Ручные процессы сборки, тестирования и развертывания:
- Человеческий фактор и ошибки
- Несогласованность окружений
- Долго и непредсказуемо
- Сложно отслеживать изменения

**Решение - CI/CD:**
- **Continuous Integration (Непрерывная интеграция)** - автоматическая сборка и тестирование каждой фиксации в репозитории
- **Continuous Delivery/Deployment (Непрерывная доставка/развертывание)** - автоматическое развертывание протестированного кода в среды

**Преимущества:**
- Раннее обнаружение ошибок
- Быстрая обратная связь
- Предсказуемость релизов
- Автоматизация рутины

---

### **2. GitHub Actions основы**

**GitHub Actions** - платформа для автоматизации workflows прямо в репозитории GitHub.

**Ключевые концепции:**

- **Workflow** - автоматизируемый процесс, описанный в YAML-файле
- **Event** - событие, запускающее workflow (push, pull_request, schedule)
- **Job** - набор шагов, выполняемых на одном runner
- **Step** - отдельная задача (команда или Action)
- **Action** - reusable компонент для выполнения частой задачи

**Базовая структура workflow файла:**
```yaml
name: .NET CI

on: # События-триггеры
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  build: # Job ID
    runs-on: ubuntu-latest # ОС для выполнения
    
    steps:
    - uses: actions/checkout@v4 # Действие: checkout кода
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
        
    - name: Restore dependencies
      run: dotnet restore
      
    - name: Build
      run: dotnet build --no-restore --configuration Release
      
    - name: Test
      run: dotnet test --no-build --verbosity normal
```

---

### **3. Создание CI-пайплайна для .NET**

**Пример полного CI-пайплайна для ASP.NET Core приложения:**

```yaml
name: .NET CI Pipeline

on:
  push:
    branches: [ main, develop, feature/* ]
  pull_request:
    branches: [ main, develop ]

env:
  DOTNET_VERSION: '8.0.x'
  PROJECT_PATH: 'src/MyAspNetCoreApp/MyAspNetCoreApp.csproj'
  TEST_PATH: 'tests/MyAspNetCoreApp.Tests/MyAspNetCoreApp.Tests.csproj'

jobs:
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: ${{ env.DOTNET_VERSION }}
        
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Restore dependencies
      run: dotnet restore ${{ env.PROJECT_PATH }}
      
    - name: Build
      run: dotnet build ${{ env.PROJECT_PATH }} --no-restore --configuration Release --verbosity normal
      
    - name: Run unit tests
      run: dotnet test ${{ env.TEST_PATH }} --no-build --configuration Release --verbosity normal --logger "trx;LogFileName=test-results.trx"
      
    - name: Upload test results
      uses: actions/upload-artifact@v3
      if: always() # Загружаем даже если тесты упали
      with:
        name: test-results
        path: '**/*.trx'
        
    - name: Publish application
      run: dotnet publish ${{ env.PROJECT_PATH }} --configuration Release --output ./publish --no-build
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      with:
        name: published-app
        path: ./publish/**
```

**Ключевые моменты:**
- **Кэширование** ускоряет последующие сборки
- **Артефакты** сохраняют результаты сборки и тестов
- **Переменные окружения** делают конфигурацию гибкой

---

### **4. Расширенный CI-пайплайн**

**Пример с контейнеризацией и интеграционными тестами:**

```yaml
name: Advanced .NET CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
        
    - name: Run unit tests
      run: dotnet test --configuration Release --filter "Category=Unit"
      
  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:16
        env:
          POSTGRES_USER: testuser
          POSTGRES_PASSWORD: testpassword
          POSTGRES_DB: testdb
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432
          
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
        
    - name: Run integration tests
      run: dotnet test --configuration Release --filter "Category=Integration"
      env:
        CONNECTION_STRING: Host=localhost;Port=5432;Database=testdb;Username=testuser;Password=testpassword
        
  build-container:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests] # Зависит от успеха тестов
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Build Docker image
      run: |
        docker build -t myapp:${{ github.sha }} .
        docker build -t myapp:latest .
        
    - name: Run container tests
      run: |
        docker run -d -p 8080:8080 --name test-container myapp:${{ github.sha }
        sleep 10
        curl -f http://localhost:8080/health || exit 1
        
    - name: Log in to Docker Hub
      if: github.ref == 'refs/heads/main'
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_TOKEN }}
        
    - name: Push Docker image
      if: github.ref == 'refs/heads/main'
      run: |
        docker push myapp:${{ github.sha }}
        docker push myapp:latest
        
  code-quality:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v3
      with:
        dotnet-version: 8.0.x
        
    - name: Run security analysis
      uses: github/codeql-action/analyze@v2
      
    - name: Run SonarCloud analysis
      uses: sonarsource/sonarcloud-github-action@v1.8
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
```

---

### **5. CD-пайплайн**

**Автоматическое развертывание после успешного CI:**

```yaml
name: .NET CD Pipeline

on:
  workflow_run:
    workflows: [".NET CI Pipeline"]
    types:
      - completed
    branches: [main]

jobs:
  deploy-to-staging:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    environment: staging
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: published-app
        run-id: ${{ github.event.workflow_run.id }}
        
    - name: Deploy to Azure Web App
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'myapp-staging'
        package: './published-app'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_STAGING }}
        
    - name: Run smoke tests
      run: |
        curl -f https://myapp-staging.azurewebsites.net/health || exit 1
        
  deploy-to-production:
    runs-on: ubuntu-latest
    needs: deploy-to-staging
    environment: production
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Download build artifacts
      uses: actions/download-artifact@v3
      with:
        name: published-app
        run-id: ${{ github.event.workflow_run.id }}
        
    - name: Wait for approval
      uses: trstringer/manual-approval@v1
      with:
        secret: ${{ github.token }}
        approvers: ${{ vars.PRODUCTION_APPROVERS }}
        
    - name: Deploy to production
      uses: azure/webapps-deploy@v2
      with:
        app-name: 'myapp-production'
        package: './published-app'
        publish-profile: ${{ secrets.AZURE_WEBAPP_PUBLISH_PROFILE_PRODUCTION }}
        
    - name: Verify deployment
      run: |
        curl -f https://myapp-production.azurewebsites.net/health || exit 1
```

**Ключевые особенности CD:**
- **Environment protection** с секретами
- **Manual approval** для production
- **Smoke tests** после деплоя
- **Зависимости между job'ами**

---

### **6. Best Practices и оптимизация**

**Секреты и безопасность:**
```yaml
# НЕПРАВИЛЬНО - никогда не хардкодите секреты!
env:
  CONNECTION_STRING: "Server=localhost;Password=123456"

# ПРАВИЛЬНО - используйте GitHub Secrets
env:
  CONNECTION_STRING: ${{ secrets.PRODUCTION_CONNECTION_STRING }}
```

**Оптимизация скорости:**
```yaml
jobs:
  fast-build:
    runs-on: ubuntu-latest
    
    strategy:
      matrix:
        dotnet-version: [ '6.0.x', '7.0.x', '8.0.x' ]
        
    steps:
    - uses: actions/checkout@v4
    
    - name: Cache NuGet packages
      uses: actions/cache@v3
      with:
        path: ~/.nuget/packages
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/*.csproj') }}
        restore-keys: |
          ${{ runner.os }}-nuget-
          
    - name: Cache Docker layers
      uses: actions/cache@v3
      with:
        path: /tmp/.buildx-cache
        key: ${{ runner.os }}-buildx-${{ github.sha }}
        restore-keys: |
          ${{ runner.os }}-buildx-
          
    - name: Parallel test execution
      run: dotnet test --parallel --verbosity normal
```

**Правильная организация workflow:**
```yaml
name: Smart Pipeline

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

# Запускать только при изменениях в релевантных путях
paths:
  paths:
    - 'src/**'
    - 'tests/**'
    - '.github/workflows/**'

# Отменить старые запуски при новом push
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true
```

---

### **7. Резюме**

- **GitHub Actions** предоставляет мощную платформу для CI/CD прямо в репозитории
- **CI-пайплайн** автоматизирует сборку, тестирование и анализ кода при каждом изменении
- **CD-пайплайн** автоматически развертывает приложение после успешного CI
- **Секреты и Environment** обеспечивают безопасность конфиденциальных данных
- **Кэширование и матричные сборки** значительно ускоряют выполнение workflow
- **Best Practices** включают правильную организацию jobs, обработку ошибок и оптимизацию

---

### **8. Контрольные вопросы**

1. **Какая разница между Continuous Delivery и Continuous Deployment?**
   - Continuous Delivery: код всегда готов к развертыванию, но деплой требует ручного подтверждения
   - Continuous Deployment: автоматическое развертывание после успешного прохождения всех тестов

2. **Как организовать запуск интеграционных тестов с базой данных в GitHub Actions?**
   Использовать сервисные контейнеры в job:
   ```yaml
   services:
     postgres:
       image: postgres:16
       env: ...
   ```

3. **Как безопасно работать с паролями и подключениями в workflow?**
   Использовать GitHub Secrets через `${{ secrets.MY_SECRET }}`

4. **Как оптимизировать время выполнения пайплайна?**
   - Кэширование зависимостей (NuGet, npm)
   - Параллельное выполнение независимых jobs
   - Матричные сборки для разных версий
   - Запуск только при изменениях в релевантных путях

5. **Как организовать деплой в разные среды (staging/production)?**
   Использовать environment с разными секретами и настройками, добавить manual approval для production

6. **Что такое matrix strategy и когда её использовать?**
   Для запуска одних и тех же шагов с разными параметрами (версии .NET, ОС):
   ```yaml
   strategy:
     matrix:
       dotnet-version: [ '6.0.x', '7.0.x', '8.0.x' ]
   ```

7. **Как обработать падение шага в workflow?**
   Использовать `if: always()` или `if: failure()` для условного выполнения шагов, `continue-on-error: true` для некритичных шагов