# Лекция 9. Асинхронный JavaScript**

**Цель:** Понять концепцию асинхронности в JavaScript, изучить механизмы работы с асинхронными операциями: Callbacks, Promises и async/await.

---

### **План лекции**

1.  **Введение в асинхронность**
    *   Синхронная vs асинхронная модель выполнения.
    *   Проблема "блокирующего" кода.
    *   Event Loop: как JavaScript управляет асинхронными операциями.

2.  **Callbacks (Функции обратного вызова)**
    *   Что такое callback?
    *   Практическое применение: `setTimeout`, события.
    *   "Callback Hell" и его проблемы.

3.  **Promises (Промисы)**
    *   Что такое Promise? Состояния Promise.
    *   Создание промисов.
    *   Цепочки вызовов: `.then()`, `.catch()`, `.finally()`.

4.  **Современный подход: async/await**
    *   Синтаксический сахар над промисами.
    *   Обработка ошибок с `try/catch`.
    *   Практические примеры.

5.  **Практика: Работа с HTTP-запросами (Fetch API)**
    *   Получение данных от сервера.

---

### **Содержание лекции (Детализация)**

#### **1. Введение в асинхронность**

**Синхронная модель выполнения**

По умолчанию JavaScript — однопоточный и синхронный язык. Это означает:
*   **Однопоточный:** В один момент времени выполняется только одна операция.
*   **Синхронный:** Код выполняется строго сверху вниз, каждая следующая операция ждет завершения предыдущей.

```javascript
console.log("Начало");

function synchronousTask() {
    for (let i = 0; i < 1000000000; i++) {
        // Имитация тяжелой операции
    }
    console.log("Тяжелая операция завершена");
}

synchronousTask(); // Браузер "зависнет" на время выполнения цикла
console.log("Конец"); // Выполнится только после synchronousTask()
```

**Проблема:** Если операция занимает много времени (запрос к серверу, чтение файла, сложные вычисления), весь интерфейс "замирает" — пользователь не может прокручивать страницу, нажимать кнопки.

**Асинхронная модель выполнения**

Асинхронные операции позволяют отложить выполнение кода без блокировки основного потока.

```javascript
console.log("Начало");

setTimeout(() => {
    console.log("Асинхронная операция завершена");
}, 2000); // Выполнится через 2 секунды, НЕ блокируя основной поток

console.log("Конец");

// Результат в консоли:
// "Начало"
// "Конец"
// (через 2 секунды) "Асинхронная операция завершена"
```

**Event Loop (Цикл событий)**

Это механизм, который позволяет JavaScript выполнять асинхронный код. Принцип работы:
1.  Синхронный код выполняется в Call Stack (стек вызовов).
2.  Асинхронные операции (таймеры, запросы к серверу) передаются Web APIs (предоставляются браузером).
3.  Когда асинхронная операция завершается, ее callback-функция попадает в Callback Queue (очередь callback).
4.  **Event Loop** постоянно проверяет: если Call Stack пуст, он перемещает callback из Callback Queue в Call Stack для выполнения.

#### **2. Callbacks (Функции обратного вызова)**

**Callback** — это функция, которая передается другой функции как аргумент и выполняется после завершения какой-либо операции.

**Практическое применение:**

```javascript
// setTimeout - классический пример
setTimeout(function() {
    console.log("Этот код выполнится через 1 секунду");
}, 1000);

// Обработчики событий - тоже callback'и
document.getElementById('myButton').addEventListener('click', function() {
    console.log("Кнопка была нажата!");
});
```

**"Callback Hell" (Ад callback'ов)**

Когда несколько асинхронных операций зависят друг от друга, код становится очень сложным для чтения:

```javascript
// Пример callback hell (псевдокод для имитации последовательных запросов)
function getUserData(userId, callback) {
    setTimeout(() => {
        console.log("Получаем данные пользователя...");
        callback({ id: userId, name: "John" });
    }, 1000);
}

function getUserPosts(user, callback) {
    setTimeout(() => {
        console.log("Получаем посты пользователя...");
        callback([{ id: 1, title: "Post 1" }, { id: 2, title: "Post 2" }]);
    }, 1000);
}

function getPostComments(post, callback) {
    setTimeout(() => {
        console.log("Получаем комментарии...");
        callback([{ id: 1, text: "Great post!" }]);
    }, 1000);
}

// CALLBACK HELL!
getUserData(123, function(user) {
    getUserPosts(user, function(posts) {
        getPostComments(posts[0], function(comments) {
            console.log("Результат:", comments);
            // И так можно углубляться дальше...
        });
    });
});
```

#### **3. Promises (Промисы)**

**Promise** — это объект, который представляет результат асинхронной операции, которая может завершиться успешно (resolved) или с ошибкой (rejected).

**Состояния Promise:**
*   **pending** (ожидание) — начальное состояние.
*   **fulfilled** (выполнено) — операция завершена успешно.
*   **rejected** (отклонено) — операция завершена с ошибкой.

**Создание и использование Promise:**

```javascript
// Создание Promise
const myPromise = new Promise((resolve, reject) => {
    // Асинхронная операция
    setTimeout(() => {
        const success = Math.random() > 0.3; // Имитация успеха/ошибки
        
        if (success) {
            resolve("Данные успешно получены!"); // Успешное выполнение
        } else {
            reject("Ошибка: данные не получены"); // Выполнение с ошибкой
        }
    }, 2000);
});

// Использование Promise
myPromise
    .then((result) => {
        console.log("Успех:", result);
    })
    .catch((error) => {
        console.log("Ошибка:", error);
    })
    .finally(() => {
        console.log("Операция завершена (успех или ошибка)");
    });
```

**Цепочки промисов (решение проблемы Callback Hell):**

```javascript
// Перепишем пример с callback hell используя промисы
function getUserData(userId) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Получаем данные пользователя...");
            resolve({ id: userId, name: "John" });
        }, 1000);
    });
}

function getUserPosts(user) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Получаем посты пользователя...");
            resolve([{ id: 1, title: "Post 1" }, { id: 2, title: "Post 2" }]);
        }, 1000);
    });
}

function getPostComments(post) {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Получаем комментарии...");
            resolve([{ id: 1, text: "Great post!" }]);
        }, 1000);
    });
}

// Читаемая цепочка промисов!
getUserData(123)
    .then(user => getUserPosts(user))
    .then(posts => getPostComments(posts[0]))
    .then(comments => {
        console.log("Результат:", comments);
    })
    .catch(error => {
        console.error("Ошибка в цепочке:", error);
    });
```

#### **4. Современный подход: async/await**

**async/await** — это синтаксический сахар над промисами, который делает асинхронный код похожим на синхронный.

```javascript
// Ключевое слово async делает функцию асинхронной
async function fetchUserData() {
    try {
        // await приостанавливает выполнение функции до разрешения промиса
        const user = await getUserData(123);
        console.log("Пользователь:", user);
        
        const posts = await getUserPosts(user);
        console.log("Посты:", posts);
        
        const comments = await getPostComments(posts[0]);
        console.log("Комментарии:", comments);
        
        return comments; // async функция всегда возвращает Promise
    } catch (error) {
        // Обработка ошибок с помощью try/catch
        console.error("Произошла ошибка:", error);
    }
}

// Вызов async функции
fetchUserData().then(result => {
    console.log("Финальный результат:", result);
});
```

#### **5. Практика: Работа с HTTP-запросами (Fetch API)**

**Fetch API** — современный браузерный API для работы с HTTP-запросами, который возвращает Promise.

```javascript
// Базовый пример GET-запроса
async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
        
        // Проверяем, что ответ успешный (status 200-299)
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        // Парсим JSON из ответа
        const data = await response.json();
        console.log("Полученные данные:", data);
        
        // Используем данные в интерфейсе
        document.getElementById('content').textContent = data.title;
        
    } catch (error) {
        console.error('Ошибка при получении данных:', error);
    }
}

// Эквивалент с then/catch
fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => {
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
    })
    .then(data => {
        console.log("Данные:", data);
    })
    .catch(error => {
        console.error('Ошибка:', error);
    });
```

**POST-запрос с данными:**

```javascript
async function createPost(postData) {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(postData) // Преобразуем объект в JSON
        });
        
        if (!response.ok) {
            throw new Error('Ошибка при создании поста');
        }
        
        const newPost = await response.json();
        console.log('Создан новый пост:', newPost);
        return newPost;
    } catch (error) {
        console.error('Ошибка:', error);
    }
}

// Использование
createPost({
    title: 'Мой новый пост',
    body: 'Содержание поста',
    userId: 1
});
```

---

### **Резюме**

Сегодня мы погрузились в мир асинхронного JavaScript:
*   **Поняли проблему** блокирующего кода и необходимость асинхронности.
*   **Изучили эволюцию** подходов: от Callbacks через Promise к современному async/await.
*   **Callbacks** — фундаментальный механизм, но приводящий к "callback hell".
*   **Promises** — мощная абстракция для работы с асинхронностью, позволяющая строить цепочки.
*   **async/await** — современный синтаксис, делающий асинхронный код читаемым и похожим на синхронный.
*   **Fetch API** — практическое применение для работы с сетевыми запросами.

**Ключевой вывод:** Асинхронность — не опциональная, а обязательная часть фронтенд-разработки. Без неё невозможно создание отзывчивых веб-приложений, взаимодействующих с сервером.

---

### **Контрольные вопросы**

1.  Объясните, почему следующий код выведет "Сначала" раньше, чем "Потом":
    ```javascript
    console.log("Сначала");
    setTimeout(() => console.log("Потом"), 0);
    console.log("В конце");
    ```

2.  В чем основная проблема "Callback Hell" и как промисы помогают её решить?

3.  Перепишите следующий код с использованием async/await:
    ```javascript
    function getData() {
        return fetch('https://api.example.com/data')
            .then(response => response.json())
            .then(data => {
                console.log(data);
                return data;
            })
            .catch(error => {
                console.error('Ошибка:', error);
            });
    }
    ```

4.  Создайте функцию `delay(ms)`, которая возвращает промис, разрешающийся через указанное количество миллисекунд.

5.  Что выведет этот код и почему?
    ```javascript
    async function test() {
        return 1;
    }
    test().then(console.log);
    ```

6.  Как правильно обработать ошибки в async/await?

7.  **Сценарий:** Вам нужно последовательно выполнить 3 API-запроса, где каждый следующий запрос зависит от результата предыдущего. Какой подход вы выберете и почему?