# Лекция 10. ООП и продвинутые концепции в JavaScript

**Цель:** Понять объектно-ориентированное программирование в JavaScript, изучить продвинутые концепции и паттерны.

### **Тема: «ООП в JavaScript: Классы, наследование и современные паттерны»**

---

### **План лекции**

1.  **Введение в ООП**
    *   Основные принципы ООП: инкапсуляция, наследование, полиморфизм.
    *   Особенности ООП в JavaScript.

2.  **Конструкторы и прототипы**
    *   Функции-конструкторы.
    *   Прототипное наследование.
    *   Цепочка прототипов.

3.  **Современные классы (ES6+)**
    *   Синтаксис классов.
    *   Наследование с `extends`.
    *   Статические методы и свойства.

4.  **Продвинутые концепции**
    *   `this` и контекст выполнения.
    *   Замыкания (Closures).
    *   Модули (ES6 Modules).

5.  **Практика: Применение ООП во фронтенде**
    *   Создание компонентов с помощью классов.

---

### **Содержание лекции (Детализация)**

#### **1. Введение в ООП**

**Основные принципы ООП:**

*   **Инкапсуляция** — объединение данных и методов в одной сущности (объекте), сокрытие внутренней реализации.
*   **Наследование** — возможность создавать новые классы на основе существующих.
*   **Полиморфизм** — возможность использовать объекты разных классов через одинаковый интерфейс.

**Особенности ООП в JavaScript:**

В отличие от классических ООП-языков (Java, C#), JavaScript использует **прототипное наследование**, а не классовое. Однако в ES6 был добавлен синтаксис классов, который является "синтаксическим сахаром" над прототипами.

#### **2. Конструкторы и прототипы (классический подход)**

**Функции-конструкторы:**

```javascript
// Функция-конструктор (имя с большой буквы)
function Person(name, age) {
    // Свойства объекта
    this.name = name;
    this.age = age;
    
    // Методы (не самый эффективный способ - каждый экземпляр получает свою копию метода)
    this.sayHello = function() {
        console.log(`Привет, меня зовут ${this.name}`);
    };
}

// Создание экземпляров с помощью оператора new
const person1 = new Person('Иван', 30);
const person2 = new Person('Мария', 25);

person1.sayHello(); // "Привет, меня зовут Иван"
```

**Прототипное наследование:**

Более эффективный способ добавления методов — через прототип.

```javascript
function Person(name, age) {
    this.name = name;
    this.age = age;
}

// Добавление метода в прототип
Person.prototype.sayHello = function() {
    console.log(`Привет, меня зовут ${this.name}`);
};

// Добавление метода в прототип (современный синтаксис)
Person.prototype.getBirthYear = function() {
    const currentYear = new Date().getFullYear();
    return currentYear - this.age;
};

const person1 = new Person('Иван', 30);
person1.sayHello(); // "Привет, меня зовут Иван"
console.log(person1.getBirthYear()); // 1994 (если текущий год 2024)
```

**Цепочка прототипов:**

Когда мы обращаемся к свойству объекта, JavaScript:
1. Ищет свойство в самом объекте
2. Если не находит — ищет в прототипе объекта (`__proto__`)
3. Продолжает подниматься по цепочке прототипов

```javascript
console.log(person1.__proto__ === Person.prototype); // true
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Object.prototype.__proto__); // null - конец цепочки
```

#### **3. Современные классы (ES6+)**

**Синтаксис классов:**

```javascript
class Person {
    // Конструктор вызывается при создании нового экземпляра
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }
    
    // Методы автоматически добавляются в прототип
    sayHello() {
        console.log(`Привет, меня зовут ${this.name}`);
    }
    
    getBirthYear() {
        const currentYear = new Date().getFullYear();
        return currentYear - this.age;
    }
}

// Использование идентично конструкторам
const person1 = new Person('Алексей', 28);
person1.sayHello(); // "Привет, меня зовут Алексей"
```

**Наследование с `extends`:**

```javascript
class Student extends Person {
    constructor(name, age, studentId, major) {
        super(name, age); // Вызов конструктора родительского класса
        this.studentId = studentId;
        this.major = major;
    }
    
    // Переопределение метода
    sayHello() {
        console.log(`Привет, я студент ${this.name}, изучаю ${this.major}`);
    }
    
    // Новый метод
    study() {
        console.log(`${this.name} усердно учится...`);
    }
}

const student = new Student('Екатерина', 20, 'S12345', 'Компьютерные науки');
student.sayHello(); // "Привет, я студент Екатерина, изучаю Компьютерные науки"
student.study();    // "Екатерина усердно учится..."
console.log(student.getBirthYear()); // Унаследованный метод от Person
```

**Статические методы и свойства:**

Принадлежат классу, а не экземплярам.

```javascript
class MathHelper {
    // Статическое свойство
    static PI = 3.14159;
    
    // Статический метод
    static calculateCircleArea(radius) {
        return this.PI * radius * radius;
    }
    
    static compareAges(person1, person2) {
        return person1.age - person2.age;
    }
}

// Вызов без создания экземпляра
console.log(MathHelper.PI); // 3.14159
console.log(MathHelper.calculateCircleArea(5)); // 78.53975

const people = [
    new Person('Анна', 25),
    new Person('Петр', 30),
    new Person('Мария', 22)
];

// Использование статического метода
people.sort(MathHelper.compareAges);
```

#### **4. Продвинутые концепции**

**`this` и контекст выполнения:**

```javascript
class Button {
    constructor(text) {
        this.text = text;
        this.element = document.createElement('button');
        this.element.textContent = text;
        
        // Проблема: this теряется в обработчике событий
        // this.element.addEventListener('click', this.handleClick);
        
        // Решение 1: bind
        this.element.addEventListener('click', this.handleClick.bind(this));
        
        // Решение 2: стрелочная функция
        // this.element.addEventListener('click', () => this.handleClick());
    }
    
    handleClick() {
        console.log(`Нажата кнопка: ${this.text}`);
    }
}
```

**Замыкания (Closures):**

Замыкание — это функция, которая запоминает свое лексическое окружение даже после выполнения внешней функции.

```javascript
function createCounter() {
    let count = 0; // private variable
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount());  // 2
// console.log(counter.count);    // Error: count is private
```

**Модули (ES6 Modules):**

Позволяют разбивать код на отдельные файлы с импортом/экспортом.

```javascript
// math.js
export const PI = 3.14159;

export function sum(a, b) {
    return a + b;
}

export default class Calculator {
    multiply(a, b) {
        return a * b;
    }
}

// app.js
import Calculator, { PI, sum } from './math.js';

console.log(PI); // 3.14159
console.log(sum(2, 3)); // 5

const calc = new Calculator();
console.log(calc.multiply(4, 5)); // 20
```

#### **5. Практика: Применение ООП во фронтенде**

**Создание UI компонента:**

```javascript
class Modal {
    constructor(title, content) {
        this.title = title;
        this.content = content;
        this.isOpen = false;
        this.createModal();
    }
    
    createModal() {
        this.modalElement = document.createElement('div');
        this.modalElement.className = 'modal';
        this.modalElement.innerHTML = `
            <div class="modal-content">
                <div class="modal-header">
                    <h2>${this.title}</h2>
                    <span class="close">&times;</span>
                </div>
                <div class="modal-body">
                    ${this.content}
                </div>
            </div>
        `;
        
        document.body.appendChild(this.modalElement);
        
        // Навешиваем обработчики
        this.modalElement.querySelector('.close').addEventListener('click', () => {
            this.close();
        });
        
        // Закрытие по клику вне модального окна
        this.modalElement.addEventListener('click', (e) => {
            if (e.target === this.modalElement) {
                this.close();
            }
        });
    }
    
    open() {
        this.modalElement.style.display = 'block';
        this.isOpen = true;
    }
    
    close() {
        this.modalElement.style.display = 'none';
        this.isOpen = false;
    }
    
    updateContent(newContent) {
        this.content = newContent;
        this.modalElement.querySelector('.modal-body').innerHTML = newContent;
    }
}

// Использование
const myModal = new Modal('Заголовок', '<p>Содержание модального окна</p>');
myModal.open();

// Через 3 секунды обновим содержимое
setTimeout(() => {
    myModal.updateContent('<p>Обновленное содержимое!</p>');
}, 3000);
```

**Система управления пользователями:**

```javascript
class User {
    constructor(id, username, email) {
        this.id = id;
        this.username = username;
        this.email = email;
        this.isActive = true;
        this.createdAt = new Date();
    }
    
    deactivate() {
        this.isActive = false;
        console.log(`Пользователь ${this.username} деактивирован`);
    }
    
    getInfo() {
        return `${this.username} (${this.email}) - ${this.isActive ? 'Активен' : 'Неактивен'}`;
    }
}

class UserManager {
    constructor() {
        this.users = [];
        this.nextId = 1;
    }
    
    addUser(username, email) {
        const user = new User(this.nextId++, username, email);
        this.users.push(user);
        return user;
    }
    
    findUserById(id) {
        return this.users.find(user => user.id === id);
    }
    
    findUsersByUsername(username) {
        return this.users.filter(user => 
            user.username.toLowerCase().includes(username.toLowerCase())
        );
    }
    
    deactivateUser(id) {
        const user = this.findUserById(id);
        if (user) {
            user.deactivate();
        }
    }
    
    getActiveUsers() {
        return this.users.filter(user => user.isActive);
    }
}

// Использование
const userManager = new UserManager();
userManager.addUser('ivan_petrov', 'ivan@example.com');
userManager.addUser('maria_ivanova', 'maria@example.com');

console.log(userManager.getActiveUsers().map(user => user.getInfo()));
```

---

### **Резюме**

Сегодня мы изучили продвинутые концепции JavaScript:
*   **ООП в JavaScript** имеет свои особенности через прототипное наследование.
*   **Классы ES6+** предоставляют удобный синтаксис для создания конструкторов и наследования.
*   **`this` и контекст** — критически важная концепция, требующая понимания работы стрелочных функций и `bind`.
*   **Замыкания** позволяют создавать приватные переменные и сохранять состояние.
*   **Модули** помогают организовать код в больших приложениях.

**Ключевой вывод:** Понимание ООП и продвинутых концепций JavaScript необходимо для создания масштабируемых, поддерживаемых и сложных веб-приложений. Эти знания позволяют структурировать код профессиональным образом.

---

### **Контрольные вопросы**

1.  В чем разница между прототипным и классическим наследованием?
2.  Что выведет этот код и почему?
    ```javascript
    class Animal {
        constructor(name) {
            this.name = name;
        }
        
        speak() {
            console.log(`${this.name} издает звук`);
        }
    }
    
    class Dog extends Animal {
        speak() {
            console.log(`${this.name} лает`);
        }
    }
    
    const animal = new Animal('Животное');
    const dog = new Dog('Бобик');
    
    animal.speak();
    dog.speak();
    ```

3.  Как создать приватное свойство в классе JavaScript?
4.  Что такое замыкание и как оно используется для создания приватных переменных?
5.  В чем проблема с `this` в следующем коде и как её исправить?
    ```javascript
    class Timer {
        constructor() {
            this.seconds = 0;
        }
        
        start() {
            setInterval(function() {
                this.seconds++;
                console.log(this.seconds);
            }, 1000);
        }
    }
    ```

6.  Как организовать код в модули с помощью ES6 imports/exports?
7.  **Сценарий:** Вам нужно создать систему для интернет-магазина с товарами, корзиной и пользователями. Какие классы вы бы создали и как бы организовали их взаимодействие?